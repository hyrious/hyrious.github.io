<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>hyrious.log</title>
        <link>https://hyrious.me/</link>
        <description>hyrious.log</description>
        <lastBuildDate>Wed, 19 Jun 2024 10:14:25 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/jpmonette/feed</generator>
        <copyright>CC0 1.0</copyright>
        <atom:link href="https://hyrious.me/feed.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[基于 Lezer Parser 写一个 Formatter]]></title>
            <link>https://hyrious.me/p/lezer-formatter</link>
            <guid>lezer-formatter</guid>
            <pubDate>Wed, 19 Jun 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#032F62}.μ4{color:#6F42C1}.μ5{color:#E36209}.μ6{color:#6A737D}.μ7{color:#005CC5}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#9ECBFF}.μ4{color:#B392F0}.μ5{color:#FFAB70}.μ6{color:#6A737D}.μ7{color:#79B8FF}}</style><p>我不止一次萌生过自己写一个代码格式化工具的想法，但几乎都以失败告终。究其原因，正如 Anthony Fn 在 <a target="_blank" rel="noopener" href="https://antfu.me/posts/why-not-prettier-zh">为什么我不使用 Prettier</a> 中抱怨的，Prettier 这个工具总是有一些不尽如人意的格式化结果。但这一次，我发现了一个简单的实现方式。</p>
<p>Prettier 的 <a target="_blank" rel="noopener" href="https://prettier.io/docs/en/technical-details">实现方式</a> 十分容易理解：首先将代码解析成 AST，然后对着它重新输出一遍格式化好的代码。有趣的地方是他在输出一个子语法树的时候，可以对比不同的输出方式（比如使用换行或者不换行）来决定最<q>好看</q>的结果。</p>
<blockquote>
<p>上述步骤有一个小坑，就是解析 AST 的库（例如 Acorn）通常在遇到语法错误时会直接退出解析，这使得语法不正确的代码无法被格式化。实际上 Prettier 现在就有这样的问题。</p>
</blockquote>
<p>也就是说，如果要按 Prettier 方式写一个新的格式化工具，至少需要以下几个基础设施：</p>
<ul>
<li>一个 Parser 用于把代码解析成 token 或者 AST；</li>
<li>Token 身上要有一定的上下文信息，从而决定 <code>foo()</code> 的括号前面没有空格，而 <code>for ()</code> 的括号前面有空格。</li>
</ul>
<p>诶，Acorn 作者写的另一个库 <a target="_blank" rel="noopener" href="https://lezer.codemirror.net">Lezer</a> 似乎刚好满足要求。而且他还能从语法错误中恢复解析，简直是针对这个需求量身定制的一样。</p>
<p>下面就来试试！</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">import</span><span class="μ2"> { parser } </span><span class="μ1">from</span><span class="μ3"> '@lezer/javascript'</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> tree </span><span class="μ1">=</span><span class="μ2"> parser.</span><span class="μ4">parse</span><span class="μ2">(</span><span class="μ3">'let a=1'</span><span class="μ2">)</span></span>
<span class="line"><span class="μ2">tree.</span><span class="μ4">iterate</span><span class="μ2">({</span></span>
<span class="line"><span class="μ4">  enter</span><span class="μ2">(</span><span class="μ5">node</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ2">    console.</span><span class="μ4">log</span><span class="μ2">(node.name, node.from, node.to)</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ2">})</span></span>
<span class="line"><span class="μ6">// Script 0 7</span></span>
<span class="line"><span class="μ6">// VariableDeclaration 0 7</span></span>
<span class="line"><span class="μ6">// let 0 3</span></span>
<span class="line"><span class="μ6">// VariableDefinition 4 5</span></span>
<span class="line"><span class="μ6">// Equals 5 6</span></span>
<span class="line"><span class="μ6">// Number 6 7</span></span></code></pre>
<p>最细粒度的 token 一定都存储在叶子结点上，如何只输出叶子结点呢？观察 <code>enter</code> 和 <code>leave</code> 的调用规律不难看出，只有 <code>enter</code> 后面紧跟着一个 <code>leave</code> 的结点才是叶子结点，所以可以这么写：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> enter </span><span class="μ1">=</span><span class="μ7"> false</span></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> input </span><span class="μ1">=</span><span class="μ3"> 'let a=1'</span></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> tree </span><span class="μ1">=</span><span class="μ2"> parser.</span><span class="μ4">parse</span><span class="μ2">(input)</span></span>
<span class="line"><span class="μ2">tree.</span><span class="μ4">iterate</span><span class="μ2">({</span></span>
<span class="line"><span class="μ4">  enter</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ2">    enter </span><span class="μ1">=</span><span class="μ7"> true</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ4">  leave</span><span class="μ2">(</span><span class="μ5">node</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">    if</span><span class="μ2"> (enter) {</span></span>
<span class="line"><span class="μ2">      console.</span><span class="μ4">log</span><span class="μ2">(node.name, [input.</span><span class="μ4">slice</span><span class="μ2">(node.from, node.to)])</span></span>
<span class="line"><span class="μ2">    }</span></span>
<span class="line"><span class="μ2">    enter </span><span class="μ1">=</span><span class="μ7"> false</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ2">})</span></span>
<span class="line"><span class="μ6">// let [ 'let' ]</span></span>
<span class="line"><span class="μ6">// VariableDefinition [ 'a' ]</span></span>
<span class="line"><span class="μ6">// Equals [ '=' ]</span></span>
<span class="line"><span class="μ6">// Number [ '1' ]</span></span></code></pre>
<p>上面的几个 token 直接 <code>.join(&#39; &#39;)</code> 似乎就可以得到想要的结果了，但如果是这样呢 &darr;</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> input </span><span class="μ1">=</span><span class="μ3"> 'let a=1,b'</span></span>
<span class="line"><span class="μ6">// let [ 'let' ]</span></span>
<span class="line"><span class="μ6">// VariableDefinition [ 'a' ]</span></span>
<span class="line"><span class="μ6">// Equals [ '=' ]</span></span>
<span class="line"><span class="μ6">// Number [ '1' ]</span></span>
<span class="line"><span class="μ6">// , [ ',' ]</span></span>
<span class="line"><span class="μ6">// VariableDefinition [ 'b' ]</span></span></code></pre>
<p>诶，这个 <code>,</code> 前面不应该有空格。嗯，看来可以对每个 <code>node.name</code> 增加一个是否有前后空格的配置：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ4"> spaceAfter</span><span class="μ1"> =</span><span class="μ2"> (</span><span class="μ5">s</span><span class="μ2">) </span><span class="μ1">=></span><span class="μ2"> s </span><span class="μ1">+</span><span class="μ3"> ' '</span></span>
<span class="line"><span class="μ1">let</span><span class="μ4"> spaceBefore</span><span class="μ1"> =</span><span class="μ2"> (</span><span class="μ5">s</span><span class="μ2">) </span><span class="μ1">=></span><span class="μ3"> ' '</span><span class="μ1"> +</span><span class="μ2"> s</span></span>
<span class="line"><span class="μ1">let</span><span class="μ4"> spaceAround</span><span class="μ1"> =</span><span class="μ2"> (</span><span class="μ5">s</span><span class="μ2">) </span><span class="μ1">=></span><span class="μ3"> ' '</span><span class="μ1"> +</span><span class="μ2"> s </span><span class="μ1">+</span><span class="μ3"> ' '</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> spec </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ3">','</span><span class="μ2">]: spaceAfter,</span></span>
<span class="line"><span class="μ2">  let: spaceAfter,</span></span>
<span class="line"><span class="μ2">  Equals: spaceAround,</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> out </span><span class="μ1">=</span><span class="μ3"> ''</span></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> enter </span><span class="μ1">=</span><span class="μ7"> false</span></span>
<span class="line"><span class="μ2">tree.</span><span class="μ4">iterate</span><span class="μ2">({</span></span>
<span class="line"><span class="μ4">  enter</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ2">    enter </span><span class="μ1">=</span><span class="μ7"> true</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ4">  leave</span><span class="μ2">(</span><span class="μ5">node</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">    if</span><span class="μ2"> (enter) {</span></span>
<span class="line"><span class="μ1">      let</span><span class="μ2"> f </span><span class="μ1">=</span><span class="μ2"> spec[node.name]</span></span>
<span class="line"><span class="μ1">      let</span><span class="μ2"> s </span><span class="μ1">=</span><span class="μ2"> input.</span><span class="μ4">slice</span><span class="μ2">(node.from, node.to)</span></span>
<span class="line"><span class="μ2">      out </span><span class="μ1">+=</span><span class="μ2"> f </span><span class="μ1">?</span><span class="μ4"> f</span><span class="μ2">(s) </span><span class="μ1">:</span><span class="μ2"> s</span></span>
<span class="line"><span class="μ2">    }</span></span>
<span class="line"><span class="μ2">    enter </span><span class="μ1">=</span><span class="μ7"> false</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ2">})</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(out) </span><span class="μ6">// let a = 1, b</span></span></code></pre>
<p>如果代码中间有换行呢？</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> input </span><span class="μ1">=</span><span class="μ3"> 'let a=1</span><span class="μ7">\n</span><span class="μ3">let b=2'</span></span>
<span class="line"><span class="μ6">// out = 'let a = 1let b = 2'</span></span></code></pre>
<p>可以在每次 <code>+= code</code> 时，判断前面有没有跳过换行，有的话手动补一下：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ6">// before `out += f ? f(s) : s`</span></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> newline </span><span class="μ1">=</span><span class="μ4"> count_newline</span><span class="μ2">(input.</span><span class="μ4">slice</span><span class="μ2">(last.to, node.from))</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (newline) {</span></span>
<span class="line"><span class="μ2">  out </span><span class="μ1">=</span><span class="μ2"> out.</span><span class="μ4">trimEnd</span><span class="μ2">()</span></span>
<span class="line"><span class="μ2">  out </span><span class="μ1">+=</span><span class="μ2"> newline </span><span class="μ1">></span><span class="μ7"> 1</span><span class="μ1"> ?</span><span class="μ3"> '</span><span class="μ7">\n\n</span><span class="μ3">'</span><span class="μ1"> :</span><span class="μ3"> '</span><span class="μ7">\n</span><span class="μ3">'</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">function</span><span class="μ4"> count_newline</span><span class="μ2">(</span><span class="μ5">s</span><span class="μ1">:</span><span class="μ7"> string</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  let</span><span class="μ2"> count </span><span class="μ1">=</span><span class="μ7"> 0</span></span>
<span class="line"><span class="μ1">  let</span><span class="μ2"> index </span><span class="μ1">=</span><span class="μ1"> -</span><span class="μ7">1</span></span>
<span class="line"><span class="μ1">  do</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ2">    index </span><span class="μ1">=</span><span class="μ2"> s.</span><span class="μ4">indexOf</span><span class="μ2">(</span><span class="μ3">'</span><span class="μ7">\n</span><span class="μ3">'</span><span class="μ2">, index </span><span class="μ1">+</span><span class="μ7"> 1</span><span class="μ2">)</span></span>
<span class="line"><span class="μ1">    if</span><span class="μ2"> (index </span><span class="μ1">>=</span><span class="μ7"> 0</span><span class="μ2">) count</span><span class="μ1">++</span></span>
<span class="line"><span class="μ2">  } </span><span class="μ1">while</span><span class="μ2"> (index </span><span class="μ1">>=</span><span class="μ7"> 0</span><span class="μ2">)</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ2"> count</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>类似的，我们也可以手动保留缩进、折叠重复的空格等等。下面来看另一个问题：如何根据上下文输出不同的文本？</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">for</span><span class="μ2">() </span><span class="μ6">// => `for ()`</span></span></code></pre>
<p>这里既然有 <code>enter</code> 和 <code>leave</code>，那么维护一个 scope 栈自然不是难事：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> scope </span><span class="μ1">=</span><span class="μ2"> []</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">tree.</span><span class="μ4">iterate</span><span class="μ2">({</span></span>
<span class="line"><span class="μ4">  enter</span><span class="μ2">(</span><span class="μ5">node</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ2">    scope.</span><span class="μ4">push</span><span class="μ2">(node.name)</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ4">  leave</span><span class="μ2">(</span><span class="μ5">node</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ2">    scope.</span><span class="μ4">pop</span><span class="μ2">()</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ2">})</span></span></code></pre>
<p>把这个 <code>scope</code> 传给上面的配置函数，就可以根据上下文输出不同的文本了：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> spec </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ3">'('</span><span class="μ2">](</span><span class="μ5">s</span><span class="μ2">, </span><span class="μ5">scope</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">    if</span><span class="μ2"> (scope.</span><span class="μ4">includes</span><span class="μ2">(</span><span class="μ3">'ForSpec'</span><span class="μ2">)) </span><span class="μ1">return</span><span class="μ4"> spaceBefore</span><span class="μ2">(s)</span></span>
<span class="line"><span class="μ1">    return</span><span class="μ2"> s</span></span>
<span class="line"><span class="μ2">  },</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>如果你感兴趣的话，这里有 <a target="_blank" rel="noopener" href="https://gist.github.com/hyrious/a2d3b22009a6d5a3b09e368254f139f9">完整的代码</a> 。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Electron 实现多窗口踩坑]]></title>
            <link>https://hyrious.me/p/electron-multi-window-tips</link>
            <guid>electron-multi-window-tips</guid>
            <pubDate>Fri, 31 May 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#6F42C1}.μ4{color:#032F62}.μ5{color:#005CC5}.μ6{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#B392F0}.μ4{color:#9ECBFF}.μ5{color:#79B8FF}.μ6{color:#FFAB70}}</style><p>想在 electron 里打开一个新窗口，除了在主进程 <code>new BrowserWindow()</code> 外，也可以在渲染进程执行 <code>window.open()</code>。后者其实在正常浏览器里也可以用来打开弹窗，而且如果没有跨域限制的话，可以随意访问和修改后者的 <code>document</code>：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> w </span><span class="μ1">=</span><span class="μ2"> window.</span><span class="μ3">open</span><span class="μ2">(</span><span class="μ4">"about:blank"</span><span class="μ2">, </span><span class="μ4">''</span><span class="μ2">, </span><span class="μ4">'popup'</span><span class="μ2">)</span></span>
<span class="line"><span class="μ2">w.document.body.</span><span class="μ3">append</span><span class="μ2">(</span><span class="μ4">'Hello, world!'</span><span class="μ2">)</span></span></code></pre>
<p>甚至你在主窗口里创建的元素也可以被塞进这个新窗口的 DOM 里：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">w.document.body.</span><span class="μ3">appendChild</span><span class="μ2">(document.</span><span class="μ3">createElement</span><span class="μ2">(</span><span class="μ4">'h1'</span><span class="μ2">)).textContent </span><span class="μ1">=</span><span class="μ4"> 'Hello world!'</span></span></code></pre>
<p>但是，注意到这两个窗口的 JS 对象其实都不共享：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">document.</span><span class="μ3">createElement</span><span class="μ2">(</span><span class="μ4">'h1'</span><span class="μ2">) </span><span class="μ1">instanceof</span><span class="μ3"> w</span><span class="μ2">.</span><span class="μ3">HTMLElement</span><span class="μ1"> ===</span><span class="μ5"> false</span></span>
<span class="line"><span class="μ2">Uint8Array.</span><span class="μ3">of</span><span class="μ2">(</span><span class="μ5">1</span><span class="μ2">) </span><span class="μ1">instanceof</span><span class="μ3"> w</span><span class="μ2">.</span><span class="μ3">Uint8Array</span><span class="μ1"> ===</span><span class="μ5"> false</span></span></code></pre>
<p>这就会导致一些库的逻辑出现问题，例如 <a target="_blank" rel="noopener" href="https://hyrious.me/npm-browser/?q=rc-util@5.41.0/package/es/Dom/findDOMNode.js:7"><code>rc-util</code></a>：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">function</span><span class="μ3"> isDOM</span><span class="μ2">(</span><span class="μ6">node</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ2"> node </span><span class="μ1">instanceof</span><span class="μ3"> HTMLElement</span><span class="μ1"> ||</span><span class="μ2"> node </span><span class="μ1">instanceof</span><span class="μ3"> SVGElement</span><span class="μ2">;</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>想要在跨 <code>window</code> 情况下判断正确就不能依赖 <code>instanceof</code>，来看 <code>lodash</code> 里的实现：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">function</span><span class="μ3"> isElement</span><span class="μ2">(</span><span class="μ6">value</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ3"> isObjectLike</span><span class="μ2">(value) </span><span class="μ1">&#x26;&#x26;</span><span class="μ2"> value.nodeType </span><span class="μ1">===</span><span class="μ5"> 1</span><span class="μ1"> &#x26;&#x26;</span><span class="μ1"> !</span><span class="μ3">isPlainObject</span><span class="μ2">(value);</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>而且靠 <code>window.open()</code> 打开的窗口有一个小缺点，就是刷新这个窗口时，其网址如果是无效的（比如 <code>about:blank</code>）那么这个窗口就废了。</p>
<p>这么看来最稳妥的实现办法还是给这个窗口内容写一个独立的页面（当然可以通过 SPA 方式加载同一个页面只是 query / hash 不一样），窗口间通信使用 SharedWorker 或者在主进程里写一个简单的广播协议，不过这么一来要写的代码就比上面的多了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Debug 生产环境的 Electron 应用]]></title>
            <link>https://hyrious.me/p/debug-prod-electron</link>
            <guid>debug-prod-electron</guid>
            <pubDate>Thu, 28 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#24292E}.μ2{color:#6F42C1}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#E1E4E8}.μ2{color:#B392F0}}</style><p>首先启动应用，在任务管理器 / 活动监视器里找到该应用主进程的 PID，注意只有不带 Helper 后缀的才是主进程。</p>
<p>然后用 Node.js 往这个进程发送 <code>SIGUSR1</code> 信号：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">process.</span><span class="μ2">_debugProcess</span><span class="μ1">(pid)</span></span></code></pre>
<p>然后 Chrome 打开 <code>chrome://inspect</code> 就可以开始调试了。</p>
<p>当然开发者还是可以针对特定信号做防御的，比如 NTQQ 就会直接退出。</p>
<p>不过我还是建议就算是生产环境也保留开发者工具选项。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[过定点的贝塞尔曲线]]></title>
            <link>https://hyrious.me/p/bezier-through-points</link>
            <guid>bezier-through-points</guid>
            <pubDate>Fri, 08 Mar 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6A737D}.μ2{color:#005CC5}.μ3{color:#24292E}.μ4{color:#6F42C1}.μ5{color:#D73A49}.μ6{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#6A737D}.μ2{color:#79B8FF}.μ3{color:#E1E4E8}.μ4{color:#B392F0}.μ5{color:#F97583}.μ6{color:#FFAB70}}</style><blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://apoorvaj.io/cubic-bezier-through-four-points/">&laquo;Constructing a cubic Bezier that passes through four points&raquo;</a></p>
</blockquote>
<iframe src="https://hyrious.me/i/bezier-through-points.html" width="100%" height="300px"></iframe>

<p>将折线变为曲线有很多种算法，一个常规的方法是使用二阶贝塞尔 (含有一个控制点)，取每个相邻顶点组成的线段的中点作为起始/结束点，取顶点作为控制点：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">// 先连接一条直线到第一个中点</span></span>
<span class="line"><span class="μ2">M</span><span class="μ3"> p0 </span><span class="μ2">L</span><span class="μ4"> mid</span><span class="μ3">(p0, p1)</span></span>
<span class="line"><span class="μ1">// 将下一个顶点作为控制点，连接到下一个中点</span></span>
<span class="line"><span class="μ2">Q</span><span class="μ3"> p1 </span><span class="μ4">mid</span><span class="μ3">(p0, p1)</span></span>
<span class="line"><span class="μ5">...</span></span>
<span class="line"><span class="μ2">Q</span><span class="μ3"> p_n</span><span class="μ5">-</span><span class="μ2">2</span><span class="μ4"> mid</span><span class="μ3">(p_n</span><span class="μ5">-</span><span class="μ2">2</span><span class="μ3">, p_n</span><span class="μ5">-</span><span class="μ2">1</span><span class="μ3">)</span></span>
<span class="line"><span class="μ1">// 最后连接一条直线到最后一个中点</span></span>
<span class="line"><span class="μ2">L</span><span class="μ3"> p_n</span><span class="μ5">-</span><span class="μ2">1</span></span></code></pre>
<p>这个算法相当简单，而且注意到他是一个在线算法，即不需要等待所有输入都到达就能不断产生输出。但它有一个缺陷：几乎所有的顶点都不在曲线上。其实，只需要稍加修改即可让<q>在曲线上</q>这个条件成立一半：每次取两个顶点，一个作为控制点一个作为终点，这里就不贴代码了。不过这么一来其实曲线的精度损失了一部分，有没有更好的算法呢？</p>
<h3 id="一个简单的思路">一个简单的思路</h3>
<blockquote>
<p>出处：<a target="_blank" rel="noopener" href="https://agg.sourceforge.net/antigrain.com/research/bezier_interpolation/index.html">&laquo;Interpolation with Bezier Curves: A very simple method of smoothing polygons&raquo;</a><br>不过这个方法太简单了估计很多人也能自行想到。</p>
</blockquote>
<p>对于三阶贝塞尔，其实就是看是否能根据已有信息计算出最适合的控制点。假设我们有三个点形成一个角：</p>
<pre><code>        A
       /
   ?. /
     B------C
      `?
</code></pre><p>其实就是看如何找到上图中的 <code>?</code> 的位置。显然，控制点似乎和 AC 有关，不妨取 BA、BC 的中点 D、E，连接 DE。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">D</span><span class="μ5"> =</span><span class="μ4"> mid</span><span class="μ3">(</span><span class="μ2">B</span><span class="μ3">, </span><span class="μ2">A</span><span class="μ3">)</span></span>
<span class="line"><span class="μ2">E</span><span class="μ5"> =</span><span class="μ4"> mid</span><span class="μ3">(</span><span class="μ2">B</span><span class="μ3">, </span><span class="μ2">C</span><span class="μ3">)</span></span></code></pre>
<p>接下来平移 DE 到使得 B 在 DE 上，如何平移呢？不妨按 BA、BC 的长度比例，使得 DB : BE = BA : BC。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ3">p </span><span class="μ5">=</span><span class="μ4"> dis</span><span class="μ3">(</span><span class="μ2">B</span><span class="μ3">, </span><span class="μ2">A</span><span class="μ3">) </span><span class="μ5">/</span><span class="μ3"> (</span><span class="μ4">dis</span><span class="μ3">(</span><span class="μ2">B</span><span class="μ3">, </span><span class="μ2">A</span><span class="μ3">) </span><span class="μ5">+</span><span class="μ4"> dis</span><span class="μ3">(</span><span class="μ2">B</span><span class="μ3">, </span><span class="μ2">C</span><span class="μ3">))</span></span>
<span class="line"><span class="μ2">O</span><span class="μ5"> =</span><span class="μ2"> D</span><span class="μ5"> +</span><span class="μ3"> (</span><span class="μ2">E</span><span class="μ5"> -</span><span class="μ2"> D</span><span class="μ3">) </span><span class="μ5">*</span><span class="μ3"> p </span><span class="μ1">// 取 DE 上一点 O 符合比例</span></span>
<span class="line"><span class="μ2">D</span><span class="μ5"> =</span><span class="μ2"> D</span><span class="μ5"> +</span><span class="μ3"> (</span><span class="μ2">O</span><span class="μ5"> -</span><span class="μ2"> B</span><span class="μ3">) </span><span class="μ1">// 平移 DO 到 DB</span></span>
<span class="line"><span class="μ2">E</span><span class="μ5"> =</span><span class="μ2"> E</span><span class="μ5"> +</span><span class="μ3"> (</span><span class="μ2">O</span><span class="μ5"> -</span><span class="μ2"> B</span><span class="μ3">) </span><span class="μ1">// 平移 EO 到 EB</span></span>
<span class="line"><span class="μ1">// 现在 D、E 就是我们要找的控制点了</span></span></code></pre>
<h3 id="centripetal-catmullrom-spline-算法以及他的贝塞尔形式">Centripetal Catmull&ndash;Rom spline 算法以及他的贝塞尔形式</h3>
<p>贝塞尔曲线定义为两个顶点和一些控制点，而不是一列他需要经过的点 (我们最开始就是想要从一列输入点得到通过他们的曲线)，有没有一种曲线是定义为一组需要经过的点的呢？有，那就是 <a target="_blank" rel="noopener" href="http://www.cemyuksel.com/research/catmullrom_param/catmullrom_cad.pdf">Catmull-Rom 曲线</a>。贝塞尔曲线和 Catmull-Rom 曲线本质上都是用三次方程描述一条曲线，因此他们是可以互相转换的，下面就给出转换后的形式：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4271em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span>
<span class="katex-display"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:2.4271em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.4911em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord">3</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mopen">(</span><span class="mord">2</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord">3</span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-2.4519em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2481em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mord">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<!-- prettier-ignore -->
<p>其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2083em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord">∣</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.0037em;">α</span></span></span></span></span></span></span></span></span></span></span> 即和线段长度有关的一个值，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span> 取 0.5。代码如下：</p>
<!-- prettier-ignore -->
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">function</span><span class="μ4"> refit_bezier</span><span class="μ3">(</span><span class="μ6">p0</span><span class="μ3">, </span><span class="μ6">p1</span><span class="μ3">, </span><span class="μ6">p2</span><span class="μ3">, </span><span class="μ6">p3</span><span class="μ3">, </span><span class="μ6">t1</span><span class="μ3">, </span><span class="μ6">t2</span><span class="μ3">) {</span></span>
<span class="line"><span class="μ5">  let</span><span class="μ3"> d1 </span><span class="μ5">=</span><span class="μ3"> Math.</span><span class="μ4">pow</span><span class="μ3">(Math.</span><span class="μ4">hypot</span><span class="μ3">(p1.x </span><span class="μ5">-</span><span class="μ3"> p0.x, p1.y </span><span class="μ5">-</span><span class="μ3"> p0.y), </span><span class="μ2">0.5</span><span class="μ3">)</span></span>
<span class="line"><span class="μ5">  let</span><span class="μ3"> d2 </span><span class="μ5">=</span><span class="μ3"> Math.</span><span class="μ4">pow</span><span class="μ3">(Math.</span><span class="μ4">hypot</span><span class="μ3">(p2.x </span><span class="μ5">-</span><span class="μ3"> p1.x, p2.y </span><span class="μ5">-</span><span class="μ3"> p1.y), </span><span class="μ2">0.5</span><span class="μ3">)</span></span>
<span class="line"><span class="μ5">  let</span><span class="μ3"> d3 </span><span class="μ5">=</span><span class="μ3"> Math.</span><span class="μ4">pow</span><span class="μ3">(Math.</span><span class="μ4">hypot</span><span class="μ3">(p3.x </span><span class="μ5">-</span><span class="μ3"> p2.x, p3.y </span><span class="μ5">-</span><span class="μ3"> p2.y), </span><span class="μ2">0.5</span><span class="μ3">)</span></span>
<span class="line"><span class="μ1">  /* modify t1 */</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ5">    let</span><span class="μ3"> a </span><span class="μ5">=</span><span class="μ3"> d1 </span><span class="μ5">*</span><span class="μ3"> d1, b </span><span class="μ5">=</span><span class="μ3"> d2 </span><span class="μ5">*</span><span class="μ3"> d2, c </span><span class="μ5">=</span><span class="μ2"> 2</span><span class="μ5"> *</span><span class="μ3"> a </span><span class="μ5">+</span><span class="μ2"> 3</span><span class="μ5"> *</span><span class="μ3"> d1 </span><span class="μ5">*</span><span class="μ3"> d2 </span><span class="μ5">+</span><span class="μ3"> b, d </span><span class="μ5">=</span><span class="μ2"> 3</span><span class="μ5"> *</span><span class="μ3"> d1 </span><span class="μ5">*</span><span class="μ3"> (d1 </span><span class="μ5">+</span><span class="μ3"> d2)</span></span>
<span class="line"><span class="μ3">    t1.x </span><span class="μ5">=</span><span class="μ3"> (a </span><span class="μ5">*</span><span class="μ3"> p2.x </span><span class="μ5">-</span><span class="μ3"> b </span><span class="μ5">*</span><span class="μ3"> p0.x </span><span class="μ5">+</span><span class="μ3"> c </span><span class="μ5">*</span><span class="μ3"> p1.x) </span><span class="μ5">/</span><span class="μ3"> d</span></span>
<span class="line"><span class="μ3">    t1.y </span><span class="μ5">=</span><span class="μ3"> (a </span><span class="μ5">*</span><span class="μ3"> p2.y </span><span class="μ5">-</span><span class="μ3"> b </span><span class="μ5">*</span><span class="μ3"> p0.y </span><span class="μ5">+</span><span class="μ3"> c </span><span class="μ5">*</span><span class="μ3"> p1.y) </span><span class="μ5">/</span><span class="μ3"> d</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ1">  /* modify t2 */</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ5">    let</span><span class="μ3"> a </span><span class="μ5">=</span><span class="μ3"> d3 </span><span class="μ5">*</span><span class="μ3"> d3, b </span><span class="μ5">=</span><span class="μ3"> d2 </span><span class="μ5">*</span><span class="μ3"> d2, c </span><span class="μ5">=</span><span class="μ2"> 2</span><span class="μ5"> *</span><span class="μ3"> a </span><span class="μ5">+</span><span class="μ2"> 3</span><span class="μ5"> *</span><span class="μ3"> d3 </span><span class="μ5">*</span><span class="μ3"> d2 </span><span class="μ5">+</span><span class="μ3"> b, d </span><span class="μ5">=</span><span class="μ2"> 3</span><span class="μ5"> *</span><span class="μ3"> d3 </span><span class="μ5">*</span><span class="μ3"> (d3 </span><span class="μ5">+</span><span class="μ3"> d2)</span></span>
<span class="line"><span class="μ3">    t2.x </span><span class="μ5">=</span><span class="μ3"> (a </span><span class="μ5">*</span><span class="μ3"> p1.x </span><span class="μ5">-</span><span class="μ3"> b </span><span class="μ5">*</span><span class="μ3"> p3.x </span><span class="μ5">+</span><span class="μ3"> c </span><span class="μ5">*</span><span class="μ3"> p2.x) </span><span class="μ5">/</span><span class="μ3"> d</span></span>
<span class="line"><span class="μ3">    t2.y </span><span class="μ5">=</span><span class="μ3"> (a </span><span class="μ5">*</span><span class="μ3"> p1.y </span><span class="μ5">-</span><span class="μ3"> b </span><span class="μ5">*</span><span class="μ3"> p3.y </span><span class="μ5">+</span><span class="μ3"> c </span><span class="μ5">*</span><span class="μ3"> p2.y) </span><span class="μ5">/</span><span class="μ3"> d</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<h3 id="fit-curve-离线算法">Fit curve 离线算法</h3>
<blockquote>
<p>出处：&laquo;Algorithm for Automatically Fitting Digitized Curves&raquo; by Philip J. Schneider, &quot;Graphics Gems&quot;, Academic Press, 1990.
<a target="_blank" rel="noopener" href="https://github.com/odiak/fit-curve/blob/master/packages/fit-curve/src/index.ts">JavaScript 实现</a>、<a target="_blank" rel="noopener" href="https://github.com/soswow/fit-curve">另一个实现</a></p>
</blockquote>
<p>考虑到<q>拟合</q>目的，我们可以用牛顿二分法对原折线做切分，直到每个子折线都满足一定的误差要求。这个算法在 <a target="_blank" rel="noopener" href="http://paperjs.org/examples/path-simplification/">Papar.js</a> 里实现为一个路径简化算法。</p>
<p>这种算法算出的贝塞尔曲线是数据量最少且效果最好的，但是由于是离线算法，可能需要和别的算法结合使用。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[网格布局一把梭]]></title>
            <link>https://hyrious.me/p/css-subgrid</link>
            <guid>css-subgrid</guid>
            <pubDate>Mon, 22 Jan 2024 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#24292E}.μ2{color:#22863A}.μ3{color:#6F42C1}.μ4{color:#032F62}.μ5{color:#005CC5}.μ6{color:#D73A49}.μ7{color:#6A737D}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#E1E4E8}.μ2{color:#85E89D}.μ3{color:#B392F0}.μ4{color:#9ECBFF}.μ5{color:#79B8FF}.μ6{color:#F97583}.μ7{color:#6A737D}}</style><blockquote>
<p>参考：<a target="_blank" rel="noopener" href="https://web.dev/articles/css-subgrid">https://web.dev/articles/css-subgrid</a></p>
</blockquote>
<p>自从 <code>subgrid</code> 被<a target="_blank" rel="noopener" href="https://caniuse.com/css-subgrid">广泛支持</a>后，网格布局系统终于可以在前端被当成一把梭的存在 (和 <code>flex</code> 平起平坐了)，下面就来看看。</p>
<p>来看这么一个例子 (取自 <a target="_blank" rel="noopener" href="https://meyerweb.com/eric/thoughts/2016/01/15/subgrids-considered-essential/">Subgrids Considered Essential</a>)：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">&#x3C;</span><span class="μ2">ul</span><span class="μ1">></span></span>
<span class="line"><span class="μ1">  &#x3C;</span><span class="μ2">li</span><span class="μ1">>&#x3C;</span><span class="μ2">label</span><span class="μ1">>Name:&#x3C;/</span><span class="μ2">label</span><span class="μ1">> &#x3C;</span><span class="μ2">input</span><span class="μ3"> id</span><span class="μ1">=</span><span class="μ4">"name"</span><span class="μ1">>&#x3C;/</span><span class="μ2">li</span><span class="μ1">></span></span>
<span class="line"><span class="μ1">  &#x3C;</span><span class="μ2">li</span><span class="μ1">>&#x3C;</span><span class="μ2">label</span><span class="μ1">>Email:&#x3C;/</span><span class="μ2">label</span><span class="μ1">> &#x3C;</span><span class="μ2">input</span><span class="μ3"> id</span><span class="μ1">=</span><span class="μ4">"email"</span><span class="μ1">>&#x3C;/</span><span class="μ2">li</span><span class="μ1">></span></span>
<span class="line"><span class="μ1">  &#x3C;</span><span class="μ2">li</span><span class="μ1">>&#x3C;</span><span class="μ2">label</span><span class="μ1">>Password:&#x3C;/</span><span class="μ2">label</span><span class="μ1">> &#x3C;</span><span class="μ2">input</span><span class="μ3"> id</span><span class="μ1">=</span><span class="μ4">"password"</span><span class="μ1">>&#x3C;/</span><span class="μ2">li</span><span class="μ1">></span></span>
<span class="line"><span class="μ1">&#x3C;/</span><span class="μ2">ul</span><span class="μ1">></span></span></code></pre>
<p>你的设计师朋友：这几个 label 能不能加个纵向对齐？</p>
<p>除了强行给 <code>&lt;label&gt;</code> 加个估算的 <code>width</code> 外，其实用 <code>subgrid</code> 就可以实现：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">ul</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ5">  display</span><span class="μ1">: </span><span class="μ5">grid</span><span class="μ1">;</span></span>
<span class="line"><span class="μ5">  grid-template-columns</span><span class="μ1">: [column-1] </span><span class="μ5">max-content</span><span class="μ1"> [column-2] </span><span class="μ5">1</span><span class="μ6">fr</span><span class="μ1"> [</span><span class="μ5">end</span><span class="μ1">];</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ2">ul</span><span class="μ2"> li</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ5">  grid-column</span><span class="μ1">: span </span><span class="μ5">2</span><span class="μ1">;</span></span>
<span class="line"><span class="μ5">  display</span><span class="μ1">: </span><span class="μ5">grid</span><span class="μ1">;</span></span>
<span class="line"><span class="μ5">  grid-template-columns</span><span class="μ1">: </span><span class="μ5">subgrid</span><span class="μ1">;</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre>
<p>简单解释几点：</p>
<ul>
<li><code>[name]</code> 是用来给<strong>格线</strong>命名的，也可以不命名直接从 1 开始数 (或者从右侧 -1 开始数)，也就是说本例中 <code>[column-1]</code> 实际上等于 1，<code>[end]</code> 实际上等于 3 或者 -1</li>
<li><code>grid-template-columns: max-content 1fr</code> 设置了这样一个网格：<br>一共两列，第一列宽度是其内容的最大宽度，第二列是占满剩下的宽度</li>
<li><code>grid-column</code> 是一个缩写属性，表示本元素在父网格中<strong>开始</strong>到<strong>结束</strong>的列<strong>格线</strong>，以下几个表示的都是<q>前两格</q>：<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">ul</span><span class="μ2"> li</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ5">  grid-column</span><span class="μ1">: </span><span class="μ5">1</span><span class="μ1"> / </span><span class="μ5">3</span><span class="μ1">;</span></span>
<span class="line"><span class="μ5">  grid-column</span><span class="μ1">: </span><span class="μ5">1</span><span class="μ1"> / span </span><span class="μ5">2</span><span class="μ1">;</span></span>
<span class="line"><span class="μ5">  grid-column</span><span class="μ1">: span </span><span class="μ5">2</span><span class="μ1">;</span></span>
<span class="line"><span class="μ5">  grid-column</span><span class="μ1">: column-1 / </span><span class="μ5">end</span><span class="μ1">; </span><span class="μ7">/* 可以通过命名更直观地表示范围 */</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre>
本例中，<code>&lt;li&gt;</code> 元素需要占满宽度，所以直接框选了一行里的所有格子</li>
<li><code>grid-template-columns: subgrid</code> 表示此网格继承父元素的网格位置，也就是刚刚用 <code>grid-column: span 2</code> 框住的两列</li>
<li>所以我们现在有 1 + 3 个 <code>display: grid</code>，其中 <code>&lt;ul&gt;</code> 是三行两列的，而每个 <code>&lt;li&gt;</code> 各自占住一行并且是两列的，并且他们的<q>两列</q>完全是同一个逻辑网格里的</li>
</ul>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[最小 tsconfig.json]]></title>
            <link>https://hyrious.me/p/minimal-tsconfig</link>
            <guid>minimal-tsconfig</guid>
            <pubDate>Mon, 18 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#24292E}.μ2{color:#005CC5}.μ3{color:#032F62}.μ4{color:#D73A49}.μ5{color:#6F42C1}.μ6{color:#6A737D}.μ7{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#E1E4E8}.μ2{color:#79B8FF}.μ3{color:#9ECBFF}.μ4{color:#F97583}.μ5{color:#B392F0}.μ6{color:#6A737D}.μ7{color:#FFAB70}}</style><p>TypeScript 发展至今积累了许多过时配置项以及重复配置项，本文试图按现在<a target="_blank" rel="noopener" href="https://aka.ms/tsconfig">最新</a>的文档，给出最小的 tsconfig.json 配置。</p>
<h3 id="tldr">TL;DR</h3>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">{</span></span>
<span class="line"><span class="μ2">  "compilerOptions"</span><span class="μ1">: {</span></span>
<span class="line"><span class="μ2">    "strict"</span><span class="μ1">: </span><span class="μ2">true</span><span class="μ1">,</span></span>
<span class="line"><span class="μ2">    "target"</span><span class="μ1">: </span><span class="μ3">"ESNext"</span></span>
<span class="line"><span class="μ1">  }</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre>
<p>如果你有第三方库，建议增加以下配置：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">{</span></span>
<span class="line"><span class="μ2">  "compilerOptions"</span><span class="μ1">: {</span></span>
<span class="line"><span class="μ2">    "strict"</span><span class="μ1">: </span><span class="μ2">true</span><span class="μ1">,</span></span>
<span class="line"><span class="μ2">    "target"</span><span class="μ1">: </span><span class="μ3">"ESNext"</span><span class="μ1">,</span></span>
<span class="line"><span class="μ2">    "module"</span><span class="μ1">: </span><span class="μ3">"Preserve"</span><span class="μ1">,</span></span>
<span class="line"><span class="μ2">    "types"</span><span class="μ1">: [],</span></span>
<span class="line"><span class="μ2">    "skipLibCheck"</span><span class="μ1">: </span><span class="μ2">true</span><span class="μ1">,</span></span>
<span class="line"><span class="μ2">    "noEmit"</span><span class="μ1">: </span><span class="μ2">true</span><span class="μ1">,</span></span>
<span class="line"><span class="μ2">    "verbatimModuleSyntax"</span><span class="μ1">: </span><span class="μ2">true</span></span>
<span class="line"><span class="μ1">  }</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre>
<h3 id="解释">解释</h3>
<h4 id="strict"><code>strict</code></h4>
<p>开启严格模式，比如不允许含有 <code>null</code> 的类型通过检查。</p>
<pre class="shiki shiki-themes github-light github-dark twoslash lsp μ0" tabindex="0"><code><span class="line"><span class="μ4">declare</span><span class="μ4"> const</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">const</span><span class="μ2"> a</span><span class="μ4">:</span><span class="μ2"> string</span><span class="μ4"> |</span><span class="μ2"> null</span></code></span>a</span></span><span class="μ4">:</span><span class="μ2"> string</span><span class="μ4"> |</span><span class="μ2"> null</span></span>
<span class="line"><span class="twoslash-error"><span class="μ1">a</span></span><span class="μ1">.</span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">String.</span><span class="μ2">length</span><span class="μ1">: number</span></code><div class="twoslash-popup-docs">Returns the length of a String object.</div></span>length</span></span></span><div class="twoslash-meta-line twoslash-error-line">'a' is possibly 'null'.</div></code></pre>
<p>这个严格模式代替了其他 8 个建议开启的配置项，我就不一一列举了，文末会附上一些更严格的选项，用户按需打开。</p>
<h4 id="target"><code>target</code></h4>
<p>代码降级和默认 <code>lib</code>，类比 esbuild 的 <code>target</code>，不填是 <code>ES5</code>。例如，当 <code>target</code> 是 <code>ES5</code> 时，<code>let a = 1</code> 会变成 <code>var a = 1</code>。如果不使用 <code>tsc</code> 编译出 js 文件，这里的降级对我们没有意义。</p>
<p>当 <code>target</code> 是 <code>ES6</code> 及以上时，会默认设置：</p>
<ul>
<li><code>lib</code> 为 <code>[&quot;DOM&quot;, &quot;DOM.Iterable&quot;, ...]</code>；</li>
<li><code>module</code> 为 <code>ES6</code>，<ul>
<li><code>moduleResolution</code> 为 <code>Node</code>。</li>
</ul>
</li>
</ul>
<p>因此大多数情况下，你只需要设置 <code>target</code> 为 <code>ESNext</code> 即可使用最新的语法和 ESM 环境。</p>
<h4 id="module"><code>module</code></h4>
<p>使用哪种模块类型，是 ESM 还是 CJS，类比 esbuild 的 <code>format</code>。不填时，当 <code>target</code> 是 <code>ES6</code> 以上时默认是为 <code>ES6</code>。</p>
<p>由于现代前端主流就是推行 ESM，这里设置为以下任何一个变体的即可。</p>
<table>
<thead>
<tr>
<th>module</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ES6/ES2015</td>
<td>支持 import / export</td>
</tr>
<tr>
<td>ES2020</td>
<td>增加了 import() / import.meta 支持</td>
</tr>
<tr>
<td>ES2022/ESNext</td>
<td>增加了 top level await 支持</td>
</tr>
<tr>
<td>Node16/NodeNext</td>
<td>等于 ES2020/ESNext，但是强制要求文件名后缀匹配</td>
</tr>
<tr>
<td><strong>Preserve</strong></td>
<td><strong>交给用户或者打包器决定，不再产生报错</strong></td>
</tr>
</tbody></table>
<h4 id="moduleresolution"><code>moduleResolution</code></h4>
<p>要求按何种算法搜索 <code>import</code> 后面的路径，使用现代打包器的建议设置为 <code>Bundler</code>。</p>
<p>当你使用 <code>module: &quot;Preserve&quot;</code> 时，<code>moduleResolution: &quot;Bundler&quot;</code> 默认开启。</p>
<h4 id="esmoduleinterop"><code>esModuleInterop</code></h4>
<p>影响如何使用第三方库的默认导出名，使用现代打包器的这里无脑打开即可。</p>
<p>如果你没有第三方库，根本无需这个选项。</p>
<p>当你使用 <code>module: &quot;Preserve&quot;</code> 时，<code>esModuleInterop: true</code> 默认开启。</p>
<h4 id="types-node"><code>types: [&quot;node&quot;]</code></h4>
<p>设置导入哪些污染全局的类型声明，比如 <code>@types/node</code>。默认不填的话所有 <code>node_modules/@types</code> 里的类型都会注入到全局，如果你觉得这个行为慢或者不安全，可以手动设置。</p>
<h4 id="skiplibcheck"><code>skipLibCheck</code></h4>
<p>所有 d.ts 文件不再报告错误或警告，通常是用来规避一些第三方库的类型冲突问题。</p>
<h4 id="noemit"><code>noEmit</code></h4>
<p>打开这个选项主要是为了规避文件名冲突问题，<code>tsc</code> 默认会假设你会运行他来生成目标 js 文件，如果这个生成会覆盖已有文件就会报错。你可以看情况打开这个选项告诉他不会生成 js。</p>
<h4 id="verbatimmodulesyntax"><code>verbatimModuleSyntax</code></h4>
<p>强制要求类型导入必须使用 <code>import type</code>，方便第三方打包器分析文件依赖的时候不产生循环引用。</p>
<h3 id="附includeexcludefiles">附：<code>include/exclude/files</code></h3>
<p>这几个选项会用来决定当前<q>项目</q>里有哪些文件，TypeScript 会使用以下几种行为。</p>
<ul>
<li>啥也没设置的话，从 tsconfig.json 当前文件夹递归搜索所有 .ts 文件，跳过默认 exclude 的文件 (比如 node_modules)。</li>
<li>设置了 <code>files</code> 就直接用这个数组里的文件，不再搜索。</li>
<li>设置了 <code>include</code> 或 <code>exclude</code> 就执行这个搜索算法：<code>glob(include).reject(exclude)</code>。</li>
</ul>
<p>因此最无脑的选择是直接把 tsconfig.json 放到 src 目录里。</p>
<h3 id="附超级严格选项">附：超级严格选项</h3>
<h5 id="nofallthroughcasesinswitch-true">noFallthroughCasesInSwitch: true</h5>
<p>不允许直接 fallthrough 到下一个 case，除非用 <code>// @ts-expect-error</code> 绕过。</p>
<pre class="shiki shiki-themes github-light github-dark twoslash lsp μ0" tabindex="0"><code><span class="line"><span class="μ4">const</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">const</span><span class="μ2"> a</span><span class="μ4">:</span><span class="μ2"> number</span></code></span>a</span></span><span class="μ4">:</span><span class="μ2"> number</span><span class="μ4"> =</span><span class="μ2"> 6</span><span class="μ1">;</span></span>
<span class="line"></span>
<span class="line"><span class="μ4">switch</span><span class="μ1"> (</span><span class="μ1"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">const</span><span class="μ2"> a</span><span class="μ4">:</span><span class="μ2"> number</span></code></span>a</span></span><span class="μ1">) {</span></span>
<span class="line"><span class="μ4">  </span><span class="twoslash-error"><span class="μ4">case</span><span class="μ2"> 0</span><span class="μ1">:</span></span></span><div class="twoslash-meta-line twoslash-error-line">Fallthrough case in switch.</div><span class="line"><span class="μ1">    </span><span class="μ1"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">var</span><span class="μ1"> console</span><span class="μ4">:</span><span class="μ5"> Console</span></code></span>console</span></span><span class="μ1">.</span><span class="μ5"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">Console.</span><span class="μ5">log</span><span class="μ1">(</span><span class="μ4">...</span><span class="μ1">data: any[]): </span><span class="μ4">void</span></code><div class="twoslash-popup-docs">[MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static)</div></span>log</span></span><span class="μ1">(</span><span class="μ3">"even"</span><span class="μ1">);</span></span>
<span class="line"><span class="μ4">  case</span><span class="μ2"> 1</span><span class="μ1">:</span></span>
<span class="line"><span class="μ1">    </span><span class="μ1"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">var</span><span class="μ1"> console</span><span class="μ4">:</span><span class="μ5"> Console</span></code></span>console</span></span><span class="μ1">.</span><span class="μ5"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">Console.</span><span class="μ5">log</span><span class="μ1">(</span><span class="μ4">...</span><span class="μ1">data: any[]): </span><span class="μ4">void</span></code><div class="twoslash-popup-docs">[MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static)</div></span>log</span></span><span class="μ1">(</span><span class="μ3">"odd"</span><span class="μ1">);</span></span>
<span class="line"><span class="μ4">    break</span><span class="μ1">;</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ4">switch</span><span class="μ1"> (</span><span class="μ1"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">const</span><span class="μ2"> a</span><span class="μ4">:</span><span class="μ2"> number</span></code></span>a</span></span><span class="μ1">) {</span></span>
<span class="line"><span class="μ6">  // @ts-expect-error</span></span>
<span class="line"><span class="μ4">  case</span><span class="μ2"> 0</span><span class="μ1">:</span></span>
<span class="line"><span class="μ1">    </span><span class="μ1"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">var</span><span class="μ1"> console</span><span class="μ4">:</span><span class="μ5"> Console</span></code></span>console</span></span><span class="μ1">.</span><span class="μ5"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">Console.</span><span class="μ5">log</span><span class="μ1">(</span><span class="μ4">...</span><span class="μ1">data: any[]): </span><span class="μ4">void</span></code><div class="twoslash-popup-docs">[MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static)</div></span>log</span></span><span class="μ1">(</span><span class="μ3">"even"</span><span class="μ1">);</span></span>
<span class="line"><span class="μ4">  case</span><span class="μ2"> 1</span><span class="μ1">:</span></span>
<span class="line"><span class="μ1">    </span><span class="μ1"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">var</span><span class="μ1"> console</span><span class="μ4">:</span><span class="μ5"> Console</span></code></span>console</span></span><span class="μ1">.</span><span class="μ5"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">Console.</span><span class="μ5">log</span><span class="μ1">(</span><span class="μ4">...</span><span class="μ1">data: any[]): </span><span class="μ4">void</span></code><div class="twoslash-popup-docs">[MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static)</div></span>log</span></span><span class="μ1">(</span><span class="μ3">"odd"</span><span class="μ1">);</span></span>
<span class="line"><span class="μ4">    break</span><span class="μ1">;</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre>
<h5 id="noimplicitoverride-true">noImplicitOverride: true</h5>
<p>不允许直接覆盖父类的方法，除非加一个 <code>override</code> 关键字。</p>
<h5 id="noimplicitreturns-true">noImplicitReturns: true</h5>
<p>不允许不写 <code>return</code>。</p>
<h5 id="nopropertyaccessfromindexsignature-true">noPropertyAccessFromIndexSignature: true</h5>
<p>不允许用 <code>.</code> 访问未知下标属性。</p>
<h5 id="nouncheckedindexedaccess-true">noUncheckedIndexedAccess: true</h5>
<p>访问未知下标属性的时候会自动加上 <code>| undefined</code>。</p>
<h5 id="nounusedlocals-true">noUnusedLocals: true</h5>
<p>不允许出现未使用的局部变量，真有可以加前缀 <code>_</code>。</p>
<h5 id="nounusedparameters-true">noUnusedParameters: true</h5>
<p>不允许出现未使用的参数，真有可以加前缀 <code>_</code>。</p>
<hr>
<p><time>2024-01-24</time> 更新</p>
<p>TypeScript 还有一个无配置文件模式，当然这个模式下默认是不开 <code>strict</code> 的，来看看实际上会造成什么问题：</p>
<ol start="0">
<li><code>target: &quot;es5&quot;</code>，不使用 <code>tsc</code> 编译的话其实没啥影响</li>
<li><code>alwaysStrict: false</code>，默认不产生 <code>&quot;use strict&quot;</code></li>
<li><code>noImplicitAny: false</code>，隐式 <code>any</code> 不会报错，所以你可以写下面这个东东<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">window.foo </span><span class="μ4">=</span><span class="μ3"> 'bar'</span></span>
<span class="line"><span class="μ6">// 否则你必须标记成</span></span>
<span class="line"><span class="μ1">(window </span><span class="μ4">as</span><span class="μ2"> any</span><span class="μ1">).foo </span><span class="μ4">=</span><span class="μ3"> 'bar'</span></span></code></pre>
</li>
<li><code>noImplicitThis: false</code>，<code>this</code> 不标类型不会报错，所以你可以写下面这个东东<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ4">function</span><span class="μ5"> foo</span><span class="μ1">() { </span><span class="μ4">return</span><span class="μ2"> this</span><span class="μ1">.bar }</span></span>
<span class="line"><span class="μ6">// 否则你必须标记成</span></span>
<span class="line"><span class="μ4">function</span><span class="μ5"> foo</span><span class="μ1">(</span><span class="μ2">this</span><span class="μ4">:</span><span class="μ1"> { </span><span class="μ7">bar</span><span class="μ4">:</span><span class="μ2"> unknown</span><span class="μ1"> }) { </span><span class="μ4">return</span><span class="μ2"> this</span><span class="μ1">.bar }</span></span></code></pre>
</li>
<li><code>strictNullChecks: false</code>，不会检查 <code>null | undefined</code>，但是目前 VS Code 和 Sublime LSP TypeScript 都是默认开启这个检查的 (有可能是 tsserver 默认开启)，所以实际上可以理解成仍然会检查 null。下面这段代码可以用 tsc 编译过但是常见编辑器里会有提示<pre class="shiki shiki-themes github-light github-dark twoslash lsp μ0" tabindex="0"><code><span class="line"><span class="μ4">declare</span><span class="μ4"> const</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">const</span><span class="μ2"> a</span><span class="μ4">:</span><span class="μ2"> string</span><span class="μ4"> |</span><span class="μ2"> null</span></code></span>a</span></span><span class="μ4">:</span><span class="μ2"> string</span><span class="μ4"> |</span><span class="μ2"> null</span></span>
<span class="line"><span class="μ1"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ4">var</span><span class="μ1"> console</span><span class="μ4">:</span><span class="μ5"> Console</span></code></span>console</span></span><span class="μ1">.</span><span class="μ5"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">Console.</span><span class="μ5">log</span><span class="μ1">(</span><span class="μ4">...</span><span class="μ1">data: any[]): </span><span class="μ4">void</span></code><div class="twoslash-popup-docs">[MDN Reference](https://developer.mozilla.org/docs/Web/API/console/log_static)</div></span>log</span></span><span class="μ1">(</span><span class="twoslash-error"><span class="μ1">a</span></span><span class="μ1">.</span><span class="μ5"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">String.</span><span class="μ5">toLowerCase</span><span class="μ1">(): string</span></code><div class="twoslash-popup-docs">Converts all the alphabetic characters in a string to lowercase.</div></span>toLowerCase</span></span><span class="μ1">())</span></span><div class="twoslash-meta-line twoslash-error-line">'a' is possibly 'null'.</div></code></pre>
</li>
<li><code>strictPropertyInitialization: false</code>，不会检查未初始化的属性<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ4">class</span><span class="μ5"> Foo</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ7">  bar</span><span class="μ4">:</span><span class="μ2"> string</span><span class="μ1">;</span></span>
<span class="line"><span class="μ4">  constructor</span><span class="μ1">() {</span></span>
<span class="line"><span class="μ6">    // Not initializing 'bar' here and no error</span></span>
<span class="line"><span class="μ1">  }</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre>
</li>
<li><code>useUnknownInCatchVariables: false</code>，<code>catch(error)</code> 默认用 any 类型。其实在规范的项目里我希望 <code>error</code> 直接隐式标成 <code>Error</code>，这样 <code>.message</code> 比较容易</li>
<li>你可以正常使用 <code>import { uniq } from &quot;lodash&quot;</code> 和 <code>import.meta.url</code> 等语法</li>
<li>但是不能写 top level await，这个功能必须要设置 <code>module: &quot;ESNext&quot; / &quot;ES2022&quot;</code></li>
</ol>
<hr>
<p><time>2024-05-23</time> 更新</p>
<p>最近 TypeScript 5.4 新增了一个 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-5-4.html#support-for-require-calls-in---moduleresolution-bundler-and---module-preserve"><code>module: &quot;Preserve&quot;</code></a>
配置项，可以让 TypeScript 在看到混合语法时不报错（通常这是由作者自己的打包器处理的），并且省下三个常用配置项：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ3">"moduleResolution"</span><span class="μ1">: </span><span class="μ3">"bundler"</span><span class="μ1">,</span></span>
<span class="line"><span class="μ3">"esModuleInterop"</span><span class="μ1">: </span><span class="μ2">true</span><span class="μ1">,</span></span>
<span class="line"><span class="μ3">"resolveJsonModule"</span><span class="μ1">: </span><span class="μ2">true</span><span class="μ1">,</span></span></code></pre>
<p>另外，我将常用的 <code>tsconfig.json</code> 发到了一个包里：<a target="_blank" rel="noopener" href="https://github.com/hyrious/configs">https://github.com/hyrious/configs</a></p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TypeScript 小技巧]]></title>
            <link>https://hyrious.me/p/typescript-tips</link>
            <guid>typescript-tips</guid>
            <pubDate>Fri, 15 Dec 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#6F42C1}.μ3{color:#24292E}.μ4{color:#E36209}.μ5{color:#005CC5}.μ6{color:#6A737D}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#B392F0}.μ3{color:#E1E4E8}.μ4{color:#FFAB70}.μ5{color:#79B8FF}.μ6{color:#6A737D}}</style><h3 id="implicit-nominal-typing">Implicit Nominal Typing</h3>
<p>不知道中文该叫什么，<q>隐式标称类型</q>？咳咳，简单来说我们想标记一类特定的对象是某个类型的，但是又没有也不想在他身上加个脏脏的标记字段，如下面的例子：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ2"> Foo</span><span class="μ3"> {}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">class</span><span class="μ2"> Bar</span><span class="μ3"> {}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> foo</span><span class="μ1">:</span><span class="μ2"> Foo</span><span class="μ1"> =</span><span class="μ1"> new</span><span class="μ2"> Bar</span><span class="μ3">()</span></span></code></pre>
<p>明明是两个类，但是其中一个的实例居然可以直接赋值成另一个类型。为了不让这么操作，可以要求 <code>Foo</code> 身上有个 <code>Bar</code> 身上没有的东西，可以往他身上添加一个不存在的私有属性来达到目的：</p>
<pre class="shiki shiki-themes github-light github-dark twoslash lsp μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">class</span><span class="μ2"> Foo</span></code></span>Foo</span></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ1">  private</span><span class="μ1"> declare</span><span class="μ4"> </span><span class="μ4"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ3">Foo._isFoo: </span><span class="μ5">true</span></code></span>_isFoo</span></span><span class="μ1">:</span><span class="μ5"> true</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">class</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">class</span><span class="μ2"> Bar</span></code></span>Bar</span></span><span class="μ3"> {}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> </span><span class="twoslash-error"><span class="μ3">foo</span></span><span class="μ1">:</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">class</span><span class="μ2"> Foo</span></code></span>Foo</span></span><span class="μ1"> =</span><span class="μ1"> new</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ3">constructor </span><span class="μ2">Bar</span><span class="μ3">(): Bar</span></code></span>Bar</span></span><span class="μ3">()</span></span><div class="twoslash-meta-line twoslash-error-line">Property '_isFoo' is missing in type 'Bar' but required in type 'Foo'.</div></code></pre>
<p>这里有两个标记使得他变得如此好用：</p>
<ul>
<li><p><code>private</code> 决定了它仍然可以产生类型标记，但禁止了上层用户直接访问，你只能通过构造函数来实例化这个特殊的类型：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ6">// 生成的 d.ts</span></span>
<span class="line"><span class="μ1">declare</span><span class="μ1"> class</span><span class="μ2"> Foo</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ1">  private</span><span class="μ4"> _isFoo</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
</li>
<li><p><code>declare</code> 决定了这个属性只是个标记而没有实体，因此生成的 JavaScript 也很干净：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ6">// 生成的 js</span></span>
<span class="line"><span class="μ1">class</span><span class="μ2"> Foo</span><span class="μ3"> {}</span></span></code></pre>
</li>
</ul>
<p>如果你设置了 <a target="_blank" rel="noopener" href="https://www.typescriptlang.org/tsconfig#useDefineForClassFields"><code>useDefineForClassFields: false</code></a>，也可以省略 <code>declare</code> 换成 <code>!</code>。</p>
<h4 id="shared-nominal-typing">Shared Nominal Typing</h4>
<p>上文往 <code>class</code> 上添加了私有属性，如果是往 <code>interface</code> 上加呢？诶，我们发现 <code>private</code> 是保不住了，但是可以让一些类共享同一个类型，而且用户一般不会自己尝试实现这个类型：</p>
<pre class="shiki shiki-themes github-light github-dark twoslash lsp μ0" tabindex="0"><code><span class="line"><span class="μ1">type</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">type</span><span class="μ2"> FooLike</span><span class="μ1"> =</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">    _isFoo</span><span class="μ1">:</span><span class="μ2"> FooLike</span><span class="μ3">;</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre></code></span>FooLike</span></span><span class="μ1"> =</span><span class="μ3"> { </span><span class="μ4"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ2">_isFoo</span><span class="μ3">: FooLike</span></code></span>_isFoo</span></span><span class="μ1">:</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover twoslash-query-presisted"><span class="twoslash-popup-container"><div class="twoslash-popup-arrow"></div><code class="twoslash-popup-code"><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">type</span><span class="μ2"> FooLike</span><span class="μ1"> =</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">    _isFoo</span><span class="μ1">:</span><span class="μ2"> FooLike</span><span class="μ3">;</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre></code></span>FooLike</span></span><span class="μ3"> }</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">class</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">class</span><span class="μ2"> Bar</span></code></span>Bar</span></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ1">  declare</span><span class="μ4"> </span><span class="μ4"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ3">Bar._isFoo: </span><span class="μ5">this</span></code></span>_isFoo</span></span><span class="μ1">:</span><span class="μ5"> this</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> </span><span class="μ3"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">let</span><span class="μ3"> a</span><span class="μ1">:</span><span class="μ2"> FooLike</span></code></span>a</span></span><span class="μ1">:</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">type</span><span class="μ2"> FooLike</span><span class="μ1"> =</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">    _isFoo</span><span class="μ1">:</span><span class="μ2"> FooLike</span><span class="μ3">;</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre></code></span>FooLike</span></span><span class="μ1"> =</span><span class="μ1"> new</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ3">constructor </span><span class="μ2">Bar</span><span class="μ3">(): Bar</span></code></span>Bar</span></span><span class="μ3">()</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">class</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ1">class</span><span class="μ2"> UserDefined</span></code></span>UserDefined</span></span><span class="μ3"> {}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> </span><span class="twoslash-error"><span class="μ3">b</span></span><span class="μ1">:</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">type</span><span class="μ2"> FooLike</span><span class="μ1"> =</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">    _isFoo</span><span class="μ1">:</span><span class="μ2"> FooLike</span><span class="μ3">;</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre></code></span>FooLike</span></span><span class="μ1"> =</span><span class="μ1"> new</span><span class="μ2"> </span><span class="μ2"><span class="twoslash-hover"><span class="twoslash-popup-container"><code class="twoslash-popup-code"><span class="μ3">constructor </span><span class="μ2">UserDefined</span><span class="μ3">(): UserDefined</span></code></span>UserDefined</span></span><span class="μ3">()</span></span><div class="twoslash-meta-line twoslash-error-line">Property '_isFoo' is missing in type 'UserDefined' but required in type 'FooLike'.</div></code></pre>
<h3 id="tagged-value">Tagged Value</h3>
<p>传统 JavaScript 人的做法是存一个 <code>{ type: string, value }</code>，写起来不免有些繁琐而且不利于代码压缩。我们可以考虑下面这个写法：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ2"> Value</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">> {</span></span>
<span class="line"><span class="μ6">  /** </span><span class="μ1">@internal</span><span class="μ6"> */</span></span>
<span class="line"><span class="μ1">  constructor</span><span class="μ3">(</span><span class="μ1">readonly</span><span class="μ4"> type</span><span class="μ1">:</span><span class="μ2"> Type</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">>, </span><span class="μ1">readonly</span><span class="μ4"> value</span><span class="μ1">:</span><span class="μ2"> T</span><span class="μ3">) {}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">  static</span><span class="μ2"> define</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">>() {</span></span>
<span class="line"><span class="μ1">    return</span><span class="μ1"> new</span><span class="μ2"> Type</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">>()</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">  is</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">>(</span><span class="μ4">type</span><span class="μ1">:</span><span class="μ2"> Type</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">>)</span><span class="μ1">:</span><span class="μ5"> this</span><span class="μ1"> is</span><span class="μ2"> Value</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">> {</span></span>
<span class="line"><span class="μ1">    return</span><span class="μ5"> this</span><span class="μ3">.type </span><span class="μ1">===</span><span class="μ3"> type</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">class</span><span class="μ2"> Type</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">> {</span></span>
<span class="line"><span class="μ2">  of</span><span class="μ3">(</span><span class="μ4">value</span><span class="μ1">:</span><span class="μ2"> T</span><span class="μ3">)</span><span class="μ1">:</span><span class="μ2"> Value</span><span class="μ3">&#x3C;</span><span class="μ2">T</span><span class="μ3">> {</span></span>
<span class="line"><span class="μ1">    return</span><span class="μ1"> new</span><span class="μ2"> Value</span><span class="μ3">(</span><span class="μ5">this</span><span class="μ3">, value)</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ6">// 定义一个类型叫温度</span></span>
<span class="line"><span class="μ1">const</span><span class="μ5"> temperature</span><span class="μ1"> =</span><span class="μ3"> Value</span><span class="μ1">&#x3C;</span><span class="μ3">number</span><span class="μ1">></span><span class="μ3">.</span><span class="μ2">define</span><span class="μ3">()</span></span>
<span class="line"></span>
<span class="line"><span class="μ6">// 实例化这个类型</span></span>
<span class="line"><span class="μ1">const</span><span class="μ5"> a</span><span class="μ1"> =</span><span class="μ3"> temperature.</span><span class="μ2">of</span><span class="μ3">(</span><span class="μ5">42</span><span class="μ3">)</span></span>
<span class="line"><span class="μ3">a.</span><span class="μ2">is</span><span class="μ3">(temperature) </span><span class="μ6">// true</span></span></code></pre>
<p>注意到 <code>@internal</code> 标记，这使得最终用户不能看到这个构造，也就可以要求一定通过指定的工厂函数实例化自定义类型了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[代码分割并不简单]]></title>
            <link>https://hyrious.me/p/code-splitting-is-not-trivial</link>
            <guid>code-splitting-is-not-trivial</guid>
            <pubDate>Mon, 27 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6A737D}.μ2{color:#D73A49}.μ3{color:#24292E}.μ4{color:#005CC5}.μ5{color:#032F62}.μ6{color:#6F42C1}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#6A737D}.μ2{color:#F97583}.μ3{color:#E1E4E8}.μ4{color:#79B8FF}.μ5{color:#9ECBFF}.μ6{color:#B392F0}}</style><p>Code Splitting 一直是前端性能优化的一个重要手段，但是如此重要的功能在 <a target="_blank" rel="noopener" href="https://esbuild.github.io/api/#splitting">esbuild</a> 中时至今日仍然是实验性的，这是为什么呢？下面就来看看。</p>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>考虑下面这段代码：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">// shared.js</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> let</span><span class="μ3"> util </span><span class="μ2">=</span><span class="μ4"> 1</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">// a.js (entry)</span></span>
<span class="line"><span class="μ2">import</span><span class="μ3"> { util } </span><span class="μ2">from</span><span class="μ5"> './shared.js'</span></span>
<span class="line"><span class="μ2">import</span><span class="μ3"> b </span><span class="μ2">from</span><span class="μ5"> './b.js'</span></span>
<span class="line"><span class="μ6">foo</span><span class="μ3">(b, util)</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">// b.js (entry)</span></span>
<span class="line"><span class="μ2">import</span><span class="μ3"> { util } </span><span class="μ2">from</span><span class="μ5"> './shared.js'</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> default</span><span class="μ6"> bar</span><span class="μ3">(util)</span></span></code></pre>
<p>如果我要你对 a.js 和 b.js 进行打包，且要求仅打包出两个文件，如何对敌？</p>
<p>简单来说，此时你必须决定把 shared.js 放入某个文件里，而这次「放入」实际上产生了某种程度上说可以称之为错误的结果，下面就来看看：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">// dist/a.js (a + shared)</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> let</span><span class="μ3"> util </span><span class="μ2">=</span><span class="μ4"> 1</span></span>
<span class="line"><span class="μ2">import</span><span class="μ3"> b </span><span class="μ2">from</span><span class="μ5"> './b.js'</span><span class="μ1"> // a -> b</span></span>
<span class="line"><span class="μ6">foo</span><span class="μ3">(b, util)</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">// dist/b.js (b)</span></span>
<span class="line"><span class="μ2">import</span><span class="μ3"> { util } </span><span class="μ2">from</span><span class="μ5"> './a.js'</span><span class="μ1"> // b -> a</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> default</span><span class="μ6"> bar</span><span class="μ3">(util)</span></span></code></pre>
<p>可以观察到：竟然出现了循环引用！实际上光是在 dist/a.js 中创建出 <code>util</code> 这个导出都是有问题的——因为原文件 a.js 没有要你导出 <code>util</code>。</p>
<p>语义上的事情暂且放到一边，接下来看看运行时效果是否正确。因为 a.js 和 b.js 都是入口文件，理论上他们都可能被单独执行。然而，当你运行 dist/a.js 时，他要 import dist/b.js，所以 bar() 先执行；当你运行 dist/b.js 时，他要 import dist/a.js，所以 foo() 先执行。🤯</p>
<p>但是我们看一下源文件，b.js 压根没有依赖 a.js，所以理论上来说执行 b.js 时不应该执行 foo() 才对。</p>
<h3 id="副作用管理没有平凡解">副作用管理没有<abbr title="trivial">平凡</abbr>解</h3>
<p>我们的软件功能基于副作用工作，大部分<abbr title="imperative">命令式</abbr>编程语言需要代码按顺序运行。考虑下面的代码，从语法上说他们是分离的语法树，但是由于引用关系，一些代码必须要在其他一些代码之后执行：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">class</span><span class="μ6"> A</span><span class="μ3"> {} </span><span class="μ1">// [1]</span></span>
<span class="line"><span class="μ4">A</span><span class="μ3">.foo </span><span class="μ2">=</span><span class="μ4"> 1</span><span class="μ1"> // [2] 必须在 [1] 之后执行</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">// [3] 「似乎」不需要在 [1] 之后执行</span></span>
<span class="line"><span class="μ2">function</span><span class="μ6"> foo</span><span class="μ3">() {</span></span>
<span class="line"><span class="μ2">  return</span><span class="μ2"> new</span><span class="μ6"> A</span><span class="μ3">()</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ6">foo</span><span class="μ3">() </span><span class="μ1">// [4] 如果你不知道 foo() 里在干什么，你无法确定 [4] 要在 [1] 之后执行</span></span></code></pre>
<p>实际上，追踪语法树之间的<strong>实际执行顺序</strong>关系太复杂了 (光是引用关系还好说，但是在 JavaScript 中可以轻易出现交叉引用)，各种隐式的依赖关系几乎不可能分析完整。因为打包器无法知道产物具体是如何运行的，只能尽最大努力兼容所有情况，出现 <a target="_blank" rel="noopener" href="https://github.com/evanw/esbuild/issues/399">bug</a> 也是常有的。</p>
<h3 id="如何实践">如何实践</h3>
<p>对于库作者，尽量发布 ESM 格式的纯函数包。如果要依赖副作用，可以手动包装成工厂函数或者其他形式实现懒惰加载，如此一来等到运行时，相关副作用代码大概率已经被执行过了，就不怕顺序问题了。另外，尽量不要出现循环引用，打包器通常很难决定在这种情况下哪个文件先执行。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">// bundle.js</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> function</span><span class="μ6"> foo</span><span class="μ3">() {</span></span>
<span class="line"><span class="μ2">  return</span><span class="μ2"> new</span><span class="μ6"> A</span><span class="μ3">()</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"><span class="μ2">class</span><span class="μ6"> A</span><span class="μ3"> {} </span><span class="μ1">// 假设 class A {} 被打包器挪到了后面</span></span>
<span class="line"><span class="μ4">A</span><span class="μ3">.data </span><span class="μ2">=</span><span class="μ4"> 1</span><span class="μ1"> // 副作用</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">// main.js</span></span>
<span class="line"><span class="μ6">foo</span><span class="μ3">() </span><span class="μ1">// 用户代码执行的时候也不怕 A.data 未定义了</span></span></code></pre>
<p>对于终端开发者，如果你有 HTTP/2，可以无脑使用打包器的默认配置来分包，通常情况下会分出相当多的碎片，这主要是为了保证语义和运行顺序的正确性。不用担心碎片文件的性能问题，我们还有 <a target="_blank" rel="noopener" href="https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill">preload</a> 机制可以提前下载并解析模块。一句话概括，Just use <a target="_blank" rel="noopener" href="https://vitejs.dev/">Vite</a>。</p>
<p>如果你需要一定程度的手动配置 (<a target="_blank" rel="noopener" href="https://github.com/evanw/esbuild/issues/207">Manual chunks</a>)，目前 Rollup 和 webpack 各自实现了一套相对稳定的分包算法。而 esbuild 还没实现，不过你可以<a target="_blank" rel="noopener" href="https://github.com/hyrious/esbuild-split-vendors-example">手动</a>模拟 webpack 的效果。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CRDT 漫谈]]></title>
            <link>https://hyrious.me/p/crdt</link>
            <guid>crdt</guid>
            <pubDate>Thu, 23 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6F42C1}.μ2{color:#D73A49}.μ3{color:#24292E}.μ4{color:#005CC5}.μ5{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#B392F0}.μ2{color:#F97583}.μ3{color:#E1E4E8}.μ4{color:#79B8FF}.μ5{color:#FFAB70}}</style><p>以前写过一篇 <a href="./crdt-fractional-indexing">&laquo;CRDT: 分数排序&raquo;</a>。我认为，CRDT 可能是未来实现大部分软件的最佳选择。有了它，你就免费获得了离线编辑、协作、历史记录、撤销重做等等功能，传统的软件开发中以上任何一条都是非常难设计和实现的。</p>
<h3 id="定义">定义</h3>
<p>Conflict-free Replicated Data Type，无冲突数据结构。什么叫冲突？这通常需要根据具体场景来理解和定义，对于大家最熟悉的文本编辑场景，冲突就是两个或以上用户的编辑最终变成了重叠、错位、不一致的情况。CRDT 的目标就是针对各种不同的场景，<strong>分别</strong>设计出特定的数据结构，使得它们可以符合大多数人的预期、保持一致。由于 CRDT 不是一种，有的时候大家也会用 CRDTs 来代指所有的 CRDT。下文中还会列举一些常见的实现。</p>
<h4 id="问题框架">问题框架</h4>
<p>CRDT 要解决的问题必须都能用这个框架来描述。</p>
<blockquote>
<p>假设有一个无敌信道，可以让任何在里面的消息都广播到所有客户端，并且不会发生消息的丢失 (不用保证顺序)，那么如何基于它设计一个数据结构，使其可以满足某个协作场景的需求？</p>
</blockquote>
<p>简单来说要求有这样一个基建:</p>
<ul>
<li>消息全部到达，包括所有历史消息，不用保证顺序</li>
<li>消息不会重复</li>
</ul>
<p>&hellip;这在现实中当然是不存在的，于是具体应用就需要分别实现某些基建，这通常包括：</p>
<ul>
<li>一个存储服务，用于在所有设备都下线时保存最新的状态</li>
<li>一个消息队列，用于保证消息的到达 (但不用保证永久存储)<ul>
<li>基于 P2P 的实现有可能无法保证，此时需要客户端实现重试策略</li>
</ul>
</li>
<li>其他对业务有用的服务<ul>
<li>例如，一个同步观看视频的应用将需要同步设备的时间以对齐视频播放的位置</li>
</ul>
</li>
</ul>
<p>因此，如果有产品将以上基建封装成一个统一的服务，将会非常有利于 CRDT 应用的落地。</p>
<h4 id="本地优先软件">本地优先软件</h4>
<p>CRDT 非常适合用来制作本地优先软件 (Local-first software)。现如今人们通常接触的都是云应用 (或者你可以称其为 <abbr title="Software as a service">SaaS</abbr>)，你需要登录才能访问和使用你上传的数据。而一旦服务器宕机或者由于一些不可抗力，你珍贵的数据就会暂时消失一段时间。有了 CRDT，你的本地编辑历史会被持久化存储，就不怕内容丢失了。</p>
<p>当然，前面提到的问题可以通过本地多保存几次备份等土办法来解决。从另一个角度来说，本地优先的意义在于<q>让本地的修改优先发生</q>，也就是说用户应当立即看到操作的效果，而不是等服务器返回响应。否则运气不好的话用户每操作一会就得等应用转圈圈，这种体验是非常糟糕的。CRDT 上的修改都是立即生效的，就算网络断开也不会丢失这次的操作。</p>
<h4 id="什么时候不用-crdt">什么时候不用 CRDT？</h4>
<p>CRDT 的最低目标只是保证结果一致，而不保证总是符合预期。例如，<abbr title="Multiplayer Online Battle Arena">MOBA</abbr> 类游戏中对于伤害的结算需要有一个中心服务器进行裁决和下发以保证公平性。再比如，银行类系统会要求每次金融操作的原子性、一致性等硬标准，这些地方该转圈圈还是得转。</p>
<p>多人游戏的同步是又一个比较复杂的话题，以后有机会可以再展开。</p>
<h3 id="分类">分类</h3>
<p>有两大类 CRDT 的设计方向，一类是基于操作 (Operation) 的，也就是广播消息内容直接是<q>操作</q>，比如 (+1) (insert 0 &quot;hello&quot;) 之类的，现在主要流行的 CRDT 库大都是这类，也叫 <abbr title="Commutative replicated data types">CmRDTs</abbr>。另一类是基于状态 (State) 的，广播消息是本地的状态 (可以是全量或部分)，而接收端需要实现特殊的合并算法来算到最新状态，也叫 <abbr title="Convergent replicated data types">CvRDTs</abbr>。</p>
<h3 id="常见场景和实现">常见场景和实现</h3>
<p>下面有一些是纯学术构想的虚拟场景，有一些则是真实且有线上应用的。</p>
<h4 id="投票系统">投票系统</h4>
<p>假如你在做一个直播类软件，软件上有一个点赞按钮，所有观众都可以点击此按钮为主播的人气值 +1，你该如何实现：有一万个人同时点击这个按钮，如何让主播最终看到人气值 = 一万，且服务器不炸。</p>
<p><strong>解</strong>: 可以设计这样一种数据结构，它的消息体里只有一个 <code>1</code>，主播拿到消息后立刻增加人气值。回想上文中的信道，显然，既然消息都可以到达，那么最终收到的 <code>1</code> 的数量一定是完整的一万。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">点赞</span><span class="μ2"> =</span><span class="μ3"> () </span><span class="μ2">=></span><span class="μ3"> 观众.</span><span class="μ1">发送</span><span class="μ3">(</span><span class="μ4">1</span><span class="μ3">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">收到</span><span class="μ2"> =</span><span class="μ3"> (</span><span class="μ5">点赞</span><span class="μ3">) </span><span class="μ2">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">  this</span><span class="μ3">.人气值 </span><span class="μ2">+=</span><span class="μ3"> 点赞</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<h4 id="分组投票系统">分组投票系统</h4>
<p>还是上面的场景，但是你想看到具体每个人点了多少次赞。</p>
<p><strong>解</strong>: 可以让消息体里带上观众的 ID，主播那里分别统计每个人的点赞次数。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">点赞</span><span class="μ2"> =</span><span class="μ3"> () </span><span class="μ2">=></span><span class="μ3"> 观众.</span><span class="μ1">发送</span><span class="μ3">(</span><span class="μ4">this</span><span class="μ3">.id, </span><span class="μ4">1</span><span class="μ3">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">收到</span><span class="μ2"> =</span><span class="μ3"> ([</span><span class="μ5">谁</span><span class="μ3">, </span><span class="μ5">点赞</span><span class="μ3">]) </span><span class="μ2">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">  this</span><span class="μ3">.人气值[谁] </span><span class="μ2">+=</span><span class="μ3"> 点赞</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<h4 id="礼物系统-set">礼物系统 (Set)</h4>
<p>还是上面的场景，但是这次不要求统计赞数，而是要求知道主播收到了哪些种类的礼物。</p>
<p><strong>解</strong>: 可以让消息体里带上礼物的 ID，主播那里把收到的礼物 ID 放到一个集合里。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">发送礼物</span><span class="μ2"> =</span><span class="μ3"> () </span><span class="μ2">=></span><span class="μ3"> 观众.</span><span class="μ1">发送</span><span class="μ3">(礼物.id)</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">收到</span><span class="μ2"> =</span><span class="μ3"> ([</span><span class="μ5">谁</span><span class="μ3">, </span><span class="μ5">礼物</span><span class="μ3">]) </span><span class="μ2">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">  this</span><span class="μ3">.收到的[礼物] </span><span class="μ2">=</span><span class="μ4"> true</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<h4 id="知乎">知乎</h4>
<p>这次不光可以点赞，还可以点踩。只需要知道最后 <code>赞 - 踩</code> 是多少即可。</p>
<p><strong>解</strong>: 可以设计两种消息，一个 <code>+1</code>，一个 <code>-1</code>，主播累加所有消息。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">点赞</span><span class="μ2"> =</span><span class="μ3"> () </span><span class="μ2">=></span><span class="μ3"> 观众.</span><span class="μ1">发送</span><span class="μ3">(</span><span class="μ2">+</span><span class="μ4">1</span><span class="μ3">)</span></span>
<span class="line"><span class="μ1">点踩</span><span class="μ2"> =</span><span class="μ3"> () </span><span class="μ2">=></span><span class="μ3"> 观众.</span><span class="μ1">发送</span><span class="μ3">(</span><span class="μ2">-</span><span class="μ4">1</span><span class="μ3">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">收到</span><span class="μ2"> =</span><span class="μ3"> (</span><span class="μ5">点赞或点踩</span><span class="μ3">) </span><span class="μ2">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">  this</span><span class="μ3">.人气值 </span><span class="μ2">+=</span><span class="μ3"> 点赞或点踩</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<h4 id="通用-map">通用 (Map)</h4>
<p>对于一些元信息类的数据，只需要保留最后一次修改的结果。例如文章标题、卡片颜色等等。</p>
<p><strong>注意</strong>: 上文中的信道是不保序的，因此你不能依赖消息到达的顺序来实现。</p>
<p><strong>解</strong>: 可以使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lamport_timestamp">Lamport</a> 时钟来对消息进行排序，消息内容就是修改 <code>Map</code> 内容。</p>
<blockquote>
<p>Lamport 时钟是指这样一个数：初始化为 0，每次发送消息一起发出去且 +1，每次收到消息时设为最新消息的时钟 +1。</p>
</blockquote>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">写入</span><span class="μ2"> =</span><span class="μ3"> (</span><span class="μ5">key</span><span class="μ3">, </span><span class="μ5">value</span><span class="μ3">) </span><span class="μ2">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">  this</span><span class="μ3">.</span><span class="μ1">发送</span><span class="μ3">(</span><span class="μ4">this</span><span class="μ3">.lamport</span><span class="μ2">++</span><span class="μ3">, key, value)</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"><span class="μ1">收到</span><span class="μ2"> =</span><span class="μ3"> (</span><span class="μ5">lamport</span><span class="μ3">, </span><span class="μ5">key</span><span class="μ3">, </span><span class="μ5">value</span><span class="μ3">) </span><span class="μ2">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ2">  if</span><span class="μ3"> (</span><span class="μ4">this</span><span class="μ3">.lamport </span><span class="μ2">&#x3C;</span><span class="μ3"> lamport) {</span></span>
<span class="line"><span class="μ4">    this</span><span class="μ3">.lamport </span><span class="μ2">=</span><span class="μ3"> lamport </span><span class="μ2">+</span><span class="μ4"> 1</span></span>
<span class="line"><span class="μ4">    this</span><span class="μ3">.数据[key] </span><span class="μ2">=</span><span class="μ3"> value</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<h4 id="列表-list">列表 (List)</h4>
<p>对于记事本等小型列表场景，直接替换整个列表似乎有点浪费带宽。</p>
<p><a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-fractional-indexing/">Evan</a> 提出给元素增加一个分数信息表示列表位置的方法，详见 <a href="./crdt-fractional-indexing">&laquo;CRDT: 分数排序&raquo;</a>。</p>
<h4 id="文本-一种列表">文本 (一种列表)</h4>
<p>对于文本编辑器之类大量有序数据的场景，一个重要的需求是保证不重叠，例如两个人分别在同一个位置输入了 <code>ab</code> <code>cd</code>，合并结果可以是 <code>abcd</code> 或 <code>cdab</code>，但不能是 <code>acbd</code>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yjs">Yjs</a> 实现了一个名叫 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/452980520">YATA</a> 的算法，基本思想是保证 <code>a-b</code> 和 <code>c-d</code> 这两根线不能形成交叉。</p>
<p><a target="_blank" rel="noopener" href="https://www.loro.dev/blog/crdt-richtext">Loro</a> 实现了 Peritext 和 Fugue 两个新算法，能很好地支持富文本 (文本上有各种标记，如加粗变色等) 场景以及解决文本重叠问题。</p>
<h4 id="树-无环图">树 (无环图)</h4>
<p>如果只有 <code>Map</code>，你可以对每个节点存储其父节点的 ID 来实现图结构，但是这无法解决循环引用的问题。</p>
<p><a target="_blank" rel="noopener" href="https://www.loro.dev/blog/loro-now-open-source#movable-tree">Loro</a> 实现了一个拥有移动节点指令 (也就是<q>设置某个节点的父节点</q>) 的树形数据结构，其基本思想是插入适当的<q>撤销</q>操作来恢复树结构不能有环的约定。</p>
<p><a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-mutable-tree-hierarchy/">Evan</a> 实现了一个类似的算法。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Hello, world!]]></title>
            <link>https://hyrious.me/p/hello-world</link>
            <guid>hello-world</guid>
            <pubDate>Fri, 17 Nov 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6A737D}.μ2{color:#D73A49}.μ3{color:#005CC5}.μ4{color:#24292E}.μ5{color:#6F42C1}.μ6{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#6A737D}.μ2{color:#F97583}.μ3{color:#79B8FF}.μ4{color:#E1E4E8}.μ5{color:#B392F0}.μ6{color:#9ECBFF}}</style><p>我又㕛叕重写了一遍博客，这次用上了 <a target="_blank" rel="noopener" href="https://vitejs.dev/">Vite</a>。其实我以前用过不少博客生成器，包括 <a target="_blank" rel="noopener" href="https://jekyllrb.com/">Jekyll</a>、<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>、<a target="_blank" rel="noopener" href="https://www.gatsbyjs.com/">Gatsby</a> 等等，但是他们要么渲染太慢，要么安装成本太大。我<a target="_blank" rel="noopener" href="https://github.com/hyrious/hyrious/issues/5">曾经</a>口胡过详细的需求，简单来说我需要这个生成器拥有以下功能：</p>
<ul>
<li>支持无 JS 访问，也就是说整个页面只有 HTML 和 CSS 就应该能正常运行了</li>
<li>支持 <a target="_blank" rel="noopener" href="https://github.github.com/gfm/" title="GitHub Flavored Markdown">GFM</a>，因为源码放在 GitHub，最好能直接打开 GitHub 观看</li>
<li>仍然支持按需引入 JS 脚本，这样在我的博客上阅读时可以有更丰富的体验</li>
<li>[优化] 支持秒级刷新，这样编辑时基本不会打断思路（我时不时就想看看渲染结果）</li>
</ul>
<p>我曾经试过手撸 HTML 源码，这样确实灵活性很高且只需要<abbr title="不含学习 HTML 和 CSS 的时间">成本为零</abbr>的先验知识，但是遇到代码高亮等读写都比较麻烦的内容还是不够方便。后来我写了一个 <a target="_blank" rel="noopener" href="https://github.com/hyrious/telegraph">telegraph</a>，除了灵活度不高外基本实现了上述需求。</p>
<p>这次重写我决定尝试一下 Vite 的 <a target="_blank" rel="noopener" href="https://vitejs.dev/guide/ssr.html#pre-rendering-ssg">SSR</a>，在研究了一下 <a target="_blank" rel="noopener" href="https://github.com/antfu/vite-ssg">Vue</a> 的方案后，我发现核心就是要让前端代码能跑在 Node.js 上，这样本地的脚本就可以分析同一份前端数据以渲染那些网页了。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">// src/main.ts</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> const</span><span class="μ3"> app</span><span class="μ2"> =</span><span class="μ2"> import</span><span class="μ4">.</span><span class="μ3">meta</span><span class="μ4">.env.</span><span class="μ3">SSR</span><span class="μ2"> ?</span><span class="μ5"> createSSRApp</span><span class="μ4">(App) </span><span class="μ2">:</span><span class="μ5"> createApp</span><span class="μ4">(App)</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">// scripts/build.ts</span></span>
<span class="line"><span class="μ2">import</span><span class="μ4"> { app } </span><span class="μ2">from</span><span class="μ6"> '../src/main'</span></span>
<span class="line"><span class="μ4">console.</span><span class="μ5">log</span><span class="μ4">(</span><span class="μ5">renderToString</span><span class="μ4">(app))</span></span></code></pre>
<p>因为我不想要运行时带一个 100 kB 的 Vue，但是又想要 dev 环境下能看到内容，最后我的入口文件长这样：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">// 这几个变量都是纯的，打包时会被 tree shake 掉</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> let</span><span class="μ4"> templates </span><span class="μ2">=</span><span class="μ4"> {}</span></span>
<span class="line"><span class="μ2">export</span><span class="μ2"> let</span><span class="μ4"> posts </span><span class="μ2">=</span><span class="μ4"> {}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">// 只在预渲染和 dev 时加载真正的数据</span></span>
<span class="line"><span class="μ2">if</span><span class="μ4"> (</span><span class="μ2">import</span><span class="μ4">.</span><span class="μ3">meta</span><span class="μ4">.env.</span><span class="μ3">SSR</span><span class="μ2"> ||</span><span class="μ2"> import</span><span class="μ4">.</span><span class="μ3">meta</span><span class="μ4">.hot) {</span></span>
<span class="line"><span class="μ4">  templates </span><span class="μ2">=</span><span class="μ2"> import</span><span class="μ4">.</span><span class="μ3">meta</span><span class="μ4">.</span><span class="μ5">glob</span><span class="μ4">(</span><span class="μ6">'./templates/*.html'</span><span class="μ4">, { query: </span><span class="μ6">'raw'</span><span class="μ4">, eager: </span><span class="μ3">true</span><span class="μ4"> })</span></span>
<span class="line"><span class="μ4">  posts </span><span class="μ2">=</span><span class="μ2"> import</span><span class="μ4">.</span><span class="μ3">meta</span><span class="μ4">.</span><span class="μ5">glob</span><span class="μ4">(</span><span class="μ6">'../posts/*.md'</span><span class="μ4">, { eager: </span><span class="μ3">true</span><span class="μ4"> })</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">  if</span><span class="μ4"> (</span><span class="μ2">import</span><span class="μ4">.</span><span class="μ3">meta</span><span class="μ4">.hot) {</span></span>
<span class="line"><span class="μ5">    render</span><span class="μ4">(location.pathname, templates, posts)</span></span>
<span class="line"><span class="μ2">    import</span><span class="μ4">.</span><span class="μ3">meta</span><span class="μ4">.hot.</span><span class="μ5">accept</span><span class="μ4">()</span></span>
<span class="line"><span class="μ4">  }</span></span>
<span class="line"><span class="μ4">}</span></span></code></pre>
<p>完整的代码见<a target="_blank" rel="noopener" href="https://github.com/hyrious/hyrious.github.io/blob/-/src/main.ts">这里</a>。</p>
<p>经过这么一通折腾，现在我可以用 Vite 生成无 JS 的博客了！</p>
<pre><code>&gt; @ build /path/to/hyrious.github.io
&gt; esbuild-dev scripts/build.ts

[build] Build for client...
vite v5.0.0 building for production...
✓ 7 modules transformed.
dist/index.html                 0.50 kB │ gzip: 0.30 kB
dist/assets/index-vWxNvpCb.css  6.42 kB │ gzip: 2.37 kB
✓ built in 898ms

[build] Build for server...
dist/index.html          4.41 kB
dist/p/index.html        3.04 kB
dist/p/hello-world.html  12.11 kB

[build] Build finished.
</code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[打破 React Portal]]></title>
            <link>https://hyrious.me/p/break-react-portal</link>
            <guid>break-react-portal</guid>
            <pubDate>Wed, 01 Mar 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6F42C1}.μ2{color:#24292E}.μ3{color:#005CC5}.μ4{color:#D73A49}.μ5{color:#6A737D}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#B392F0}.μ2{color:#E1E4E8}.μ3{color:#79B8FF}.μ4{color:#F97583}.μ5{color:#6A737D}}</style><p><a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react-dom/createPortal">Portal</a> 是 React 的 <q>DOM 传送门</q>，它可以把虚拟 DOM 转移到其他真实 DOM 下渲染，同时还会保持虚拟 DOM 树的事件冒泡。但实际使用时我们可能反而不想要事件冒泡被<q>传送</q>走，只需要两行 CSS 即可达到这个目的，下面就来看看。</p>
<h3 id="tldr">TL;DR</h3>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">.portal</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  pointer-events</span><span class="μ2">: </span><span class="μ3">none</span><span class="μ2">;</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ1">.contents</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  pointer-events</span><span class="μ2">: </span><span class="μ3">all</span><span class="μ2">;</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<h3 id="portal-的真身">Portal 的真身</h3>
<p>众所周知，<a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react-dom/components/common#react-event-object">React DOM 包装了一套合成事件</a>来打平不同浏览器的区别，但是不仅仅如此，它还负责以下两个重要任务：</p>
<ul>
<li>减少对真实 DOM 的 <code>addEventListener</code> 的调用，避免性能问题</li>
<li><a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react-dom/createPortal">捕捉所有 Portal 里的事件，传送到对应的组件里处理</a></li>
</ul>
<p>除了第一个纯粹是自作自受以外，第二个具体是怎么实现的呢？我们观察 Portal 元素，会发现上面挂了所有可能的事件监听器，大概就可以猜到他是怎么转移这些事件的了。</p>
<h3 id="屏蔽事件监听器">屏蔽事件监听器</h3>
<p>如何清空一个元素上所有未知的监听器？在不黑原生 API 的情况下，一种方法是创建一个新的元素替代他：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ4">let</span><span class="μ2"> dup </span><span class="μ4">=</span><span class="μ2"> old.</span><span class="μ1">cloneNode</span><span class="μ2">() </span><span class="μ5">// 所有 DOM 属性继承，但是新元素没有挂任何监听器</span></span>
<span class="line"><span class="μ2">dup.</span><span class="μ1">append</span><span class="μ2">(</span><span class="μ4">...</span><span class="μ2">old.childNodes)</span></span>
<span class="line"><span class="μ2">old.</span><span class="μ1">replaceWith</span><span class="μ2">(dup)</span></span></code></pre>
<p>不过这会导致这个新元素不被 React DOM 管理，上面缺少了一些私有 JS 属性。</p>
<p>另一个方法是，通过设置 CSS，这个元素就会变成纯纯的空气，所有事件都不会发到他身上。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">.portal</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  pointer-events</span><span class="μ2">: </span><span class="μ3">none</span><span class="μ2">;</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>但是这个属性是<strong>继承</strong>的，就像 <code>color</code> 属性会影响下面所有元素一样，这下里面元素的事件也发不出来了。所以我们需要再启用里面的元素的事件：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">.contents</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  pointer-events</span><span class="μ2">: </span><span class="μ3">all</span><span class="μ2">;</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>这样一来，传送门下面的事件就可以正常发送到外面，被外面的元素（例如另一个 React DOM 根元素）捕获了。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[TypeScript <code>object</code> vs <code>record</code> vs <code>{}</code>]]></title>
            <link>https://hyrious.me/p/ts-object</link>
            <guid>ts-object</guid>
            <pubDate>Tue, 21 Feb 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#005CC5}.μ4{color:#6A737D}.μ5{color:#6F42C1}.μ6{color:#E36209}.μ7{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#79B8FF}.μ4{color:#6A737D}.μ5{color:#B392F0}.μ6{color:#FFAB70}.μ7{color:#9ECBFF}}</style><p>TypeScript 中存在三种可以用来描述<q>对象</q>的类型：<code>object</code>、<code>Record&lt;string, any&gt;</code>、<code>{}</code>，该用哪种？下面就来看看。</p>
<h3 id="-空的形状"><code>{}</code> 空的形状</h3>
<p>首先我们知道 <code>{}</code> 是一个 interface，它负责匹配<q>形状</q>，而一个空的形状约等于 <code>any</code> ——</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> a</span><span class="μ1">:</span><span class="μ2"> {} </span><span class="μ1">=</span><span class="μ3"> 1</span><span class="μ4"> // ok</span></span></code></pre>
<p>实际上，它保证右侧的值是可以按<q>对象</q>形式（也就是下标形式）访问的。也就是说 <code>null</code> 和 <code>undefined</code> 不在此列（因为他们直接 <code>.foo</code> 会炸）。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> a</span><span class="μ1">:</span><span class="μ2"> {} </span><span class="μ1">=</span><span class="μ3"> null</span><span class="μ4"> // error</span></span></code></pre>
<p>此外，注意到对象都继承有 <code>Object.prototype</code>，所以我们可以调用这些方法而不爆炸：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> a</span><span class="μ1">:</span><span class="μ2"> {} </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ2">a.</span><span class="μ5">toString</span><span class="μ2">() </span><span class="μ4">// ok</span></span></code></pre>
<p>上面的说法有个问题，<code>Object.create(null)</code> 可以不继承那些方法，但是 <code>Object.create()</code> 的类型返回 <code>any</code>，所以 TypeScript 实际检查不出下面代码的错误：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> a</span><span class="μ1">:</span><span class="μ2"> {} </span><span class="μ1">=</span><span class="μ2"> Object.</span><span class="μ5">create</span><span class="μ2">(</span><span class="μ3">null</span><span class="μ2">)</span></span>
<span class="line"><span class="μ2">a.</span><span class="μ5">toString</span><span class="μ2">() </span><span class="μ4">// types ok, but runtime error</span></span></code></pre>
<h3 id="object-非基本类型以外的所有"><code>object</code> 非基本类型以外的所有</h3>
<p>可以阅读 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-2-2/#the-object-type">TypeScript 2.2 的更新说明</a>，就是 <code>{}</code> 去掉 <code>number</code> 之类的基本类型。</p>
<p>实际上，除了标准库里会有一些接口必须传入非基本类型对象（如 <code>map.set(object,value)</code>）外，日常操作几乎用不着这个玩意儿。</p>
<h4 id="object-所有对象都继承的形状"><code>Object</code> 所有对象都继承的形状</h4>
<p><code>Object</code>（大写 <code>O</code>）是定义在 <code>libes*.d.ts</code> 里的 interface，它是所有对象类型最终继承的形状，所以它上面的方法可以从任意对象上点出来使用。</p>
<p>除了用于扩展标准库以外，日常操作几乎用不着这个玩意儿。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ4">// 可能的用途</span></span>
<span class="line"><span class="μ4">// 模块上下文需要 declare global，脚本上下文不需要</span></span>
<span class="line"><span class="μ1">declare</span><span class="μ2"> global {</span></span>
<span class="line"><span class="μ1">  interface</span><span class="μ5"> Object</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ5">    foo</span><span class="μ2">()</span><span class="μ1">:</span><span class="μ3"> number</span></span>
<span class="line"><span class="μ2">  }</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ3">Object</span><span class="μ2">.</span><span class="μ3">prototype</span><span class="μ2">.</span><span class="μ5">foo</span><span class="μ1"> =</span><span class="μ1"> function</span><span class="μ5"> foo</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ3"> 42</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<h3 id="recordstring-any-传统字典或者不如-"><code>Record&lt;string, any&gt;</code> 传统字典，或者不如 <code>{}</code></h3>
<p>在 <code>Map</code>（es6）发明出来之前，JS 里只能使用对象来模拟使用字典（实际上 v8 会检测这种用法并在底层切到一个真的字典实现）。因此 <code>Record&lt;K, V&gt;</code> 可以用于标记这种用法。</p>
<p>另一种用法是，当你在玩一些类型体操，操作用户传入或者 infer 出来的对象类型时，需要先用 <code>extends</code> 来限制传进来的确实是对象类型，你可能会在哪里看到这种写法：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">function</span><span class="μ5"> foo</span><span class="μ2">&#x3C;</span><span class="μ5">T</span><span class="μ1"> extends</span><span class="μ5"> Record</span><span class="μ2">&#x3C;</span><span class="μ3">string</span><span class="μ2">, </span><span class="μ3">any</span><span class="μ2">>>(</span><span class="μ6">obj</span><span class="μ1">:</span><span class="μ5"> T</span><span class="μ2">, </span><span class="μ6">key</span><span class="μ1">:</span><span class="μ1"> keyof</span><span class="μ5"> T</span><span class="μ2">) {}</span></span></code></pre>
<p>简单解释一下 <code>extends</code>，这个关键字限制传进来的类型必须被右侧的类型<em>包含</em>，然后可以对原类型做后续处理（如 <code>keyof</code> 和别的体操）。</p>
<p>显然，这个例子里我们限制第一个参数大概需要是个对象，然后第二个参数会推导出第一个参数的下标。那么用 <code>{}</code> 可以吗？可以！</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">type</span><span class="μ5"> Foo</span><span class="μ2">&#x3C;</span><span class="μ5">T</span><span class="μ1"> extends</span><span class="μ2"> {}> </span><span class="μ1">=</span><span class="μ1"> keyof</span><span class="μ5"> T</span></span>
<span class="line"><span class="μ4">// type A = 'a' | 'b'</span></span>
<span class="line"><span class="μ1">type</span><span class="μ5"> A</span><span class="μ1"> =</span><span class="μ5"> Foo</span><span class="μ2">&#x3C;{ </span><span class="μ6">a</span><span class="μ1">:</span><span class="μ3"> 1</span><span class="μ2">; </span><span class="μ6">b</span><span class="μ1">:</span><span class="μ3"> 2</span><span class="μ2"> }></span></span>
<span class="line"><span class="μ4">// type B = 'toString' | 'toFixed' | 'toExponential' | 'toPrecision' | 'valueOf' | 'toLocaleString'</span></span>
<span class="line"><span class="μ1">type</span><span class="μ5"> B</span><span class="μ1"> =</span><span class="μ5"> Foo</span><span class="μ2">&#x3C;</span><span class="μ3">1</span><span class="μ2">></span></span></code></pre>
<p><q>这不对</q>，你可能想这么说。这一眼看上去不符合你对用户的用法的期待，但是类型和运行时上都是允许的。</p>
<!-- prettier-ignore -->
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">foo</span><span class="μ2">(</span><span class="μ3">1</span><span class="μ2">, </span><span class="μ7">'toString'</span><span class="μ2">); </span><span class="μ4">// ok</span></span>
<span class="line"><span class="μ2">(</span><span class="μ3">1</span><span class="μ2">)[</span><span class="μ7">'toString'</span><span class="μ2">] </span><span class="μ4">// ok</span></span></code></pre>
<p>我建议所有人都把 <code>extends Record&lt;string, any&gt;</code> 换成 <code>extends {}</code>，因为</p>
<ul>
<li>对类型的限制更宽松</li>
<li>更短，好写好读</li>
<li>（性能上）更快</li>
<li>（语义上）更正确</li>
</ul>
<h3 id="typescript-eslint-历史遗留问题"><code>typescript-eslint</code> 历史遗留问题</h3>
<p><a target="_blank" rel="noopener" href="https://typescript-eslint.io/rules/ban-types/">typescript-eslint 默认禁止你使用 <code>Object</code> 和 <code>{}</code></a>，前者没什么问题，但 <code>{}</code> 实际上是很有用的类型。这纯粹是因为 TypeScript 以前的 <code>{}</code> 没那么好用。</p>
<p>你可以添加以下规则来覆盖它对 <code>{}</code> 的限制：</p>
<!-- prettier-ignore -->
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">{</span></span>
<span class="line"><span class="μ3">  "@typescript-eslint/ban-types"</span><span class="μ2">: [</span><span class="μ7">"error"</span><span class="μ2">, {</span></span>
<span class="line"><span class="μ3">    "types"</span><span class="μ2">: { </span><span class="μ3">"{}"</span><span class="μ2">: </span><span class="μ3">false</span><span class="μ2"> },</span></span>
<span class="line"><span class="μ3">    "extendDefaults"</span><span class="μ2">: </span><span class="μ3">true</span></span>
<span class="line"><span class="μ2">  }]</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[CRDT: 分数排序]]></title>
            <link>https://hyrious.me/p/crdt-fractional-indexing</link>
            <guid>crdt-fractional-indexing</guid>
            <pubDate>Thu, 19 Jan 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#032F62}.μ4{color:#005CC5}.μ5{color:#6A737D}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#9ECBFF}.μ4{color:#79B8FF}.μ5{color:#6A737D}}</style><blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-fractional-indexing">&laquo;CRDT: Fractional Indexing&raquo;</a>
原网站里还有精美的可视化效果。</p>
</blockquote>
<p>CRDT 是一系列解决协作问题的算法，其中一个不可避免的问题就是：如何记录顺序，如何在发生顺序修改时表现正确。假设我们使用一个数组来记录一组数据的话：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> [</span><span class="μ3">'hello'</span><span class="μ2">, </span><span class="μ3">'world'</span><span class="μ2">]</span></span></code></pre>
<p>在同步这个数据时，不可避免地要将这个数组发来发去，当数据量很大时显然不是一个优解。此时先别急着实现 CRDT 链表，我们可以让每个元素多记录一个特殊的数据用来排序，并且用这种方式的网络传输压力很小，下面就来看看。</p>
<p>首先，利用传统的 LWW (last-write-win) 算法，我们可以实现 CRDT Map，但这里面的元素不是有序的。接着，我们给每个元素添加一个字段表示它在数组中的位置。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ3">'?'</span><span class="μ2"> },</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ3">'?'</span><span class="μ2"> },</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>其中左边的 <code>1@1</code> 只是用来标记元素唯一的，它可以通过 <code>client(本地随机id) + clock(自增整数)</code> 的方式生成。右边的 <code>position</code> 是本文即将说明的技巧，有了它就可以轻松实现排序、有序元素间交换等行为。</p>
<h3 id="position-的定义"><code>position</code> 的定义</h3>
<p>我们定义 <code>position</code> 是一个从 0 到 1 的数，当出现新的元素要插到某个有序列中时，取其前后元素的 <code>position</code>，折半即可得到新元素的 <code>position</code>。当没有前元素时，认为它是 0，当没有后元素时，认为它是 1。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ4">0.5</span><span class="μ2"> }, </span><span class="μ5">// 第一个元素，插入 0 ~ 1 的中间，取 0.5</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ4">0.75</span><span class="μ2"> }, </span><span class="μ5">// 第二个元素，插入 0.5 ~ 1 的中间，取 0.75</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>直接二分取数的话，很快我们就会碰到浮点数的瓶颈：折半失效了！此时可以把它转成字符串，利用大整数的实现思路，实现一个无限精度的小数（或者称之为以 10 的指数为分母的分数）。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ3">'0.5'</span><span class="μ2"> }, </span><span class="μ5">// 5/10</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ3">'0.75'</span><span class="μ2"> }, </span><span class="μ5">// 75/100</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<h3 id="冲突处理">冲突处理</h3>
<p>上面这个技巧在多人协作时会有一个问题：如果两个人同时在一个位置插入了新节点，岂不是会产生两个一模一样的 <code>position</code>？</p>
<p>首先我们肯定不能让排序的结果不对，我们可以用客户端本地生成的随机 id (也就是上面 <code>todos</code> 的 keys) 对这些节点的排序算法做兜底。</p>
<p>其次有一个简单的方法可以避免这种确定性冲突——引入不确定的随机数即可，每次不光是折半产生下标，并且我们故意往后多添加几位随机数。在十进制下，仅仅是多添加三个字节就可以达到 1000 种不同的后缀，而这么多人同时操作同一个有序列表的概率不大。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ3">'0.5123'</span><span class="μ2"> }, </span><span class="μ5">// ~5/10</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ3">'0.75478'</span><span class="μ2"> }, </span><span class="μ5">// ~75/100</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>当然，如果放宽 CRDT 的限制，引入中心服务器裁决的话，也可以让服务器帮冲突的节点挑选一个新位置。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[JS 作用域碎碎念]]></title>
            <link>https://hyrious.me/p/js-scope</link>
            <guid>js-scope</guid>
            <pubDate>Tue, 17 Jan 2023 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#005CC5}.μ4{color:#6F42C1}.μ5{color:#6A737D}.μ6{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#79B8FF}.μ4{color:#B392F0}.μ5{color:#6A737D}.μ6{color:#FFAB70}}</style><p>JS 里存在两类<q>块</q>，一种是 block <code>{}</code>，另一种是 function body <code>(){}</code>（包括 method），这两种块对不同的变量声明会有不同的作用域效果，下面就来看看。</p>
<h4 id="var"><code>var</code></h4>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">false</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  var</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(a) </span><span class="μ5">// undefined</span></span></code></pre>
<p><code>var</code> 是一种历史悠久的变量，他不认识 block <code>{}</code>，会直接提升到第一个 function body 区，即使是 Dead-code 也不例外。</p>
<h4 id="let-const"><code>let</code>, <code>const</code></h4>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">true</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  const</span><span class="μ3"> a</span><span class="μ1"> =</span><span class="μ3"> 2</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(a) </span><span class="μ5">// 1</span></span></code></pre>
<p><code>let</code> 和 <code>const</code> 严格存在于当前 block 内，不会发生任何变量提升。</p>
<h4 id="function"><code>function</code></h4>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">false</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  function</span><span class="μ4"> foo</span><span class="μ2">() {}</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(foo) </span><span class="μ5">// undefined</span></span></code></pre>
<p><code>function</code> 也是一种定义变量的方式，他和 <code>var</code> 一样悠久，提升规则和 <code>var</code> 几乎一样，但有两点不同：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">const</span><span class="μ3"> a</span><span class="μ1"> =</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">false</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  var</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 2</span><span class="μ5"> // SyntaxError: Identifier 'a' has already been declared</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">const</span><span class="μ3"> foo</span><span class="μ1"> =</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">true</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  function</span><span class="μ4"> foo</span><span class="μ2">() {}</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(foo) </span><span class="μ5">// 1</span></span></code></pre>
<ol>
<li><code>var</code> 会不择手段地提升，碰到 <code>const</code>, <code>let</code> 之类硬茬就会爆炸；而 <code>function</code> 则温和很多。</li>
</ol>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(a, </span><span class="μ4">foo</span><span class="μ2">()) </span><span class="μ5">// undefined, 2</span></span>
<span class="line"><span class="μ1">var</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">function</span><span class="μ4"> foo</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ3"> 2</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<ol start="2">
<li>和 <code>var</code> 只送一个 <code>undefined</code> 不同，<code>function</code> 会连着定义一起送出去，我们可以 <em>看起来</em> 在定义之前就使用他。实际上，可以认为 <code>function</code> 连着内容一起被提升到了当前函数块的顶部执行。</li>
</ol>
<p>另外，当整个 <code>function</code> 作为表达式而不是语句存在时，其名称只会被限定在函数体内可以访问：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">$button.</span><span class="μ4">onclick</span><span class="μ1"> =</span><span class="μ1"> function</span><span class="μ4"> hello</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ2">  console.</span><span class="μ4">log</span><span class="μ2">(hello.name) </span><span class="μ5">// 'hello'</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(hello) </span><span class="μ5">// ReferenceError: hello is not defined</span></span></code></pre>
<h4 id="class"><code>class</code></h4>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">const</span><span class="μ3"> A</span><span class="μ1"> =</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">true</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  class</span><span class="μ4"> A</span><span class="μ2"> {}</span></span>
<span class="line"><span class="μ3">  A</span><span class="μ1"> =</span><span class="μ3"> 2</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(</span><span class="μ3">A</span><span class="μ2">) </span><span class="μ5">// 1</span></span></code></pre>
<p><code>class</code> 创造的变量约等于 <code>let</code>，不过需要注意的是，在 <code>class</code> 的静态表达式中是可以直接访问到其类名的，而 <code>let</code> 需要先执行完 <code>class</code>，反而不能这么使用：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ4"> A</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> a</span><span class="μ1"> =</span><span class="μ3"> A</span><span class="μ2">.name </span><span class="μ5">// 'A'</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> b</span><span class="μ1"> =</span><span class="μ3"> this</span><span class="μ2">.name </span><span class="μ5">// can also use `this`</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ3"> A</span><span class="μ1"> =</span><span class="μ1"> class</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> a</span><span class="μ1"> =</span><span class="μ3"> A</span><span class="μ2">.name </span><span class="μ5">// ReferenceError: A is not defined</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> b</span><span class="μ1"> =</span><span class="μ3"> this</span><span class="μ2">.name </span><span class="μ5">// 'A'</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre>
<p>注意到最后一个例子，<code>A.b</code> 可以拿到 <code>&#39;A&#39;</code>，这是因为匿名类会被自动赋予左边的变量名。当左边不是一个变量的时候该类的名字就是空了：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(</span></span>
<span class="line"><span class="μ1">  class</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ1">    static</span><span class="μ6"> b</span><span class="μ1"> =</span><span class="μ3"> this</span><span class="μ2">.name</span></span>
<span class="line"><span class="μ2">  }.b,</span></span>
<span class="line"><span class="μ2">) </span><span class="μ5">// ''</span></span></code></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[NPM Browser: 在线浏览 NPM 包内容]]></title>
            <link>https://hyrious.me/p/npm-browser</link>
            <guid>npm-browser</guid>
            <pubDate>Wed, 14 Dec 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p><time>2022-12-14</time> 更新</p>
<p>最近 npm 官网上线了一个查看包内容的 tab <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/npm?activeTab=explore">https://www.npmjs.com/package/npm?activeTab=explore</a>, <a target="_blank" rel="noopener" href="https://github.blog/changelog/2022-12-06-explore-the-content-of-your-npm-packages-with-the-new-code-explorer/">https://github.blog/changelog/2022-12-06-explore-the-content-of-your-npm-packages-with-the-new-code-explorer/</a></p>
<hr>
<p><time>2022-08-24</time> 更新</p>
<p>我以前经常使用 <a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/npm/lib0/">jsdelivr</a> 和 <a target="_blank" rel="noopener" href="https://unpkg.com/lib0/">unpkg</a> 来查看一些 NPM 包的源码，这么做有几个好处：</p>
<ol>
<li>假如这个包没有开源<sup><a href="#user-content-fn-1" data-footnote-ref="" id="user-content-fnref-1">1</a></sup>，我们仍然可以读到一些有用的内容；</li>
<li>虽然开源了，但是有可能打包工具配置有问题，可以借助这些网站快速查看包结构；</li>
<li>是在线的，不用污染本地环境。</li>
</ol>
<p>虽然这两个 CDN 都很快，但是想要切换文件还是比较慢。因此我写了个 <a target="_blank" rel="noopener" href="https://hyrious.me/npm-browser">NPM Browser</a> 来满足我的需求，它的前身是 <a target="_blank" rel="noopener" href="https://hyrious.me/tool/npm.html">tool/npm</a>。</p>
<h3 id="用法">用法</h3>
<p>直接打开输入包名即可从 npm registry 上下载 tgz 并解压出来查看。目前我还没有发现第二个 npm registry 镜像能够给前端开 CORS 的。并且我还用了 indexeddb 缓存每个包的内容，浏览看过的包会很快。</p>
<p>搜索包也是用的 npm registry 的 API，有时可能会超出 rate limit 导致无法响应。</p>
<p>地址栏会实时显示整个应用的状态，可以简单地分享给别人<del>对线</del>，格式为:</p>
<pre><code>网址?q=包名@版本/package/路径:行数
</code></pre><p>下面演示几个用法：</p>
<ul>
<li>查看最新版 lodash 包的内容: <a target="_blank" rel="noopener" href="https://hyrious.me/npm-browser/?q=lodash">https://hyrious.me/npm-browser/?q=lodash</a></li>
<li>指定到具体版本的具体文件的具体行: <a target="_blank" rel="noopener" href="https://hyrious.me/npm-browser/?q=@github/textarea-autosize@0.3.0/package/dist/index.js:72">https://hyrious.me/npm-browser/?q=@github/textarea-autosize@0.3.0/package/dist/index.js:72</a></li>
</ul>
<p>另一个我觉得很有用的功能是文件 diff，在标题栏包名右边第二个按钮就是。有的时候一些第三方包升级，但是 changelog 不会事无巨细地列出所有代码的修改，此时可以利用这个功能查看到底改了啥，例如前几天 markedjs 更新了一个小版本：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://hyrious.me/tool/diff-npm.html?a=marked%404.0.18%2Flib%2Fmarked.esm.js&b=marked%404.0.19%2Flib%2Fmarked.esm.js&s=1&f=l">/package/lib/marked.esm.js: marked@4.0.18 &rarr; marked@4.0.19</a></li>
</ul>
<p>以上。</p>
<section class="footnotes"><ol dir="auto"><li id="user-content-fn-1"><p dir="auto">例如 <a target="_blank" rel="noopener" href="https://motion.dev">motion</a> <a href="#user-content-fnref-1" class="data-footnote-backref" aria-label="Back to content"><g-emoji class="g-emoji" alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji></a></p></li></ol></section>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[热更新是怎么工作的]]></title>
            <link>https://hyrious.me/p/hmr</link>
            <guid>hmr</guid>
            <pubDate>Sat, 19 Feb 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#6F42C1}.μ4{color:#005CC5}.μ5{color:#6A737D}.μ6{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#B392F0}.μ4{color:#79B8FF}.μ5{color:#6A737D}.μ6{color:#9ECBFF}}</style><p>注：并非指线上软件不重启更新，而是指开发阶段能够获得更好的开发体验。</p>
<hr>
<p>几年前我玩 RPG Maker 的时候也想过这个问题，每次修改过脚本后都要重新启动游戏才能测试效果，有没有什么办法可以不重启呢？</p>
<p>简单地想，如果直接重新执行被修改的那一页脚本，那么只需要他能保证执行后是想要的效果就行了。由于大部分脚本插件都是<q>插件</q>式的，他们通常是使用 <code>alias</code> 修改一些个默认系统里的方法以及定义一些新模块，由于 Ruby 有<q>打开类</q>的元编程特性，所以重新执行一段类/模块定义并不会出错，那么只需要能让一段基于 <code>alias</code> 写的插件执行两遍等于只执行第二遍就行了！</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">alias</span><span class="μ2"> old_meth meth</span></span>
<span class="line"><span class="μ1">def</span><span class="μ3"> meth</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ2"> old_meth </span><span class="μ1">+</span><span class="μ4"> 1</span></span>
<span class="line"><span class="μ1">end</span></span></code></pre>
<p>假设有这样的插件代码。仔细观察，我们需要让 <code>old_meth</code> 第二次执行的时候仍然是<q>原方法</q>。怎么做呢？可以换成一个自定义的 <code>alias</code>：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">magic_alias </span><span class="μ4">:old_meth</span><span class="μ2">, </span><span class="μ4">:meth</span></span>
<span class="line"><span class="μ2">...</span></span></code></pre>
<p>如果上下文里已经有 <code>old_meth</code>，说明已经执行过一次，什么都不做就行：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ1"> &#x3C;&#x3C;</span><span class="μ2"> self</span></span>
<span class="line"><span class="μ1">  def</span><span class="μ3"> magic_alias</span><span class="μ2">(name, value)</span></span>
<span class="line"><span class="μ1">    return</span><span class="μ1"> if</span><span class="μ2"> method_defined? name</span></span>
<span class="line"><span class="μ1">    alias_method</span><span class="μ2"> name, value </span><span class="μ5"># 否则正常使用原 alias 效果</span></span>
<span class="line"><span class="μ1">  end</span></span>
<span class="line"><span class="μ1">end</span></span></code></pre>
<p>所以，我当时的方案就是：在每页文件开头加这么一个神秘函数，用它代替 alias，然后重新执行这页代码，就可以适配大部分插件脚本的热更新了。</p>
<hr>
<p>Sublime Text 里也有一个针对插件的热更新机制，也是直接重新执行一下插件 python 文件。不过，它可以在顶层定义 <code>plugin_loaded</code> 和 <code>plugin_unloaded</code> 方法，在插件重载的时候可以利用这两个方法确保执行效果正确。</p>
<p>比起我的<q>神秘代码</q> + 重新执行，ST 的工作方式如下：</p>
<ol>
<li>原插件非阻塞调用 <code>plugin_unloaded</code></li>
<li>执行新插件</li>
<li>执行新插件的 <code>plugin_loaded</code></li>
</ol>
<p>这样一来，等于将热更新逻辑交给写插件的人实现。</p>
<hr>
<p>前端开发也有一套热更新方法，你可以在 <a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/hot-module-replacement/">webpack</a>、<a target="_blank" rel="noopener" href="https://github.com/rixo/rollup-plugin-hot">rollup</a>、<a target="_blank" rel="noopener" href="https://github.com/PepsRyuu/nollup/blob/master/docs/nollup-hooks.md">nollup</a>、<a target="_blank" rel="noopener" href="https://vitejs.dev/guide/features.html#hot-module-replacement">vite</a> 里看到一套 HMR 接口，其基本思路和上面提到的其实也是一回事，每个模块（文件）可以注册退出 <code>hot.dispose()</code> 和进入 <code>hot.accept()</code> 时干的事情，从而达到热更新效果。</p>
<p>以 Vite 为例，他的热更新流程如下：</p>
<ol>
<li>后端扫描代码文件，理清依赖关系，把代码里包含 <code>hot.accept()</code> 的文件视为<q>热更新模块边界</q></li>
<li>有文件发生变化时，通过 1 的依赖关系查找到变化文件的公共热更新边界，通知前端刷新这个文件</li>
<li>前端依次执行：<ol>
<li>调用所有相关文件的 <code>hot.dispose()</code> 回调</li>
<li>下载执行 2 找到的边界文件</li>
<li>调用该文件的 <code>hot.accept()</code> 回调</li>
</ol>
</li>
</ol>
<p>不过，这里存在一个陷阱：你能保证除了更新的文件以外的模块不变吗？</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">// global.js</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> let</span><span class="μ2"> state </span><span class="μ1">=</span><span class="μ2"> []</span></span>
<span class="line"></span>
<span class="line"><span class="μ5">// a.js</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> { state } </span><span class="μ1">from</span><span class="μ6"> './global.js'</span></span>
<span class="line"><span class="μ2">state.</span><span class="μ3">push</span><span class="μ2">(</span><span class="μ6">'a'</span><span class="μ2">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ5">// b.js</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> { state } </span><span class="μ1">from</span><span class="μ6"> './global.js'</span></span>
<span class="line"><span class="μ2">state.</span><span class="μ3">push</span><span class="μ2">(</span><span class="μ6">'b'</span><span class="μ2">)</span></span></code></pre>
<p>如果 a.js 发生了热更新，他能否在更新期间拿到和 b.js 一样的 <code>state</code>？</p>
<p>如果不能，那么此时运行时出现了两个 <code>state</code>，可能会出现一些 bug。</p>
<p>因此，那些基于黑 <code>require</code> 或类似技术（如 SystemJS）的 HMR 实现，可以保证新加载的模块依然可以引用到公共模块，只需要动态决定 <code>require</code> 返回啥就行了（比如可以用 <code>id+timestamp</code> 标识模块的唯一性）。</p>
<p>而 Vite 这种基于原生 ESM 的，显然没有地方给他黑 <code>import</code>，他唯一能做的就是利用浏览器缓存来让浏览器觉得使用了同一个模块。继续思考，然后你会发现他这种方案只能<q>不打包</q>，否则总是无法实现模块的唯一性。</p>
<p>Vite 的方案有没有可能在 Node.js 里实现呢？不好说，因为我们不清楚 <code>import</code> 到底有没有 cache，以及这个 cache 认不认 query（<code>import &quot;mod?t=114514&quot;</code>）。</p>
<hr>
<p>什么东西适合热更新？虽然我上面只提了 RM/ST 插件、前端工具，但是不难看出，基本上就这些东西<q>在</q>实现热更新：</p>
<ul>
<li>即插即用的插件</li>
<li>前端组件库，包括 CSS 样式</li>
</ul>
<p>前者不难理解，本身已经对<q>即插即用</q>下了一些功夫。后者可以理解为，组件的副作用恰好是热更新的目标——因为组件本身存在生命周期，只需要调用前组件的卸载和新组件的挂载就行。这些组件就类似我一开篇提到的用 alias 编写的 RM 插件，因为符合某种规范所以恰好运行良好。</p>
<p>除此以外，适当缩小业务范围也不难定义出适合热更新的目标。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Sublime Text 插件踩坑]]></title>
            <link>https://hyrious.me/p/sublime-plugin-tips</link>
            <guid>sublime-plugin-tips</guid>
            <pubDate>Sun, 06 Feb 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6A737D}.μ2{color:#D73A49}.μ3{color:#6F42C1}.μ4{color:#24292E}.μ5{color:#E36209}.μ6{color:#032F62}.μ7{color:#005CC5}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#6A737D}.μ2{color:#F97583}.μ3{color:#B392F0}.μ4{color:#E1E4E8}.μ5{color:#FFAB70}.μ6{color:#9ECBFF}.μ7{color:#79B8FF}}</style><p>春节花了几天写了一个 <a target="_blank" rel="noopener" href="https://github.com/hyrious/prettierd">Sublime Text 插件</a>，这里大概记录一下关于它（主要是 python 部分）的小知识。</p>
<h3 id="sublimeset_timeout-和-sublimeset_timeout_async"><samp>sublime.set_timeout()</samp> 和 <samp>sublime.set_timeout_async()</samp></h3>
<p>文档上说 <q><samp>_async</samp></q> 会放在另一个线程里执行，听着似乎等于 <samp>threading<wbr>.Thread()<wbr>.start()</samp>？其实不然！这里文档没有明说的是，sublime 一共只有两个线程 —— 主渲染线程和 worker 线程。<q><samp>_async</samp></q> 的意思是把一个函数放到 worker 线程里跑 —— worker 线程里的任务还是会互相阻塞。所以一旦我们需要实现一些长时间阻塞的任务（如 <samp>process<wbr>.stdout<wbr>.readline()</samp>，假设你要做一个使用 tsserver 的插件<span class="half-shrink-right">）</span>，最好还是自己拿 Thread 搞事。</p>
<p>只有那些短时间且符合用户操作目的的单任务（例如格式化一下文本，当用户按下快捷键时，他期望编辑器做一些工作，但是又不希望整个程序像卡死了一样）适合在 worker 线程工作。</p>
<h3 id="async-await-py37"><samp>async await</samp> <span class="half-shrink-left">（</span>py3.7+）</h3>
<p>Sublime Text 4 提供了 python3.8 给新的插件，这意味着你可以写 <code>if a := 1</code> 和 <code>async def</code> 了。说到 <code>async</code> 我就不困了，我立马搬出《<a target="_blank" rel="noopener" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">函数染色问题</a>》。另外，在 sublime 里你总不能让一个 async 函数占着主线程，所以有了下面这段代码：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1"># Run a callback (-> coroutine) in a new `threading.Thread()`. Refer to</span></span>
<span class="line"><span class="μ1"># https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058</span></span>
<span class="line"><span class="μ2">def</span><span class="μ3"> run_in_new_thread</span><span class="μ4">(function, </span><span class="μ2">*</span><span class="μ4">args, </span><span class="μ2">**</span><span class="μ4">kwargs):</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # The "loop" holder.</span></span>
<span class="line"><span class="μ4">    loop </span><span class="μ2">=</span><span class="μ4"> asyncio.new_event_loop()</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # Kick start the event loop.</span></span>
<span class="line"><span class="μ2">    def</span><span class="μ3"> wrapper</span><span class="μ4">(loop):</span></span>
<span class="line"><span class="μ4">        asyncio.set_event_loop(loop)</span></span>
<span class="line"><span class="μ4">        loop.run_forever() </span><span class="μ1"># &#x3C;- block current thread, until "loop.stop()"</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # Send wrapper to a new thread with the loop.</span></span>
<span class="line"><span class="μ4">    t </span><span class="μ2">=</span><span class="μ4"> threading.Thread(</span><span class="μ5">target</span><span class="μ2">=</span><span class="μ4">wrapper, </span><span class="μ5">args</span><span class="μ2">=</span><span class="μ4">(loop,))</span></span>
<span class="line"><span class="μ4">    t.start()</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # Run the callback with the loop.</span></span>
<span class="line"><span class="μ4">    coro </span><span class="μ2">=</span><span class="μ4"> function(</span><span class="μ2">*</span><span class="μ4">args, </span><span class="μ2">**</span><span class="μ4">kwargs)</span></span>
<span class="line"><span class="μ4">    future </span><span class="μ2">=</span><span class="μ4"> asyncio.run_coroutine_threadsafe(coro, loop)</span></span>
<span class="line"><span class="μ1">    # `await future` to wait for it.</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">    return</span><span class="μ4"> future</span></span></code></pre>
<p>虽然他是 thread-safe 的，不过手操 thread 还是让我有点不爽。而且这抽象泄露也太严重了，直接给你一个 <samp>loop</samp> <span class="half-shrink-left">（</span>约等于 generator 函数给你的那个对象<span class="half-shrink-right">）</span>。</p>
<h3 id="subprocesspopen-和僵尸进程"><samp>subprocess.Popen</samp> 和僵尸进程</h3>
<p>你可以在任何 python 环境下（包括 REPL）试试这段代码：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">import</span><span class="μ4"> subprocess</span></span>
<span class="line"><span class="μ1"># 启动一个子进程，只要能一直跑随便用啥都行</span></span>
<span class="line"><span class="μ4">p </span><span class="μ2">=</span><span class="μ4"> subprocess.Popen([</span><span class="μ6">'ruby'</span><span class="μ4">, </span><span class="μ6">'-e'</span><span class="μ4">, </span><span class="μ6">'sleep 9999'</span><span class="μ4">])</span></span>
<span class="line"><span class="μ7">exit</span><span class="μ4">()</span></span></code></pre>
<p>你的 python 退出了，但是子进程还在跑！<span class="half-shrink-left">（</span>也就是所谓的僵尸进程<span class="half-shrink-right">）</span>。我以为是缺什么参数，结果他压根没有实现自动退出子进程的功能（隔壁 ruby、nodejs 可是默认行为，导致我都不知道还能这样<span class="half-shrink-right">）</span>。没有力量，所以只能找到 sublime 有个 <samp>on_exit</samp> 监听器，要在那里退出子进程。</p>
<h3 id="异步触发修改">异步触发修改</h3>
<p>出于操作的同步性考虑，插件必须在一次 <samp>TextCommand</samp> 回调里同步地完成对 view 的修改。一旦这个回调执行的同步代码太多，编辑器就会卡住，体验很不好。那么如何实现异步的修改呢？这里有一个小技巧，就是在异步任务结束的时候再触发一遍 <samp>TextCommand</samp> 并且把必要的参数传进去。一旦有新的用户操作会打断这次异步任务的，就加个标记不去触发即可。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[如何编写更快的 JS]]></title>
            <link>https://hyrious.me/p/fast-js</link>
            <guid>fast-js</guid>
            <pubDate>Fri, 28 Jan 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<p>这篇博客主要是对 4 年前的这篇 <q><a target="_blank" rel="noopener" href="https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html">Maybe you don&#39;t need Rust and WASM to speed up your JS</a></q> 的笔记。</p>
<p><strong>注意</strong>：过早优化是万恶之源，了解这篇博客<strong>可能</strong>有助于你写出更快的 JS/TS，但是不要一味追求写出让人看不懂的代码。</p>
<ol>
<li>调用函数时传递和声明一样多的参数，不使用可选参数。</li>
<li><a target="_blank" rel="noopener" href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">单态化</a>函数，简单来说让每个参数的形状（对象的结构、或者函数本身）都永远不变。这个招式平时比较难搓，建议看前面的文章详细理解。</li>
<li>克制地使用缓存 —— 除非查找它比计算它容易。</li>
<li>想办法减少 GC 的压力，例如申请一个大的 TypedArray 存储定长数据。</li>
<li>如果只是在 <code>ASCII</code> 范围内工作，用 <code>Uint8Array</code> 代替 <code>String</code>。</li>
</ol>
<p>还有一些常识：</p>
<ol>
<li>用 <code>class</code> 维护对象的形状，不去改变 <code>prototype</code>。</li>
<li>从<q>维护形状</q>考虑，不要用 <code>Record&lt;string, X&gt;</code> 当 <code>Map/Set</code> 使 —— 直接用 <code>Map</code> 即可。</li>
</ol>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[简单理解 Tree Shaking]]></title>
            <link>https://hyrious.me/p/tree-shaking</link>
            <guid>tree-shaking</guid>
            <pubDate>Tue, 25 Jan 2022 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#005CC5}.μ2{color:#032F62}.μ3{color:#24292E}.μ4{color:#6F42C1}.μ5{color:#D73A49}.μ6{color:#6A737D}.μ7{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#79B8FF}.μ2{color:#9ECBFF}.μ3{color:#E1E4E8}.μ4{color:#B392F0}.μ5{color:#F97583}.μ6{color:#6A737D}.μ7{color:#FFAB70}}</style><p>问：如何分析并删除无用的 JS 代码？Tree-Shaking 给了打包器们一个简单的方法：只需要删除每个闭包里的没有<strong>使用</strong>且没有<strong>副作用</strong>的变量声明/表达式即可。剩下的就是需要给代码块（语法节点）标上有没有被使用、有没有副作用的信息。</p>
<p>怎么知道一段代码的副作用呢？<span class="half-shrink-left">（</span>换句话说，是不是<q>纯</q>的）</p>
<p>首先，纯字面量（数字，字符串等表达式）肯定没有副作用：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">42</span></span>
<span class="line"><span class="μ2">'hello'</span></span>
<span class="line"><span class="μ3">{ </span><span class="μ4">a</span><span class="μ3">: [] }</span></span>
<span class="line"><span class="μ5">function</span><span class="μ3">(){} </span><span class="μ6">// 函数本身也是没有副作用的 -- 除非你调他</span></span></code></pre>
<p><del>其次，</del> 没有其次了，仅此而已。光有上面这些信息就足够 shake 掉这个例子：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">function</span><span class="μ4"> add</span><span class="μ3">(</span><span class="μ7">a</span><span class="μ3">, </span><span class="μ7">b</span><span class="μ3">) { </span><span class="μ5">return</span><span class="μ3"> a </span><span class="μ5">+</span><span class="μ3"> b }</span></span>
<span class="line"><span class="μ5">function</span><span class="μ4"> mul</span><span class="μ3">(</span><span class="μ7">a</span><span class="μ3">, </span><span class="μ7">b</span><span class="μ3">) { </span><span class="μ5">return</span><span class="μ3"> a </span><span class="μ5">*</span><span class="μ3"> b }</span></span>
<span class="line"><span class="μ5">export</span><span class="μ5"> let</span><span class="μ3"> sum </span><span class="μ5">=</span><span class="μ4"> add</span><span class="μ3">(</span><span class="μ1">3</span><span class="μ3">, </span><span class="μ1">5</span><span class="μ3">)</span></span></code></pre>
<p align=center>&darr; &darr; &darr;</p>

<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">function</span><span class="μ4"> add</span><span class="μ3">(</span><span class="μ7">a</span><span class="μ3">, </span><span class="μ7">b</span><span class="μ3">) { </span><span class="μ5">return</span><span class="μ3"> a </span><span class="μ5">+</span><span class="μ3"> b }</span></span>
<span class="line"><span class="μ5">export</span><span class="μ5"> let</span><span class="μ3"> sum </span><span class="μ5">=</span><span class="μ4"> add</span><span class="μ3">(</span><span class="μ1">3</span><span class="μ3">, </span><span class="μ1">5</span><span class="μ3">)</span></span></code></pre>
<p>但是——你一拍大腿——能不能把函数调用也删掉呢？例如，假如我最终没有用上面的 <code>sum</code>，能不能把它连同 <code>add</code> 的定义一起删掉呢？——是可以的，用 Pure Annotation：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">export</span><span class="μ5"> let</span><span class="μ3"> sum </span><span class="μ5">=</span><span class="μ6"> /* @__PURE__ */</span><span class="μ4"> add</span><span class="μ3">(</span><span class="μ1">3</span><span class="μ3">, </span><span class="μ1">5</span><span class="μ3">)</span></span></code></pre>
<p>这个注释在告诉打包器：本次函数调用是<q>纯</q>的，其返回值和 <code>123</code> 差不多，如果没人用的话可以把这个调用删了。</p>
<p><strong>陷阱</strong>：但是你不能删掉函数括号里的东西。这是因为参数本身可能是由别的副作用产生的，兴许有人依赖这个副作用呢。例如：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ6">/* @__PURE__ */</span><span class="μ4"> debugPrint</span><span class="μ3">(</span><span class="μ4">createApp</span><span class="μ3">())</span></span></code></pre>
<p align=center>&darr; &darr; &darr;</p>

<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ4">createApp</span><span class="μ3">()</span></span></code></pre>
<p>这个标记对下面这种调用也有效：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ6">/* @__PURE__ */</span><span class="μ3"> React.</span><span class="μ4">createElement</span><span class="μ3">(</span><span class="μ2">'div'</span><span class="μ3">, {}, </span><span class="μ2">'Hello'</span><span class="μ3">)  </span><span class="μ6">// => nothing</span></span>
<span class="line"><span class="μ6">/* @__PURE__ */</span><span class="μ5"> new</span><span class="μ1"> A</span><span class="μ3">.b.c.</span><span class="μ4">d</span><span class="μ3">()                            </span><span class="μ6">// => nothing</span></span></code></pre>
<p>细心的你已经发现了：你无法对访问下标（<code>a.b</code>）标记是否含有副作用。实际上 esbuild 会认为所有的 getter setter 都是有副作用的。所以下面这段代码不能被 shake 掉：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">let</span><span class="μ3"> a </span><span class="μ5">=</span><span class="μ3"> {}</span></span>
<span class="line"><span class="μ3">a.b </span><span class="μ5">=</span><span class="μ1"> 1</span></span>
<span class="line"><span class="μ6">// 即使没有用到 a，这段代码也不能被删掉</span></span></code></pre>
<p>如果有一些复杂的初始化函数，你可以使用下面这个写法来规避这个问题：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">let</span><span class="μ3"> a </span><span class="μ5">=</span><span class="μ6"> /* @__PURE__ */</span><span class="μ3"> (() </span><span class="μ5">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ5">  let</span><span class="μ3"> a </span><span class="μ5">=</span><span class="μ3"> {}</span></span>
<span class="line"><span class="μ3">  a.b </span><span class="μ5">=</span><span class="μ1"> 1</span></span>
<span class="line"><span class="μ5">  return</span><span class="μ3"> a</span></span>
<span class="line"><span class="μ3">})()</span></span></code></pre>
<p>注意：esbuild 的 <code>--minify-whitespace</code> 会将 <code>/* @__PURE__ */</code> 视为空格删掉，因此在输出 esm 时一定要记得关闭这个功能。</p>
<hr>
<p><strong>附赠：如何在打出的包里区分 dev/prod 环境？</strong></p>
<p>虽然 Node.js 推出了 conditional exports 并建议大家用这样的形式导出不同的包：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">"exports"</span><span class="μ3">: {</span></span>
<span class="line"><span class="μ1">  "development"</span><span class="μ3">: </span><span class="μ2">"./dist/index.dev.js"</span><span class="μ3">,</span></span>
<span class="line"><span class="μ1">  "production"</span><span class="μ3">: </span><span class="μ2">"./dist/index.prod.js"</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<p>但是前端生态可等不到他推广这个 feature，反而是使用了一个非常 cjs 的方法：</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">if</span><span class="μ3"> (process.env.</span><span class="μ1">NODE_ENV</span><span class="μ5"> ===</span><span class="μ2"> 'production'</span><span class="μ3">) {</span></span>
<span class="line"><span class="μ1">  module</span><span class="μ3">.</span><span class="μ1">exports</span><span class="μ5"> =</span><span class="μ4"> require</span><span class="μ3">(</span><span class="μ2">'./dist/index.prod.js'</span><span class="μ3">)</span></span>
<span class="line"><span class="μ3">} </span><span class="μ5">else</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ1">  module</span><span class="μ3">.</span><span class="μ1">exports</span><span class="μ5"> =</span><span class="μ4"> require</span><span class="μ3">(</span><span class="μ2">'./dist/index.dev.js'</span><span class="μ3">)</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<p>你可以在 React 和 Vue3 的包里看到这种写法，而且现代打包器都对这种写法做了预处理。</p>
<hr>
<p>总之，理解了 Tree-Shaking 是如何工作的，才能让打包结果符合你的预期。</p>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Earley 算法]]></title>
            <link>https://hyrious.me/p/earley-parser</link>
            <guid>earley-parser</guid>
            <pubDate>Wed, 27 Sep 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[<style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#D73A49}.μ2{color:#6F42C1}.μ3{color:#24292E}.μ4{color:#6A737D}.μ5{color:#005CC5}.μ6{color:#032F62}.μ7{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#F97583}.μ2{color:#B392F0}.μ3{color:#E1E4E8}.μ4{color:#6A737D}.μ5{color:#79B8FF}.μ6{color:#9ECBFF}.μ7{color:#DBEDFF}}</style><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Earley_parser">Earley parser - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bitpeach/p/3602522.html">模式识别之 Earley 算法入门详讲 - bitpeach</a></li>
</ul>
<p>Earley parser 是一个可以在最坏 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度下解析任何 CFG 文法的产生式的算法，它是支持左递归的。</p>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">new</span><span class="μ2"> EarleyParser</span><span class="μ3">({ CFG }).</span><span class="μ2">parse</span><span class="μ3">(str) </span><span class="μ4">//=> AST</span></span></code></pre>
<p>设某条 CFG 是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，我们引入一个 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 代表解析位置，例如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 代表当前正在匹配 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 规则，已经匹配成功了 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>，下一步是匹配 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>。</p>
<p>设 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是输入序列的第 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个 token 所在的位置，对于每个 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，Earley 算法都要产生一个 State 集合。每个 State 形如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，代表我从 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 位置开始匹配的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 规则，已经匹配成功了 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>，下一步是匹配 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>。设 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位置对应的 State 集合为 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</p>
<p>首先，生成 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>；接下来重复执行以下操作：</p>
<ul>
<li>预测：如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 后面是一个非终结符如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，我们把 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 开头的规则添加到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是当前位置，<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 是刚才匹配 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的起始位置）</li>
<li>扫描：如果 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 后面是一个终结符如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，我们把 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 添加到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>规约：对于 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 中的每个 State，如果它的 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 到达该规则的末尾，如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">⋅</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，说明我们已经匹配完成了这个（子）规则，在 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 中找到所有 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 后面是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的如 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">Xβ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，将小圆点后移一位 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 添加到 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>注意：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 是一个 <strong>集合</strong>，里面没有重复的 State。</p>
<p>设输入有 n 个 token，我们在 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 中找到所有 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的，说明我们已经匹配完成了全部的规则，找到的都是合法的生成树。</p>
<h4 id="简单实现">简单实现</h4>
<pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ2"> Earley</span></span>
<span class="line"><span class="μ1">  def</span><span class="μ2"> initialize</span><span class="μ3"> rules </span><span class="μ1">=</span><span class="μ3"> []</span></span>
<span class="line"><span class="μ3">    @rules </span><span class="μ1">=</span><span class="μ3"> rules</span></span>
<span class="line"><span class="μ1">  end</span></span>
<span class="line"><span class="μ1">  def</span><span class="μ2"> lazy_each_with_index</span><span class="μ3"> arr, i </span><span class="μ1">=</span><span class="μ5"> 0</span></span>
<span class="line"><span class="μ1">    yield</span><span class="μ3"> arr[i], (i </span><span class="μ1">+=</span><span class="μ5"> 1</span><span class="μ3">) </span><span class="μ1">-</span><span class="μ5"> 1</span><span class="μ1"> while</span><span class="μ3"> arr[i]</span></span>
<span class="line"><span class="μ1">  end</span></span>
<span class="line"><span class="μ1">  def</span><span class="μ2"> uniq_bfs</span><span class="μ3"> start </span><span class="μ1">=</span><span class="μ3"> [], i </span><span class="μ1">=</span><span class="μ5"> 0</span></span>
<span class="line"><span class="μ1">    yield</span><span class="μ3"> start[(i </span><span class="μ1">+=</span><span class="μ5"> 1</span><span class="μ3">) </span><span class="μ1">-</span><span class="μ5"> 1</span><span class="μ3">], </span><span class="μ5">-></span><span class="μ3"> x { start.push(x).uniq!; x } </span><span class="μ1">while</span><span class="μ3"> start[i]</span></span>
<span class="line"><span class="μ1">  end</span></span>
<span class="line"><span class="μ1">  def</span><span class="μ2"> parse</span><span class="μ3"> str, </span><span class="μ1">&#x26;</span><span class="μ3">lex</span></span>
<span class="line"><span class="μ3">    s </span><span class="μ1">=</span><span class="μ3"> [[[@rules[</span><span class="μ5">0</span><span class="μ3">], </span><span class="μ5">0</span><span class="μ3">, </span><span class="μ5">0</span><span class="μ3">]]]</span></span>
<span class="line"><span class="μ3">    lazy_each_with_index(s) { |set, k|</span></span>
<span class="line"><span class="μ3">      s.push [] </span><span class="μ1">if</span><span class="μ3"> token </span><span class="μ1">=</span><span class="μ3"> lex.(str)</span></span>
<span class="line"><span class="μ3">      uniq_bfs(set) { |((n, rule), i, j), u|</span></span>
<span class="line"><span class="μ1">        if</span><span class="μ3"> rule.size </span><span class="μ1">==</span><span class="μ3"> i</span></span>
<span class="line"><span class="μ3">          s[j].</span><span class="μ5">select</span><span class="μ3"> { |(_, rule), i, _| rule[i] </span><span class="μ1">==</span><span class="μ3"> n }.each { |e, i, j| u.([e, i </span><span class="μ1">+</span><span class="μ5"> 1</span><span class="μ3">, j]) }</span></span>
<span class="line"><span class="μ1">        elsif</span><span class="μ3"> rule[i].is_a? </span><span class="μ5">Symbol</span></span>
<span class="line"><span class="μ3">          @rules.</span><span class="μ5">select</span><span class="μ3"> { |e, _| rule[i] </span><span class="μ1">==</span><span class="μ3"> e }.each { |e| u.([e, </span><span class="μ5">0</span><span class="μ3">, k]) }</span></span>
<span class="line"><span class="μ1">        elsif</span><span class="μ3"> match rule[i], token</span></span>
<span class="line"><span class="μ3">          s[k </span><span class="μ1">+</span><span class="μ5"> 1</span><span class="μ3">].push [[n, rule], i </span><span class="μ1">+</span><span class="μ5"> 1</span><span class="μ3">, j]</span></span>
<span class="line"><span class="μ1">        end</span></span>
<span class="line"><span class="μ3">      }</span></span>
<span class="line"><span class="μ3">    }</span></span>
<span class="line"><span class="μ3">    s[</span><span class="μ1">-</span><span class="μ5">1</span><span class="μ3">].any? { |(n, rule), i, j| n </span><span class="μ1">==</span><span class="μ3"> @rules[</span><span class="μ5">0</span><span class="μ3">][</span><span class="μ5">0</span><span class="μ3">] </span><span class="μ1">&#x26;&#x26;</span><span class="μ3"> rule.size </span><span class="μ1">==</span><span class="μ3"> i </span><span class="μ1">&#x26;&#x26;</span><span class="μ3"> j.zero? }</span></span>
<span class="line"><span class="μ1">  end</span></span>
<span class="line"><span class="μ1">  def</span><span class="μ2"> match</span><span class="μ3"> pattern, token</span></span>
<span class="line"><span class="μ1">    case</span><span class="μ3"> pattern</span></span>
<span class="line"><span class="μ1">    when</span><span class="μ5"> String</span><span class="μ1"> then</span><span class="μ3"> token </span><span class="μ1">==</span><span class="μ3"> pattern</span></span>
<span class="line"><span class="μ1">    when</span><span class="μ5"> Regexp</span><span class="μ1"> then</span><span class="μ3"> token </span><span class="μ1">=~</span><span class="μ3"> pattern</span></span>
<span class="line"><span class="μ1">    else</span><span class="μ5"> false</span></span>
<span class="line"><span class="μ1">    end</span></span>
<span class="line"><span class="μ1">  end</span></span>
<span class="line"><span class="μ1">end</span></span>
<span class="line"></span>
<span class="line"><span class="μ5">p</span><span class="μ5"> Earley</span><span class="μ3">.</span><span class="μ1">new</span><span class="μ3">([</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:P</span><span class="μ3">, [</span><span class="μ5">:S</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:S</span><span class="μ3">, [</span><span class="μ5">:S</span><span class="μ3">, </span><span class="μ6">'+'</span><span class="μ3">, </span><span class="μ5">:M</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:S</span><span class="μ3">, [</span><span class="μ5">:S</span><span class="μ3">, </span><span class="μ6">'-'</span><span class="μ3">, </span><span class="μ5">:M</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:S</span><span class="μ3">, [</span><span class="μ5">:M</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:M</span><span class="μ3">, [</span><span class="μ5">:M</span><span class="μ3">, </span><span class="μ6">'*'</span><span class="μ3">, </span><span class="μ5">:T</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:M</span><span class="μ3">, [</span><span class="μ5">:M</span><span class="μ3">, </span><span class="μ6">'/'</span><span class="μ3">, </span><span class="μ5">:T</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:M</span><span class="μ3">, [</span><span class="μ5">:T</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">  [</span><span class="μ5">:T</span><span class="μ3">, [</span><span class="μ6">/</span><span class="μ7">^</span><span style="--s-light:#22863A;--s-dark:#85E89D;--s-light-font-weight:bold;--s-dark-font-weight:bold">\d</span><span class="μ7">+$</span><span class="μ6">/</span><span class="μ3">]],</span></span>
<span class="line"><span class="μ3">]).parse(</span><span class="μ6">'2 + 3 - 4'</span><span class="μ3">) { |s|</span></span>
<span class="line"><span class="μ3">  s.slice!(</span><span class="μ6">/</span><span class="μ7">^</span><span style="--s-light:#22863A;--s-dark:#85E89D;--s-light-font-weight:bold;--s-dark-font-weight:bold">\s</span><span class="μ7">+</span><span class="μ6">/</span><span class="μ3">)</span></span>
<span class="line"><span class="μ3">  s.slice!(</span><span class="μ6">/</span><span class="μ7">^</span><span style="--s-light:#22863A;--s-dark:#85E89D;--s-light-font-weight:bold;--s-dark-font-weight:bold">\d</span><span class="μ7">+|</span><span style="--s-light:#22863A;--s-dark:#85E89D;--s-light-font-weight:bold;--s-dark-font-weight:bold">\+</span><span class="μ7">|</span><span style="--s-light:#22863A;--s-dark:#85E89D;--s-light-font-weight:bold;--s-dark-font-weight:bold">\-</span><span class="μ7">|</span><span style="--s-light:#22863A;--s-dark:#85E89D;--s-light-font-weight:bold;--s-dark-font-weight:bold">\*</span><span class="μ7">|</span><span style="--s-light:#22863A;--s-dark:#85E89D;--s-light-font-weight:bold;--s-dark-font-weight:bold">\/</span><span class="μ6">/</span><span class="μ3">)</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre>
<h4 id="最后">最后</h4>
<p>Earley parser 是一个自顶向下的算法，有一个与之类似的操作叫 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK 算法</a> 是自下而上的。</p>]]></content:encoded>
        </item>
    </channel>
</rss>