<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://hyrious.me/</id>
    <title>hyrious.log</title>
    <updated>2023-11-27T04:03:47.079Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <author>
        <name>hyrious</name>
        <email>hyrious@outlook.com</email>
        <uri>https://hyrious.me</uri>
    </author>
    <link rel="alternate" href="https://hyrious.me/"/>
    <link rel="self" href="https://hyrious.me/feed.atom"/>
    <subtitle>hyrious.log</subtitle>
    <icon>https://hyrious.me/favicon.svg</icon>
    <rights>CC0 1.0</rights>
    <entry>
        <title type="html"><![CDATA[代码分割并不简单]]></title>
        <id>https://hyrious.me/p/code-splitting-is-not-trivial</id>
        <link href="https://hyrious.me/p/code-splitting-is-not-trivial"/>
        <updated>2023-11-27T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#6A737D}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#005CC5}.μ4{color:#032F62}.μ5{color:#6F42C1}@media(prefers-color-scheme:dark){.μ0{color:#6A737D}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#79B8FF}.μ4{color:#9ECBFF}.μ5{color:#B392F0}}</style><p>Code Splitting 一直是前端性能优化的一个重要手段，但是如此重要的功能在 <a target="_blank" rel="noopener" href="https://esbuild.github.io/api/#splitting">esbuild</a> 中时至今日仍然是实验性的，这是为什么呢？下面就来看看。</p>
<h3 id="一个简单的例子">一个简单的例子</h3>
<p>考虑下面这段代码：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">// shared.js</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> let</span><span class="μ2"> util </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">// a.js (entry)</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> { util } </span><span class="μ1">from</span><span class="μ4"> './shared.js'</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> b </span><span class="μ1">from</span><span class="μ4"> './b.js'</span></span>
<span class="line"><span class="μ5">foo</span><span class="μ2">(b, util)</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">// b.js (entry)</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> { util } </span><span class="μ1">from</span><span class="μ4"> './shared.js'</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> default</span><span class="μ5"> bar</span><span class="μ2">(util)</span></span></code></pre><p>如果我要你对 a.js 和 b.js 进行打包，且要求仅打包出两个文件，如何对敌？</p>
<p>简单来说，此时你必须决定把 shared.js 放入某个文件里，而这次「放入」实际上产生了某种程度上说可以称之为错误的结果，下面就来看看：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">// dist/a.js (a + shared)</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> let</span><span class="μ2"> util </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> b </span><span class="μ1">from</span><span class="μ4"> './b.js'</span><span class="μ0"> // a -> b</span></span>
<span class="line"><span class="μ5">foo</span><span class="μ2">(b, util)</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">// dist/b.js (b)</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> { util } </span><span class="μ1">from</span><span class="μ4"> './a.js'</span><span class="μ0"> // b -> a</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> default</span><span class="μ5"> bar</span><span class="μ2">(util)</span></span></code></pre><p>可以观察到：竟然出现了循环引用！实际上光是在 dist/a.js 中创建出 <code>util</code> 这个导出都是有问题的——因为原文件 a.js 没有要你导出 <code>util</code>。</p>
<p>语义上的事情暂且放到一边，接下来看看运行时效果是否正确。因为 a.js 和 b.js 都是入口文件，理论上他们都可能被单独执行。然而，当你运行 dist/a.js 时，他要 import dist/b.js，所以 bar() 先执行；当你运行 dist/b.js 时，他要 import dist/a.js，所以 foo() 先执行。🤯</p>
<p>但是我们看一下源文件，b.js 压根没有依赖 a.js，所以理论上来说执行 b.js 时不应该执行 foo() 才对。</p>
<h3 id="副作用管理没有平凡解">副作用管理没有<abbr title="trivial">平凡</abbr>解</h3>
<p>我们的软件功能基于副作用工作，大部分<abbr title="imperative">命令式</abbr>编程语言需要代码按顺序运行。考虑下面的代码，从语法上说他们是分离的语法树，但是由于引用关系，一些代码必须要在其他一些代码之后执行：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ5"> A</span><span class="μ2"> {} </span><span class="μ0">// [1]</span></span>
<span class="line"><span class="μ3">A</span><span class="μ2">.foo </span><span class="μ1">=</span><span class="μ3"> 1</span><span class="μ0"> // [2] 必须在 [1] 之后执行</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">// [3] 「似乎」不需要在 [1] 之后执行</span></span>
<span class="line"><span class="μ1">function</span><span class="μ5"> foo</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ1"> new</span><span class="μ5"> A</span><span class="μ2">()</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ5">foo</span><span class="μ2">() </span><span class="μ0">// [4] 如果你不知道 foo() 里在干什么，你无法确定 [4] 要在 [1] 之后执行</span></span></code></pre><p>实际上，追踪语法树之间的<strong>实际执行顺序</strong>关系太复杂了 (光是引用关系还好说，但是在 JavaScript 中可以轻易出现交叉引用)，各种隐式的依赖关系几乎不可能分析完整。因为打包器无法知道产物具体是如何运行的，只能尽最大努力兼容所有情况，出现 <a target="_blank" rel="noopener" href="https://github.com/evanw/esbuild/issues/399">bug</a> 也是常有的。</p>
<h3 id="如何实践">如何实践</h3>
<p>对于库作者，尽量发布 ESM 格式的纯函数包。如果要依赖副作用，可以手动包装成工厂函数或者其他形式实现懒惰加载，如此一来等到运行时，相关副作用代码大概率已经被执行过了，就不怕顺序问题了。另外，尽量不要出现循环引用，打包器通常很难决定在这种情况下哪个文件先执行。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">// bundle.js</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> function</span><span class="μ5"> foo</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ1"> new</span><span class="μ5"> A</span><span class="μ2">()</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ1">class</span><span class="μ5"> A</span><span class="μ2"> {} </span><span class="μ0">// 假设 class A {} 被打包器挪到了后面</span></span>
<span class="line"><span class="μ3">A</span><span class="μ2">.data </span><span class="μ1">=</span><span class="μ3"> 1</span><span class="μ0"> // 副作用</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">// main.js</span></span>
<span class="line"><span class="μ5">foo</span><span class="μ2">() </span><span class="μ0">// 用户代码执行的时候也不怕 A.data 未定义了</span></span></code></pre><p>对于终端开发者，如果你有 HTTP/2，可以无脑使用打包器的默认配置来分包，通常情况下会分出相当多的碎片，这主要是为了保证语义和运行顺序的正确性。不用担心碎片文件的性能问题，我们还有 <a target="_blank" rel="noopener" href="https://guybedford.com/es-module-preloading-integrity#modulepreload-polyfill">preload</a> 机制可以提前下载并解析模块。一句话概括，Just use <a target="_blank" rel="noopener" href="https://vitejs.dev/">Vite</a>。</p>
<p>如果你需要一定程度的手动配置 (<a target="_blank" rel="noopener" href="https://github.com/evanw/esbuild/issues/207">Manual chunks</a>)，目前 Rollup 和 webpack 各自实现了一套相对稳定的分包算法。而 esbuild 还没实现，不过你可以<a target="_blank" rel="noopener" href="https://github.com/hyrious/esbuild-split-vendors-example">手动</a>模拟 webpack 的效果。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[CRDT 漫谈]]></title>
        <id>https://hyrious.me/p/crdt</id>
        <link href="https://hyrious.me/p/crdt"/>
        <updated>2023-11-23T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#6F42C1}.μ1{color:#D73A49}.μ2{color:#24292E}.μ3{color:#005CC5}.μ4{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#B392F0}.μ1{color:#F97583}.μ2{color:#E1E4E8}.μ3{color:#79B8FF}.μ4{color:#FFAB70}}</style><p>以前写过一篇 <a href="./crdt-fractional-indexing">&laquo;CRDT: 分数排序&raquo;</a>。我认为，CRDT 可能是未来实现大部分软件的最佳选择。有了它，你就免费获得了离线编辑、协作、历史记录、撤销重做等等功能，传统的软件开发中以上任何一条都是非常难设计和实现的。</p>
<h3 id="定义">定义</h3>
<p>Conflict-free Replicated Data Type，无冲突数据结构。什么叫冲突？这通常需要根据具体场景来理解和定义，对于大家最熟悉的文本编辑场景，冲突就是两个或以上用户的编辑最终变成了重叠、错位、不一致的情况。CRDT 的目标就是针对各种不同的场景，<strong>分别</strong>设计出特定的数据结构，使得它们可以符合大多数人的预期、保持一致。由于 CRDT 不是一种，有的时候大家也会用 CRDTs 来代指所有的 CRDT。下文中还会列举一些常见的实现。</p>
<h4 id="问题框架">问题框架</h4>
<p>CRDT 要解决的问题必须都能用这个框架来描述。</p>
<blockquote>
<p>假设有一个无敌信道，可以让任何在里面的消息都广播到所有客户端，并且不会发生消息的丢失 (不用保证顺序)，那么如何基于它设计一个数据结构，使其可以满足某个协作场景的需求？</p>
</blockquote>
<p>简单来说要求有这样一个基建:</p>
<ul>
<li>消息全部到达，包括所有历史消息，不用保证顺序</li>
<li>消息不会重复</li>
</ul>
<p>&hellip;这在现实中当然是不存在的，于是具体应用就需要分别实现某些基建，这通常包括：</p>
<ul>
<li>一个存储服务，用于在所有设备都下线时保存最新的状态</li>
<li>一个消息队列，用于保证消息的到达 (但不用保证永久存储)<ul>
<li>基于 P2P 的实现有可能无法保证，此时需要客户端实现重试策略</li>
</ul>
</li>
<li>其他对业务有用的服务<ul>
<li>例如，一个同步观看视频的应用将需要同步设备的时间以对齐视频播放的位置</li>
</ul>
</li>
</ul>
<p>因此，如果有产品将以上基建封装成一个统一的服务，将会非常有利于 CRDT 应用的落地。</p>
<h4 id="本地优先软件">本地优先软件</h4>
<p>CRDT 非常适合用来制作本地优先软件 (Local-first software)。现如今人们通常接触的都是云应用 (或者你可以称其为 <abbr title="Software as a service">SaaS</abbr>)，你需要登录才能访问和使用你上传的数据。而一旦服务器宕机或者由于一些不可抗力，你珍贵的数据就会暂时消失一段时间。有了 CRDT，你的本地编辑历史会被持久化存储，就不怕内容丢失了。</p>
<p>当然，前面提到的问题可以通过本地多保存几次备份等土办法来解决。从另一个角度来说，本地优先的意义在于<q>让本地的修改优先发生</q>，也就是说用户应当立即看到操作的效果，而不是等服务器返回响应。否则运气不好的话用户每操作一会就得等应用转圈圈，这种体验是非常糟糕的。CRDT 上的修改都是立即生效的，就算网络断开也不会丢失这次的操作。</p>
<h4 id="什么时候不用-crdt">什么时候不用 CRDT？</h4>
<p>CRDT 的最低目标只是保证结果一致，而不保证总是符合预期。例如，<abbr title="Multiplayer Online Battle Arena">MOBA</abbr> 类游戏中对于伤害的结算需要有一个中心服务器进行裁决和下发以保证公平性。再比如，银行类系统会要求每次金融操作的原子性、一致性等硬标准，这些地方该转圈圈还是得转。</p>
<p>多人游戏的同步是又一个比较复杂的话题，以后有机会可以再展开。</p>
<h3 id="分类">分类</h3>
<p>有两大类 CRDT 的设计方向，一类是基于操作 (Operation) 的，也就是广播消息内容直接是<q>操作</q>，比如 (+1) (insert 0 &quot;hello&quot;) 之类的，现在主要流行的 CRDT 库大都是这类，也叫 <abbr title="Commutative replicated data types">CmRDTs</abbr>。另一类是基于状态 (State) 的，广播消息是本地的状态 (可以是全量或部分)，而接收端需要实现特殊的合并算法来算到最新状态，也叫 <abbr title="Convergent replicated data types">CvRDTs</abbr>。</p>
<h3 id="常见场景和实现">常见场景和实现</h3>
<p>下面有一些是纯学术构想的虚拟场景，有一些则是真实且有线上应用的。</p>
<h4 id="投票系统">投票系统</h4>
<p>假如你在做一个直播类软件，软件上有一个点赞按钮，所有观众都可以点击此按钮为主播的人气值 +1，你该如何实现：有一万个人同时点击这个按钮，如何让主播最终看到人气值 = 一万，且服务器不炸。</p>
<p><strong>解</strong>: 可以设计这样一种数据结构，它的消息体里只有一个 <code>1</code>，主播拿到消息后立刻增加人气值。回想上文中的信道，显然，既然消息都可以到达，那么最终收到的 <code>1</code> 的数量一定是完整的一万。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">点赞</span><span class="μ1"> =</span><span class="μ2"> () </span><span class="μ1">=></span><span class="μ2"> 观众.</span><span class="μ0">发送</span><span class="μ2">(</span><span class="μ3">1</span><span class="μ2">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">收到</span><span class="μ1"> =</span><span class="μ2"> (</span><span class="μ4">点赞</span><span class="μ2">) </span><span class="μ1">=></span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  this</span><span class="μ2">.人气值 </span><span class="μ1">+=</span><span class="μ2"> 点赞</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><h4 id="分组投票系统">分组投票系统</h4>
<p>还是上面的场景，但是你想看到具体每个人点了多少次赞。</p>
<p><strong>解</strong>: 可以让消息体里带上观众的 ID，主播那里分别统计每个人的点赞次数。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">点赞</span><span class="μ1"> =</span><span class="μ2"> () </span><span class="μ1">=></span><span class="μ2"> 观众.</span><span class="μ0">发送</span><span class="μ2">(</span><span class="μ3">this</span><span class="μ2">.id, </span><span class="μ3">1</span><span class="μ2">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">收到</span><span class="μ1"> =</span><span class="μ2"> ([</span><span class="μ4">谁</span><span class="μ2">, </span><span class="μ4">点赞</span><span class="μ2">]) </span><span class="μ1">=></span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  this</span><span class="μ2">.人气值[谁] </span><span class="μ1">+=</span><span class="μ2"> 点赞</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><h4 id="礼物系统-set">礼物系统 (Set)</h4>
<p>还是上面的场景，但是这次不要求统计赞数，而是要求知道主播收到了哪些种类的礼物。</p>
<p><strong>解</strong>: 可以让消息体里带上礼物的 ID，主播那里把收到的礼物 ID 放到一个集合里。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">发送礼物</span><span class="μ1"> =</span><span class="μ2"> () </span><span class="μ1">=></span><span class="μ2"> 观众.</span><span class="μ0">发送</span><span class="μ2">(礼物.id)</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">收到</span><span class="μ1"> =</span><span class="μ2"> ([</span><span class="μ4">谁</span><span class="μ2">, </span><span class="μ4">礼物</span><span class="μ2">]) </span><span class="μ1">=></span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  this</span><span class="μ2">.收到的[礼物] </span><span class="μ1">=</span><span class="μ3"> true</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><h4 id="知乎">知乎</h4>
<p>这次不光可以点赞，还可以点踩。只需要知道最后 <code>赞 - 踩</code> 是多少即可。</p>
<p><strong>解</strong>: 可以设计两种消息，一个 <code>+1</code>，一个 <code>-1</code>，主播累加所有消息。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">点赞</span><span class="μ1"> =</span><span class="μ2"> () </span><span class="μ1">=></span><span class="μ2"> 观众.</span><span class="μ0">发送</span><span class="μ2">(</span><span class="μ1">+</span><span class="μ3">1</span><span class="μ2">)</span></span>
<span class="line"><span class="μ0">点踩</span><span class="μ1"> =</span><span class="μ2"> () </span><span class="μ1">=></span><span class="μ2"> 观众.</span><span class="μ0">发送</span><span class="μ2">(</span><span class="μ1">-</span><span class="μ3">1</span><span class="μ2">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">收到</span><span class="μ1"> =</span><span class="μ2"> (</span><span class="μ4">点赞或点踩</span><span class="μ2">) </span><span class="μ1">=></span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  this</span><span class="μ2">.人气值 </span><span class="μ1">+=</span><span class="μ2"> 点赞或点踩</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><h4 id="通用-map">通用 (Map)</h4>
<p>对于一些元信息类的数据，只需要保留最后一次修改的结果。例如文章标题、卡片颜色等等。</p>
<p><strong>注意</strong>: 上文中的信道是不保序的，因此你不能依赖消息到达的顺序来实现。</p>
<p><strong>解</strong>: 可以使用 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Lamport_timestamp">Lamport</a> 时钟来对消息进行排序，消息内容就是修改 <code>Map</code> 内容。</p>
<blockquote>
<p>Lamport 时钟是指这样一个数：初始化为 0，每次发送消息一起发出去且 +1，每次收到消息时设为最新消息的时钟 +1。</p>
</blockquote>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">写入</span><span class="μ1"> =</span><span class="μ2"> (</span><span class="μ4">key</span><span class="μ2">, </span><span class="μ4">value</span><span class="μ2">) </span><span class="μ1">=></span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  this</span><span class="μ2">.</span><span class="μ0">发送</span><span class="μ2">(</span><span class="μ3">this</span><span class="μ2">.lamport</span><span class="μ1">++</span><span class="μ2">, key, value)</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ0">收到</span><span class="μ1"> =</span><span class="μ2"> (</span><span class="μ4">lamport</span><span class="μ2">, </span><span class="μ4">key</span><span class="μ2">, </span><span class="μ4">value</span><span class="μ2">) </span><span class="μ1">=></span><span class="μ2"> {</span></span>
<span class="line"><span class="μ1">  if</span><span class="μ2"> (</span><span class="μ3">this</span><span class="μ2">.lamport </span><span class="μ1">&#x3C;</span><span class="μ2"> lamport) {</span></span>
<span class="line"><span class="μ3">    this</span><span class="μ2">.lamport </span><span class="μ1">=</span><span class="μ2"> lamport </span><span class="μ1">+</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ3">    this</span><span class="μ2">.数据[key] </span><span class="μ1">=</span><span class="μ2"> value</span></span>
<span class="line"><span class="μ2">  }</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><h4 id="列表-list">列表 (List)</h4>
<p>对于记事本等小型列表场景，直接替换整个列表似乎有点浪费带宽。</p>
<p><a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-fractional-indexing/">Evan</a> 提出给元素增加一个分数信息表示列表位置的方法，详见 <a href="./crdt-fractional-indexing">&laquo;CRDT: 分数排序&raquo;</a>。</p>
<h4 id="文本-一种列表">文本 (一种列表)</h4>
<p>对于文本编辑器之类大量有序数据的场景，一个重要的需求是保证不重叠，例如两个人分别在同一个位置输入了 <code>ab</code> <code>cd</code>，合并结果可以是 <code>abcd</code> 或 <code>cdab</code>，但不能是 <code>acbd</code>。</p>
<p><a target="_blank" rel="noopener" href="https://github.com/yjs">Yjs</a> 实现了一个名叫 <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/452980520">YATA</a> 的算法，基本思想是保证 <code>a-b</code> 和 <code>c-d</code> 这两根线不能形成交叉。</p>
<p><a target="_blank" rel="noopener" href="https://www.loro.dev/blog/crdt-richtext">Loro</a> 实现了 Peritext 和 Fugue 两个新算法，能很好地支持富文本 (文本上有各种标记，如加粗变色等) 场景以及解决文本重叠问题。</p>
<h4 id="树-无环图">树 (无环图)</h4>
<p>如果只有 <code>Map</code>，你可以对每个节点存储其父节点的 ID 来实现图结构，但是这无法解决循环引用的问题。</p>
<p><a target="_blank" rel="noopener" href="https://www.loro.dev/blog/loro-now-open-source#movable-tree">Loro</a> 实现了一个拥有移动节点指令 (也就是<q>设置某个节点的父节点</q>) 的树形数据结构，其基本思想是插入适当的<q>撤销</q>操作来恢复树结构不能有环的约定。</p>
<p><a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-mutable-tree-hierarchy/">Evan</a> 实现了一个类似的算法。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Hello, world!]]></title>
        <id>https://hyrious.me/p/hello-world</id>
        <link href="https://hyrious.me/p/hello-world"/>
        <updated>2023-11-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#6A737D}.μ1{color:#D73A49}.μ2{color:#005CC5}.μ3{color:#24292E}.μ4{color:#6F42C1}.μ5{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#6A737D}.μ1{color:#F97583}.μ2{color:#79B8FF}.μ3{color:#E1E4E8}.μ4{color:#B392F0}.μ5{color:#9ECBFF}}</style><p>我又㕛叕重写了一遍博客，这次用上了 <a target="_blank" rel="noopener" href="https://vitejs.dev/">Vite</a>。其实我以前用过不少博客生成器，包括 <a target="_blank" rel="noopener" href="https://jekyllrb.com/">Jekyll</a>、<a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>、<a target="_blank" rel="noopener" href="https://www.gatsbyjs.com/">Gatsby</a> 等等，但是他们要么渲染太慢，要么安装成本太大。我<a target="_blank" rel="noopener" href="https://github.com/hyrious/hyrious/issues/5">曾经</a>口胡过详细的需求，简单来说我需要这个生成器拥有以下功能：</p>
<ul>
<li>支持无 JS 访问，也就是说整个页面只有 HTML 和 CSS 就应该能正常运行了</li>
<li>支持 <a target="_blank" rel="noopener" href="https://github.github.com/gfm/" title="GitHub Flavored Markdown">GFM</a>，因为源码放在 GitHub，最好能直接打开 GitHub 观看</li>
<li>仍然支持按需引入 JS 脚本，这样在我的博客上阅读时可以有更丰富的体验</li>
<li>[优化] 支持秒级刷新，这样编辑时基本不会打断思路（我时不时就想看看渲染结果）</li>
</ul>
<p>我曾经试过手撸 HTML 源码，这样确实灵活性很高且只需要<abbr title="不含学习 HTML 和 CSS 的时间">成本为零</abbr>的先验知识，但是遇到代码高亮等读写都比较麻烦的内容还是不够方便。后来我写了一个 <a target="_blank" rel="noopener" href="https://github.com/hyrious/telegraph">telegraph</a>，除了灵活度不高外基本实现了上述需求。</p>
<p>这次重写我决定尝试一下 Vite 的 <a target="_blank" rel="noopener" href="https://vitejs.dev/guide/ssr.html#pre-rendering-ssg">SSR</a>，在研究了一下 <a target="_blank" rel="noopener" href="https://github.com/antfu/vite-ssg">Vue</a> 的方案后，我发现核心就是要让前端代码能跑在 Node.js 上，这样本地的脚本就可以分析同一份前端数据以渲染那些网页了。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">// src/main.ts</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> const</span><span class="μ2"> app</span><span class="μ1"> =</span><span class="μ1"> import</span><span class="μ3">.</span><span class="μ2">meta</span><span class="μ3">.env.</span><span class="μ2">SSR</span><span class="μ1"> ?</span><span class="μ4"> createSSRApp</span><span class="μ3">(App) </span><span class="μ1">:</span><span class="μ4"> createApp</span><span class="μ3">(App)</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">// scripts/build.ts</span></span>
<span class="line"><span class="μ1">import</span><span class="μ3"> { app } </span><span class="μ1">from</span><span class="μ5"> '../src/main'</span></span>
<span class="line"><span class="μ3">console.</span><span class="μ4">log</span><span class="μ3">(</span><span class="μ4">renderToString</span><span class="μ3">(app))</span></span></code></pre><p>因为我不想要运行时带一个 100 kB 的 Vue，但是又想要 dev 环境下能看到内容，最后我的入口文件长这样：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">// 这几个变量都是纯的，打包时会被 tree shake 掉</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> let</span><span class="μ3"> templates </span><span class="μ1">=</span><span class="μ3"> {}</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> let</span><span class="μ3"> posts </span><span class="μ1">=</span><span class="μ3"> {}</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">// 只在预渲染和 dev 时加载真正的数据</span></span>
<span class="line"><span class="μ1">if</span><span class="μ3"> (</span><span class="μ1">import</span><span class="μ3">.</span><span class="μ2">meta</span><span class="μ3">.env.</span><span class="μ2">SSR</span><span class="μ1"> ||</span><span class="μ1"> import</span><span class="μ3">.</span><span class="μ2">meta</span><span class="μ3">.hot) {</span></span>
<span class="line"><span class="μ3">  templates </span><span class="μ1">=</span><span class="μ1"> import</span><span class="μ3">.</span><span class="μ2">meta</span><span class="μ3">.</span><span class="μ4">glob</span><span class="μ3">(</span><span class="μ5">'./templates/*.html'</span><span class="μ3">, { as: </span><span class="μ5">'raw'</span><span class="μ3">, eager: </span><span class="μ2">true</span><span class="μ3"> })</span></span>
<span class="line"><span class="μ3">  posts </span><span class="μ1">=</span><span class="μ1"> import</span><span class="μ3">.</span><span class="μ2">meta</span><span class="μ3">.</span><span class="μ4">glob</span><span class="μ3">(</span><span class="μ5">'../posts/*.md'</span><span class="μ3">, { eager: </span><span class="μ2">true</span><span class="μ3"> })</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">  if</span><span class="μ3"> (</span><span class="μ1">import</span><span class="μ3">.</span><span class="μ2">meta</span><span class="μ3">.hot) {</span></span>
<span class="line"><span class="μ4">    render</span><span class="μ3">(location.pathname, templates, posts)</span></span>
<span class="line"><span class="μ1">    import</span><span class="μ3">.</span><span class="μ2">meta</span><span class="μ3">.hot.</span><span class="μ4">accept</span><span class="μ3">()</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre><p>完整的代码见<a target="_blank" rel="noopener" href="https://github.com/hyrious/hyrious.github.io/blob/-/src/main.ts">这里</a>。</p>
<p>经过这么一通折腾，现在我可以用 Vite 生成无 JS 的博客了！</p>
<pre><code>&gt; @ build /path/to/hyrious.github.io
&gt; esbuild-dev scripts/build.ts

[build] Build for client...
vite v5.0.0 building for production...
✓ 7 modules transformed.
dist/index.html                 0.50 kB │ gzip: 0.30 kB
dist/assets/index-vWxNvpCb.css  6.42 kB │ gzip: 2.37 kB
✓ built in 898ms

[build] Build for server...
dist/index.html          4.41 kB
dist/p/index.html        3.04 kB
dist/p/hello-world.html  12.11 kB

[build] Build finished.</code></pre>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[打破 React Portal]]></title>
        <id>https://hyrious.me/p/break-react-portal</id>
        <link href="https://hyrious.me/p/break-react-portal"/>
        <updated>2023-03-01T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#6F42C1}.μ1{color:#24292E}.μ2{color:#005CC5}.μ3{color:#D73A49}.μ4{color:#6A737D}@media(prefers-color-scheme:dark){.μ0{color:#B392F0}.μ1{color:#E1E4E8}.μ2{color:#79B8FF}.μ3{color:#F97583}.μ4{color:#6A737D}}</style><p><a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react-dom/createPortal">Portal</a> 是 React 的 <q>DOM 传送门</q>，它可以把虚拟 DOM 转移到其他真实 DOM 下渲染，同时还会保持虚拟 DOM 树的事件冒泡。但实际使用时我们可能反而不想要事件冒泡被<q>传送</q>走，只需要两行 CSS 即可达到这个目的，下面就来看看。</p>
<h3 id="tldr">TL;DR</h3>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">.portal</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  pointer-events</span><span class="μ1">: </span><span class="μ2">none</span><span class="μ1">;</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ0">.contents</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  pointer-events</span><span class="μ1">: </span><span class="μ2">all</span><span class="μ1">;</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><h3 id="portal-的真身">Portal 的真身</h3>
<p>众所周知，<a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react-dom/components/common#react-event-object">React DOM 包装了一套合成事件</a>来打平不同浏览器的区别，但是不仅仅如此，它还负责以下两个重要任务：</p>
<ul>
<li>减少对真实 DOM 的 <code>addEventListener</code> 的调用，避免性能问题</li>
<li><a target="_blank" rel="noopener" href="https://zh-hans.react.dev/reference/react-dom/createPortal">捕捉所有 Portal 里的事件，传送到对应的组件里处理</a></li>
</ul>
<p>除了第一个纯粹是自作自受以外，第二个具体是怎么实现的呢？我们观察 Portal 元素，会发现上面挂了所有可能的事件监听器，大概就可以猜到他是怎么转移这些事件的了。</p>
<h3 id="屏蔽事件监听器">屏蔽事件监听器</h3>
<p>如何清空一个元素上所有未知的监听器？在不黑原生 API 的情况下，一种方法是创建一个新的元素替代他：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ3">let</span><span class="μ1"> dup </span><span class="μ3">=</span><span class="μ1"> old.</span><span class="μ0">cloneNode</span><span class="μ1">() </span><span class="μ4">// 所有 DOM 属性继承，但是新元素没有挂任何监听器</span></span>
<span class="line"><span class="μ1">dup.</span><span class="μ0">append</span><span class="μ1">(</span><span class="μ3">...</span><span class="μ1">old.childNodes)</span></span>
<span class="line"><span class="μ1">old.</span><span class="μ0">replaceWith</span><span class="μ1">(dup)</span></span></code></pre><p>不过这会导致这个新元素不被 React DOM 管理，上面缺少了一些私有 JS 属性。</p>
<p>另一个方法是，通过设置 CSS，这个元素就会变成纯纯的空气，所有事件都不会发到他身上。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">.portal</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  pointer-events</span><span class="μ1">: </span><span class="μ2">none</span><span class="μ1">;</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><p>但是这个属性是<strong>继承</strong>的，就像 <code>color</code> 属性会影响下面所有元素一样，这下里面元素的事件也发不出来了。所以我们需要再启用里面的元素的事件：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">.contents</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  pointer-events</span><span class="μ1">: </span><span class="μ2">all</span><span class="μ1">;</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><p>这样一来，传送门下面的事件就可以正常发送到外面，被外面的元素（例如另一个 React DOM 根元素）捕获了。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[TypeScript <code>object</code> vs <code>record</code> vs <code>{}</code>]]></title>
        <id>https://hyrious.me/p/ts-object</id>
        <link href="https://hyrious.me/p/ts-object"/>
        <updated>2023-02-21T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#D73A49}.μ1{color:#24292E}.μ2{color:#005CC5}.μ3{color:#6A737D}.μ4{color:#6F42C1}.μ5{color:#E36209}.μ6{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#F97583}.μ1{color:#E1E4E8}.μ2{color:#79B8FF}.μ3{color:#6A737D}.μ4{color:#B392F0}.μ5{color:#FFAB70}.μ6{color:#9ECBFF}}</style><p>TypeScript 中存在三种可以用来描述<q>对象</q>的类型：<code>object</code>、<code>Record&lt;string, any&gt;</code>、<code>{}</code>，该用哪种？下面就来看看。</p>
<h3 id="-空的形状"><code>{}</code> 空的形状</h3>
<p>首先我们知道 <code>{}</code> 是一个 interface，它负责匹配<q>形状</q>，而一个空的形状约等于 <code>any</code> ——</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">let</span><span class="μ1"> a</span><span class="μ0">:</span><span class="μ1"> {} </span><span class="μ0">=</span><span class="μ2"> 1</span><span class="μ3"> // ok</span></span></code></pre><p>实际上，它保证右侧的值是可以按<q>对象</q>形式（也就是下标形式）访问的。也就是说 <code>null</code> 和 <code>undefined</code> 不在此列（因为他们直接 <code>.foo</code> 会炸）。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">let</span><span class="μ1"> a</span><span class="μ0">:</span><span class="μ1"> {} </span><span class="μ0">=</span><span class="μ2"> null</span><span class="μ3"> // error</span></span></code></pre><p>此外，注意到对象都继承有 <code>Object.prototype</code>，所以我们可以调用这些方法而不爆炸：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">let</span><span class="μ1"> a</span><span class="μ0">:</span><span class="μ1"> {} </span><span class="μ0">=</span><span class="μ2"> 1</span></span>
<span class="line"><span class="μ1">a.</span><span class="μ4">toString</span><span class="μ1">() </span><span class="μ3">// ok</span></span></code></pre><p>上面的说法有个问题，<code>Object.create(null)</code> 可以不继承那些方法，但是 <code>Object.create()</code> 的类型返回 <code>any</code>，所以 TypeScript 实际检查不出下面代码的错误：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">let</span><span class="μ1"> a</span><span class="μ0">:</span><span class="μ1"> {} </span><span class="μ0">=</span><span class="μ1"> Object.</span><span class="μ4">create</span><span class="μ1">(</span><span class="μ2">null</span><span class="μ1">)</span></span>
<span class="line"><span class="μ1">a.</span><span class="μ4">toString</span><span class="μ1">() </span><span class="μ3">// types ok, but runtime error</span></span></code></pre><h3 id="object-非基本类型以外的所有"><code>object</code> 非基本类型以外的所有</h3>
<p>可以阅读 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-2-2/#the-object-type">TypeScript 2.2 的更新说明</a>，就是 <code>{}</code> 去掉 <code>number</code> 之类的基本类型。</p>
<p>实际上，除了标准库里会有一些接口必须传入非基本类型对象（如 <code>map.set(object,value)</code>）外，日常操作几乎用不着这个玩意儿。</p>
<h4 id="object-所有对象都继承的形状"><code>Object</code> 所有对象都继承的形状</h4>
<p><code>Object</code>（大写 <code>O</code>）是定义在 <code>libes*.d.ts</code> 里的 interface，它是所有对象类型最终继承的形状，所以它上面的方法可以从任意对象上点出来使用。</p>
<p>除了用于扩展标准库以外，日常操作几乎用不着这个玩意儿。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ3">// 可能的用途</span></span>
<span class="line"><span class="μ3">// 模块上下文需要 declare global，脚本上下文不需要</span></span>
<span class="line"><span class="μ0">declare</span><span class="μ1"> global {</span></span>
<span class="line"><span class="μ0">  interface</span><span class="μ4"> Object</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ4">    foo</span><span class="μ1">()</span><span class="μ0">:</span><span class="μ2"> number</span></span>
<span class="line"><span class="μ1">  }</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ2">Object</span><span class="μ1">.</span><span class="μ2">prototype</span><span class="μ1">.</span><span class="μ4">foo</span><span class="μ0"> =</span><span class="μ0"> function</span><span class="μ4"> foo</span><span class="μ1">() {</span></span>
<span class="line"><span class="μ0">  return</span><span class="μ2"> 42</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><h3 id="recordstring-any-传统字典或者不如-"><code>Record&lt;string, any&gt;</code> 传统字典，或者不如 <code>{}</code></h3>
<p>在 <code>Map</code>（es6）发明出来之前，JS 里只能使用对象来模拟使用字典（实际上 v8 会检测这种用法并在底层切到一个真的字典实现）。因此 <code>Record&lt;K, V&gt;</code> 可以用于标记这种用法。</p>
<p>另一种用法是，当你在玩一些类型体操，操作用户传入或者 infer 出来的对象类型时，需要先用 <code>extends</code> 来限制传进来的确实是对象类型，你可能会在哪里看到这种写法：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">function</span><span class="μ4"> foo</span><span class="μ1">&#x3C;</span><span class="μ4">T</span><span class="μ0"> extends</span><span class="μ4"> Record</span><span class="μ1">&#x3C;</span><span class="μ2">string</span><span class="μ1">, </span><span class="μ2">any</span><span class="μ1">>>(</span><span class="μ5">obj</span><span class="μ0">:</span><span class="μ4"> T</span><span class="μ1">, </span><span class="μ5">key</span><span class="μ0">:</span><span class="μ0"> keyof</span><span class="μ4"> T</span><span class="μ1">) {}</span></span></code></pre><p>简单解释一下 <code>extends</code>，这个关键字限制传进来的类型必须被右侧的类型<em>包含</em>，然后可以对原类型做后续处理（如 <code>keyof</code> 和别的体操）。</p>
<p>显然，这个例子里我们限制第一个参数大概需要是个对象，然后第二个参数会推导出第一个参数的下标。那么用 <code>{}</code> 可以吗？可以！</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">type</span><span class="μ4"> Foo</span><span class="μ1">&#x3C;</span><span class="μ4">T</span><span class="μ0"> extends</span><span class="μ1"> {}> </span><span class="μ0">=</span><span class="μ0"> keyof</span><span class="μ4"> T</span></span>
<span class="line"><span class="μ3">// type A = 'a' | 'b'</span></span>
<span class="line"><span class="μ0">type</span><span class="μ4"> A</span><span class="μ0"> =</span><span class="μ4"> Foo</span><span class="μ1">&#x3C;{ </span><span class="μ5">a</span><span class="μ0">:</span><span class="μ2"> 1</span><span class="μ1">; </span><span class="μ5">b</span><span class="μ0">:</span><span class="μ2"> 2</span><span class="μ1"> }></span></span>
<span class="line"><span class="μ3">// type B = 'toString' | 'toFixed' | 'toExponential' | 'toPrecision' | 'valueOf' | 'toLocaleString'</span></span>
<span class="line"><span class="μ0">type</span><span class="μ4"> B</span><span class="μ0"> =</span><span class="μ4"> Foo</span><span class="μ1">&#x3C;</span><span class="μ2">1</span><span class="μ1">></span></span></code></pre><p><q>这不对</q>，你可能想这么说。这一眼看上去不符合你对用户的用法的期待，但是类型和运行时上都是允许的。</p>
<!-- prettier-ignore -->
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">foo</span><span class="μ1">(</span><span class="μ2">1</span><span class="μ1">, </span><span class="μ6">'toString'</span><span class="μ1">); </span><span class="μ3">// ok</span></span>
<span class="line"><span class="μ1">(</span><span class="μ2">1</span><span class="μ1">)[</span><span class="μ6">'toString'</span><span class="μ1">] </span><span class="μ3">// ok</span></span></code></pre><p>我建议所有人都把 <code>extends Record&lt;string, any&gt;</code> 换成 <code>extends {}</code>，因为</p>
<ul>
<li>对类型的限制更宽松</li>
<li>更短，好写好读</li>
<li>（性能上）更快</li>
<li>（语义上）更正确</li>
</ul>
<h3 id="typescript-eslint-历史遗留问题"><code>typescript-eslint</code> 历史遗留问题</h3>
<p><a target="_blank" rel="noopener" href="https://typescript-eslint.io/rules/ban-types/">typescript-eslint 默认禁止你使用 <code>Object</code> 和 <code>{}</code></a>，前者没什么问题，但 <code>{}</code> 实际上是很有用的类型。这纯粹是因为 TypeScript 以前的 <code>{}</code> 没那么好用。</p>
<p>你可以添加以下规则来覆盖它对 <code>{}</code> 的限制：</p>
<!-- prettier-ignore -->
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">{</span></span>
<span class="line"><span class="μ2">  "@typescript-eslint/ban-types"</span><span class="μ1">: [</span><span class="μ6">"error"</span><span class="μ1">, {</span></span>
<span class="line"><span class="μ2">    "types"</span><span class="μ1">: { </span><span class="μ2">"{}"</span><span class="μ1">: </span><span class="μ2">false</span><span class="μ1"> },</span></span>
<span class="line"><span class="μ2">    "extendDefaults"</span><span class="μ1">: </span><span class="μ2">true</span></span>
<span class="line"><span class="μ1">  }]</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[CRDT: 分数排序]]></title>
        <id>https://hyrious.me/p/crdt-fractional-indexing</id>
        <link href="https://hyrious.me/p/crdt-fractional-indexing"/>
        <updated>2023-01-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#D73A49}.μ1{color:#24292E}.μ2{color:#032F62}.μ3{color:#005CC5}.μ4{color:#6A737D}@media(prefers-color-scheme:dark){.μ0{color:#F97583}.μ1{color:#E1E4E8}.μ2{color:#9ECBFF}.μ3{color:#79B8FF}.μ4{color:#6A737D}}</style><blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-fractional-indexing">&laquo;CRDT: Fractional Indexing&raquo;</a>
原网站里还有精美的可视化效果。</p>
</blockquote>
<p>CRDT 是一系列解决协作问题的算法，其中一个不可避免的问题就是：如何记录顺序，如何在发生顺序修改时表现正确。假设我们使用一个数组来记录一组数据的话：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">var</span><span class="μ1"> todos </span><span class="μ0">=</span><span class="μ1"> [</span><span class="μ2">'hello'</span><span class="μ1">, </span><span class="μ2">'world'</span><span class="μ1">]</span></span></code></pre><p>在同步这个数据时，不可避免地要将这个数组发来发去，当数据量很大时显然不是一个优解。此时先别急着实现 CRDT 链表，我们可以让每个元素多记录一个特殊的数据用来排序，并且用这种方式的网络传输压力很小，下面就来看看。</p>
<p>首先，利用传统的 LWW (last-write-win) 算法，我们可以实现 CRDT Map，但这里面的元素不是有序的。接着，我们给每个元素添加一个字段表示它在数组中的位置。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">var</span><span class="μ1"> todos </span><span class="μ0">=</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  '1@1'</span><span class="μ1">: { text: </span><span class="μ2">'hello'</span><span class="μ1">, position: </span><span class="μ2">'?'</span><span class="μ1"> },</span></span>
<span class="line"><span class="μ2">  '1@2'</span><span class="μ1">: { text: </span><span class="μ2">'world'</span><span class="μ1">, position: </span><span class="μ2">'?'</span><span class="μ1"> },</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><p>其中左边的 <code>1@1</code> 只是用来标记元素唯一的，它可以通过 <code>client(本地随机id) + clock(自增整数)</code> 的方式生成。右边的 <code>position</code> 是本文即将说明的技巧，有了它就可以轻松实现排序、有序元素间交换等行为。</p>
<h3 id="position-的定义"><code>position</code> 的定义</h3>
<p>我们定义 <code>position</code> 是一个从 0 到 1 的数，当出现新的元素要插到某个有序列中时，取其前后元素的 <code>position</code>，折半即可得到新元素的 <code>position</code>。当没有前元素时，认为它是 0，当没有后元素时，认为它是 1。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">var</span><span class="μ1"> todos </span><span class="μ0">=</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  '1@1'</span><span class="μ1">: { text: </span><span class="μ2">'hello'</span><span class="μ1">, position: </span><span class="μ3">0.5</span><span class="μ1"> }, </span><span class="μ4">// 第一个元素，插入 0 ~ 1 的中间，取 0.5</span></span>
<span class="line"><span class="μ2">  '1@2'</span><span class="μ1">: { text: </span><span class="μ2">'world'</span><span class="μ1">, position: </span><span class="μ3">0.75</span><span class="μ1"> }, </span><span class="μ4">// 第二个元素，插入 0.5 ~ 1 的中间，取 0.75</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><p>直接二分取数的话，很快我们就会碰到浮点数的瓶颈：折半失效了！此时可以把它转成字符串，利用大整数的实现思路，实现一个无限精度的小数（或者称之为以 10 的指数为分母的分数）。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">var</span><span class="μ1"> todos </span><span class="μ0">=</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  '1@1'</span><span class="μ1">: { text: </span><span class="μ2">'hello'</span><span class="μ1">, position: </span><span class="μ2">'0.5'</span><span class="μ1"> }, </span><span class="μ4">// 5/10</span></span>
<span class="line"><span class="μ2">  '1@2'</span><span class="μ1">: { text: </span><span class="μ2">'world'</span><span class="μ1">, position: </span><span class="μ2">'0.75'</span><span class="μ1"> }, </span><span class="μ4">// 75/100</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><h3 id="冲突处理">冲突处理</h3>
<p>上面这个技巧在多人协作时会有一个问题：如果两个人同时在一个位置插入了新节点，岂不是会产生两个一模一样的 <code>position</code>？</p>
<p>首先我们肯定不能让排序的结果不对，我们可以用客户端本地生成的随机 id (也就是上面 <code>todos</code> 的 keys) 对这些节点的排序算法做兜底。</p>
<p>其次有一个简单的方法可以避免这种确定性冲突——引入不确定的随机数即可，每次不光是折半产生下标，并且我们故意往后多添加几位随机数。在十进制下，仅仅是多添加三个字节就可以达到 1000 种不同的后缀，而这么多人同时操作同一个有序列表的概率不大。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">var</span><span class="μ1"> todos </span><span class="μ0">=</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ2">  '1@1'</span><span class="μ1">: { text: </span><span class="μ2">'hello'</span><span class="μ1">, position: </span><span class="μ2">'0.5123'</span><span class="μ1"> }, </span><span class="μ4">// ~5/10</span></span>
<span class="line"><span class="μ2">  '1@2'</span><span class="μ1">: { text: </span><span class="μ2">'world'</span><span class="μ1">, position: </span><span class="μ2">'0.75478'</span><span class="μ1"> }, </span><span class="μ4">// ~75/100</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><p>当然，如果放宽 CRDT 的限制，引入中心服务器裁决的话，也可以让服务器帮冲突的节点挑选一个新位置。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[JS 作用域碎碎念]]></title>
        <id>https://hyrious.me/p/js-scope</id>
        <link href="https://hyrious.me/p/js-scope"/>
        <updated>2023-01-17T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#D73A49}.μ1{color:#24292E}.μ2{color:#005CC5}.μ3{color:#6F42C1}.μ4{color:#6A737D}.μ5{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#F97583}.μ1{color:#E1E4E8}.μ2{color:#79B8FF}.μ3{color:#B392F0}.μ4{color:#6A737D}.μ5{color:#FFAB70}}</style><p>JS 里存在两类<q>块</q>，一种是 block <code>{}</code>，另一种是 function body <code>(){}</code>（包括 method），这两种块对不同的变量声明会有不同的作用域效果，下面就来看看。</p>
<h4 id="var"><code>var</code></h4>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">if</span><span class="μ1"> (</span><span class="μ2">false</span><span class="μ1">) {</span></span>
<span class="line"><span class="μ0">  var</span><span class="μ1"> a </span><span class="μ0">=</span><span class="μ2"> 1</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(a) </span><span class="μ4">// undefined</span></span></code></pre><p><code>var</code> 是一种历史悠久的变量，他不认识 block <code>{}</code>，会直接提升到第一个 function body 区，即使是 Dead-code 也不例外。</p>
<h4 id="let-const"><code>let</code>, <code>const</code></h4>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">let</span><span class="μ1"> a </span><span class="μ0">=</span><span class="μ2"> 1</span></span>
<span class="line"><span class="μ0">if</span><span class="μ1"> (</span><span class="μ2">true</span><span class="μ1">) {</span></span>
<span class="line"><span class="μ0">  const</span><span class="μ2"> a</span><span class="μ0"> =</span><span class="μ2"> 2</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(a) </span><span class="μ4">// 1</span></span></code></pre><p><code>let</code> 和 <code>const</code> 严格存在于当前 block 内，不会发生任何变量提升。</p>
<h4 id="function"><code>function</code></h4>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">if</span><span class="μ1"> (</span><span class="μ2">false</span><span class="μ1">) {</span></span>
<span class="line"><span class="μ0">  function</span><span class="μ3"> foo</span><span class="μ1">() {}</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(foo) </span><span class="μ4">// undefined</span></span></code></pre><p><code>function</code> 也是一种定义变量的方式，他和 <code>var</code> 一样悠久，提升规则和 <code>var</code> 几乎一样，但有两点不同：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">const</span><span class="μ2"> a</span><span class="μ0"> =</span><span class="μ2"> 1</span></span>
<span class="line"><span class="μ0">if</span><span class="μ1"> (</span><span class="μ2">false</span><span class="μ1">) {</span></span>
<span class="line"><span class="μ0">  var</span><span class="μ1"> a </span><span class="μ0">=</span><span class="μ2"> 2</span><span class="μ4"> // SyntaxError: Identifier 'a' has already been declared</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">const</span><span class="μ2"> foo</span><span class="μ0"> =</span><span class="μ2"> 1</span></span>
<span class="line"><span class="μ0">if</span><span class="μ1"> (</span><span class="μ2">true</span><span class="μ1">) {</span></span>
<span class="line"><span class="μ0">  function</span><span class="μ3"> foo</span><span class="μ1">() {}</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(foo) </span><span class="μ4">// 1</span></span></code></pre><ol>
<li><code>var</code> 会不择手段地提升，碰到 <code>const</code>, <code>let</code> 之类硬茬就会爆炸；而 <code>function</code> 则温和很多。</li>
</ol>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(a, </span><span class="μ3">foo</span><span class="μ1">()) </span><span class="μ4">// undefined, 2</span></span>
<span class="line"><span class="μ0">var</span><span class="μ1"> a </span><span class="μ0">=</span><span class="μ2"> 1</span></span>
<span class="line"><span class="μ0">function</span><span class="μ3"> foo</span><span class="μ1">() {</span></span>
<span class="line"><span class="μ0">  return</span><span class="μ2"> 2</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><ol start="2">
<li>和 <code>var</code> 只送一个 <code>undefined</code> 不同，<code>function</code> 会连着定义一起送出去，我们可以 <em>看起来</em> 在定义之前就使用他。实际上，可以认为 <code>function</code> 连着内容一起被提升到了当前函数块的顶部执行。</li>
</ol>
<p>另外，当整个 <code>function</code> 作为表达式而不是语句存在时，其名称只会被限定在函数体内可以访问：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">$button.</span><span class="μ3">onclick</span><span class="μ0"> =</span><span class="μ0"> function</span><span class="μ3"> hello</span><span class="μ1">() {</span></span>
<span class="line"><span class="μ1">  console.</span><span class="μ3">log</span><span class="μ1">(hello.name) </span><span class="μ4">// 'hello'</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(hello) </span><span class="μ4">// ReferenceError: hello is not defined</span></span></code></pre><h4 id="class"><code>class</code></h4>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">const</span><span class="μ2"> A</span><span class="μ0"> =</span><span class="μ2"> 1</span></span>
<span class="line"><span class="μ0">if</span><span class="μ1"> (</span><span class="μ2">true</span><span class="μ1">) {</span></span>
<span class="line"><span class="μ0">  class</span><span class="μ3"> A</span><span class="μ1"> {}</span></span>
<span class="line"><span class="μ2">  A</span><span class="μ0"> =</span><span class="μ2"> 2</span></span>
<span class="line"><span class="μ1">}</span></span>
<span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(</span><span class="μ2">A</span><span class="μ1">) </span><span class="μ4">// 1</span></span></code></pre><p><code>class</code> 创造的变量约等于 <code>let</code>，不过需要注意的是，在 <code>class</code> 的静态表达式中是可以直接访问到其类名的，而 <code>let</code> 需要先执行完 <code>class</code>，反而不能这么使用：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">class</span><span class="μ3"> A</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ0">  static</span><span class="μ5"> a</span><span class="μ0"> =</span><span class="μ2"> A</span><span class="μ1">.name </span><span class="μ4">// 'A'</span></span>
<span class="line"><span class="μ0">  static</span><span class="μ5"> b</span><span class="μ0"> =</span><span class="μ2"> this</span><span class="μ1">.name </span><span class="μ4">// can also use `this`</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">let</span><span class="μ2"> A</span><span class="μ0"> =</span><span class="μ0"> class</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ0">  static</span><span class="μ5"> a</span><span class="μ0"> =</span><span class="μ2"> A</span><span class="μ1">.name </span><span class="μ4">// ReferenceError: A is not defined</span></span>
<span class="line"><span class="μ0">  static</span><span class="μ5"> b</span><span class="μ0"> =</span><span class="μ2"> this</span><span class="μ1">.name </span><span class="μ4">// 'A'</span></span>
<span class="line"><span class="μ1">}</span></span></code></pre><p>注意到最后一个例子，<code>A.b</code> 可以拿到 <code>&#39;A&#39;</code>，这是因为匿名类会被自动赋予左边的变量名。当左边不是一个变量的时候该类的名字就是空了：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">console.</span><span class="μ3">log</span><span class="μ1">(</span></span>
<span class="line"><span class="μ0">  class</span><span class="μ1"> {</span></span>
<span class="line"><span class="μ0">    static</span><span class="μ5"> b</span><span class="μ0"> =</span><span class="μ2"> this</span><span class="μ1">.name</span></span>
<span class="line"><span class="μ1">  }.b,</span></span>
<span class="line"><span class="μ1">) </span><span class="μ4">// ''</span></span></code></pre>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[NPM Browser: 在线浏览 NPM 包内容]]></title>
        <id>https://hyrious.me/p/npm-browser</id>
        <link href="https://hyrious.me/p/npm-browser"/>
        <updated>2022-12-14T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p><time>2022-12-14</time> 更新</p>
<p>最近 npm 官网上线了一个查看包内容的 tab <a target="_blank" rel="noopener" href="https://www.npmjs.com/package/npm?activeTab=explore">https://www.npmjs.com/package/npm?activeTab=explore</a>, <a target="_blank" rel="noopener" href="https://github.blog/changelog/2022-12-06-explore-the-content-of-your-npm-packages-with-the-new-code-explorer/">https://github.blog/changelog/2022-12-06-explore-the-content-of-your-npm-packages-with-the-new-code-explorer/</a></p>
<hr>
<p><time>2022-08-24</time> 更新</p>
<p>我以前经常使用 <a target="_blank" rel="noopener" href="https://cdn.jsdelivr.net/npm/lib0/">jsdelivr</a> 和 <a target="_blank" rel="noopener" href="https://unpkg.com/lib0/">unpkg</a> 来查看一些 NPM 包的源码，这么做有几个好处：</p>
<ol>
<li>假如这个包没有开源<sup><a href="#user-content-fn-1" data-footnote-ref="" id="user-content-fnref-1">1</a></sup>，我们仍然可以读到一些有用的内容；</li>
<li>虽然开源了，但是有可能打包工具配置有问题，可以借助这些网站快速查看包结构；</li>
<li>是在线的，不用污染本地环境。</li>
</ol>
<p>虽然这两个 CDN 都很快，但是想要切换文件还是比较慢。因此我写了个 <a target="_blank" rel="noopener" href="https://hyrious.me/npm-browser">NPM Browser</a> 来满足我的需求，它的前身是 <a target="_blank" rel="noopener" href="https://hyrious.me/tool/npm.html">tool/npm</a>。</p>
<h3 id="用法">用法</h3>
<p>直接打开输入包名即可从 npm registry 上下载 tgz 并解压出来查看。目前我还没有发现第二个 npm registry 镜像能够给前端开 CORS 的。并且我还用了 indexeddb 缓存每个包的内容，浏览看过的包会很快。</p>
<p>搜索包也是用的 npm registry 的 API，有时可能会超出 rate limit 导致无法响应。</p>
<p>地址栏会实时显示整个应用的状态，可以简单地分享给别人<del>对线</del>，格式为:</p>
<pre><code>网址?q=包名@版本/package/路径:行数</code></pre><p>下面演示几个用法：</p>
<ul>
<li>查看最新版 lodash 包的内容: <a target="_blank" rel="noopener" href="https://hyrious.me/npm-browser/?q=lodash">https://hyrious.me/npm-browser/?q=lodash</a></li>
<li>指定到具体版本的具体文件的具体行: <a target="_blank" rel="noopener" href="https://hyrious.me/npm-browser/?q=@github/textarea-autosize@0.3.0/package/dist/index.js:72">https://hyrious.me/npm-browser/?q=@github/textarea-autosize@0.3.0/package/dist/index.js:72</a></li>
</ul>
<p>另一个我觉得很有用的功能是文件 diff，在标题栏包名右边第二个按钮就是。有的时候一些第三方包升级，但是 changelog 不会事无巨细地列出所有代码的修改，此时可以利用这个功能查看到底改了啥，例如前几天 markedjs 更新了一个小版本：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://hyrious.me/tool/diff-npm.html?a=marked%404.0.18%2Flib%2Fmarked.esm.js&b=marked%404.0.19%2Flib%2Fmarked.esm.js&s=1&f=l">/package/lib/marked.esm.js: marked@4.0.18 &rarr; marked@4.0.19</a></li>
</ul>
<p>以上。</p>
<section class="footnotes"><ol dir="auto"><li id="user-content-fn-1"><p dir="auto">例如 <a target="_blank" rel="noopener" href="https://motion.dev">motion</a> <a href="#user-content-fnref-1" class="data-footnote-backref" aria-label="Back to content"><g-emoji class="g-emoji" alias="leftwards_arrow_with_hook" fallback-src="https://github.githubassets.com/images/icons/emoji/unicode/21a9.png">↩</g-emoji></a></p></li></ol></section>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[热更新是怎么工作的]]></title>
        <id>https://hyrious.me/p/hmr</id>
        <link href="https://hyrious.me/p/hmr"/>
        <updated>2022-02-19T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#D73A49}.μ1{color:#24292E}.μ2{color:#6F42C1}.μ3{color:#005CC5}.μ4{color:#6A737D}.μ5{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#F97583}.μ1{color:#E1E4E8}.μ2{color:#B392F0}.μ3{color:#79B8FF}.μ4{color:#6A737D}.μ5{color:#9ECBFF}}</style><p>注：并非指线上软件不重启更新，而是指开发阶段能够获得更好的开发体验。</p>
<hr>
<p>几年前我玩 RPG Maker 的时候也想过这个问题，每次修改过脚本后都要重新启动游戏才能测试效果，有没有什么办法可以不重启呢？</p>
<p>简单地想，如果直接重新执行被修改的那一页脚本，那么只需要他能保证执行后是想要的效果就行了。由于大部分脚本插件都是<q>插件</q>式的，他们通常是使用 <code>alias</code> 修改一些个默认系统里的方法以及定义一些新模块，由于 Ruby 有<q>打开类</q>的元编程特性，所以重新执行一段类/模块定义并不会出错，那么只需要能让一段基于 <code>alias</code> 写的插件执行两遍等于只执行第二遍就行了！</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">alias</span><span class="μ1"> old_meth meth</span></span>
<span class="line"><span class="μ0">def</span><span class="μ2"> meth</span></span>
<span class="line"><span class="μ0">  return</span><span class="μ1"> old_meth </span><span class="μ0">+</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ0">end</span></span></code></pre><p>假设有这样的插件代码。仔细观察，我们需要让 <code>old_meth</code> 第二次执行的时候仍然是<q>原方法</q>。怎么做呢？可以换成一个自定义的 <code>alias</code>：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">magic_alias </span><span class="μ3">:old_meth</span><span class="μ1">, </span><span class="μ3">:meth</span></span>
<span class="line"><span class="μ1">...</span></span></code></pre><p>如果上下文里已经有 <code>old_meth</code>，说明已经执行过一次，什么都不做就行：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">class</span><span class="μ0"> &#x3C;&#x3C;</span><span class="μ1"> self</span></span>
<span class="line"><span class="μ0">  def</span><span class="μ2"> magic_alias</span><span class="μ1">(name, value)</span></span>
<span class="line"><span class="μ0">    return</span><span class="μ0"> if</span><span class="μ1"> method_defined? name</span></span>
<span class="line"><span class="μ0">    alias_method</span><span class="μ1"> name, value </span><span class="μ4"># 否则正常使用原 alias 效果</span></span>
<span class="line"><span class="μ0">  end</span></span>
<span class="line"><span class="μ0">end</span></span></code></pre><p>所以，我当时的方案就是：在每页文件开头加这么一个神秘函数，用它代替 alias，然后重新执行这页代码，就可以适配大部分插件脚本的热更新了。</p>
<hr>
<p>Sublime Text 里也有一个针对插件的热更新机制，也是直接重新执行一下插件 python 文件。不过，它可以在顶层定义 <code>plugin_loaded</code> 和 <code>plugin_unloaded</code> 方法，在插件重载的时候可以利用这两个方法确保执行效果正确。</p>
<p>比起我的<q>神秘代码</q> + 重新执行，ST 的工作方式如下：</p>
<ol>
<li>原插件非阻塞调用 <code>plugin_unloaded</code></li>
<li>执行新插件</li>
<li>执行新插件的 <code>plugin_loaded</code></li>
</ol>
<p>这样一来，等于将热更新逻辑交给写插件的人实现。</p>
<hr>
<p>前端开发也有一套热更新方法，你可以在 <a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/hot-module-replacement/">webpack</a>、<a target="_blank" rel="noopener" href="https://github.com/rixo/rollup-plugin-hot">rollup</a>、<a target="_blank" rel="noopener" href="https://github.com/PepsRyuu/nollup/blob/master/docs/nollup-hooks.md">nollup</a>、<a target="_blank" rel="noopener" href="https://vitejs.dev/guide/features.html#hot-module-replacement">vite</a> 里看到一套 HMR 接口，其基本思路和上面提到的其实也是一回事，每个模块（文件）可以注册退出 <code>hot.dispose()</code> 和进入 <code>hot.accept()</code> 时干的事情，从而达到热更新效果。</p>
<p>以 Vite 为例，他的热更新流程如下：</p>
<ol>
<li>后端扫描代码文件，理清依赖关系，把代码里包含 <code>hot.accept()</code> 的文件视为<q>热更新模块边界</q></li>
<li>有文件发生变化时，通过 1 的依赖关系查找到变化文件的公共热更新边界，通知前端刷新这个文件</li>
<li>前端依次执行：<ol>
<li>调用所有相关文件的 <code>hot.dispose()</code> 回调</li>
<li>下载执行 2 找到的边界文件</li>
<li>调用该文件的 <code>hot.accept()</code> 回调</li>
</ol>
</li>
</ol>
<p>不过，这里存在一个陷阱：你能保证除了更新的文件以外的模块不变吗？</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">// global.js</span></span>
<span class="line"><span class="μ0">export</span><span class="μ0"> let</span><span class="μ1"> state </span><span class="μ0">=</span><span class="μ1"> []</span></span>
<span class="line"></span>
<span class="line"><span class="μ4">// a.js</span></span>
<span class="line"><span class="μ0">import</span><span class="μ1"> { state } </span><span class="μ0">from</span><span class="μ5"> './global.js'</span></span>
<span class="line"><span class="μ1">state.</span><span class="μ2">push</span><span class="μ1">(</span><span class="μ5">'a'</span><span class="μ1">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ4">// b.js</span></span>
<span class="line"><span class="μ0">import</span><span class="μ1"> { state } </span><span class="μ0">from</span><span class="μ5"> './global.js'</span></span>
<span class="line"><span class="μ1">state.</span><span class="μ2">push</span><span class="μ1">(</span><span class="μ5">'b'</span><span class="μ1">)</span></span></code></pre><p>如果 a.js 发生了热更新，他能否在更新期间拿到和 b.js 一样的 <code>state</code>？</p>
<p>如果不能，那么此时运行时出现了两个 <code>state</code>，可能会出现一些 bug。</p>
<p>因此，那些基于黑 <code>require</code> 或类似技术（如 SystemJS）的 HMR 实现，可以保证新加载的模块依然可以引用到公共模块，只需要动态决定 <code>require</code> 返回啥就行了（比如可以用 <code>id+timestamp</code> 标识模块的唯一性）。</p>
<p>而 Vite 这种基于原生 ESM 的，显然没有地方给他黑 <code>import</code>，他唯一能做的就是利用浏览器缓存来让浏览器觉得使用了同一个模块。继续思考，然后你会发现他这种方案只能<q>不打包</q>，否则总是无法实现模块的唯一性。</p>
<p>Vite 的方案有没有可能在 Node.js 里实现呢？不好说，因为我们不清楚 <code>import</code> 到底有没有 cache，以及这个 cache 认不认 query（<code>import &quot;mod?t=114514&quot;</code>）。</p>
<hr>
<p>什么东西适合热更新？虽然我上面只提了 RM/ST 插件、前端工具，但是不难看出，基本上就这些东西<q>在</q>实现热更新：</p>
<ul>
<li>即插即用的插件</li>
<li>前端组件库，包括 CSS 样式</li>
</ul>
<p>前者不难理解，本身已经对<q>即插即用</q>下了一些功夫。后者可以理解为，组件的副作用恰好是热更新的目标——因为组件本身存在生命周期，只需要调用前组件的卸载和新组件的挂载就行。这些组件就类似我一开篇提到的用 alias 编写的 RM 插件，因为符合某种规范所以恰好运行良好。</p>
<p>除此以外，适当缩小业务范围也不难定义出适合热更新的目标。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Sublime Text 插件踩坑]]></title>
        <id>https://hyrious.me/p/sublime-plugin-tips</id>
        <link href="https://hyrious.me/p/sublime-plugin-tips"/>
        <updated>2022-02-06T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#6A737D}.μ1{color:#D73A49}.μ2{color:#6F42C1}.μ3{color:#24292E}.μ4{color:#E36209}.μ5{color:#032F62}.μ6{color:#005CC5}@media(prefers-color-scheme:dark){.μ0{color:#6A737D}.μ1{color:#F97583}.μ2{color:#B392F0}.μ3{color:#E1E4E8}.μ4{color:#FFAB70}.μ5{color:#9ECBFF}.μ6{color:#79B8FF}}</style><p>春节花了几天写了一个 <a target="_blank" rel="noopener" href="https://github.com/hyrious/prettierd">Sublime Text 插件</a>，这里大概记录一下关于它（主要是 python 部分）的小知识。</p>
<h3 id="sublimeset_timeout-和-sublimeset_timeout_async"><samp>sublime.set_timeout()</samp> 和 <samp>sublime.set_timeout_async()</samp></h3>
<p>文档上说 <q><samp>_async</samp></q> 会放在另一个线程里执行，听着似乎等于 <samp>threading<wbr>.Thread()<wbr>.start()</samp>？其实不然！这里文档没有明说的是，sublime 一共只有两个线程 —— 主渲染线程和 worker 线程。<q><samp>_async</samp></q> 的意思是把一个函数放到 worker 线程里跑 —— worker 线程里的任务还是会互相阻塞。所以一旦我们需要实现一些长时间阻塞的任务（如 <samp>process<wbr>.stdout<wbr>.readline()</samp>，假设你要做一个使用 tsserver 的插件<span class="half-shrink-right">）</span>，最好还是自己拿 Thread 搞事。</p>
<p>只有那些短时间且符合用户操作目的的单任务（例如格式化一下文本，当用户按下快捷键时，他期望编辑器做一些工作，但是又不希望整个程序像卡死了一样）适合在 worker 线程工作。</p>
<h3 id="async-await-py37"><samp>async await</samp> <span class="half-shrink-left">（</span>py3.7+）</h3>
<p>Sublime Text 4 提供了 python3.8 给新的插件，这意味着你可以写 <code>if a := 1</code> 和 <code>async def</code> 了。说到 <code>async</code> 我就不困了，我立马搬出《<a target="_blank" rel="noopener" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">函数染色问题</a>》。另外，在 sublime 里你总不能让一个 async 函数占着主线程，所以有了下面这段代码：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0"># Run a callback (-> coroutine) in a new `threading.Thread()`. Refer to</span></span>
<span class="line"><span class="μ0"># https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058</span></span>
<span class="line"><span class="μ1">def</span><span class="μ2"> run_in_new_thread</span><span class="μ3">(function, </span><span class="μ1">*</span><span class="μ3">args, </span><span class="μ1">**</span><span class="μ3">kwargs):</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">    # The "loop" holder.</span></span>
<span class="line"><span class="μ3">    loop </span><span class="μ1">=</span><span class="μ3"> asyncio.new_event_loop()</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">    # Kick start the event loop.</span></span>
<span class="line"><span class="μ1">    def</span><span class="μ2"> wrapper</span><span class="μ3">(loop):</span></span>
<span class="line"><span class="μ3">        asyncio.set_event_loop(loop)</span></span>
<span class="line"><span class="μ3">        loop.run_forever() </span><span class="μ0"># &#x3C;- block current thread, until "loop.stop()"</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">    # Send wrapper to a new thread with the loop.</span></span>
<span class="line"><span class="μ3">    t </span><span class="μ1">=</span><span class="μ3"> threading.Thread(</span><span class="μ4">target</span><span class="μ1">=</span><span class="μ3">wrapper, </span><span class="μ4">args</span><span class="μ1">=</span><span class="μ3">(loop,))</span></span>
<span class="line"><span class="μ3">    t.start()</span></span>
<span class="line"></span>
<span class="line"><span class="μ0">    # Run the callback with the loop.</span></span>
<span class="line"><span class="μ3">    coro </span><span class="μ1">=</span><span class="μ3"> function(</span><span class="μ1">*</span><span class="μ3">args, </span><span class="μ1">**</span><span class="μ3">kwargs)</span></span>
<span class="line"><span class="μ3">    future </span><span class="μ1">=</span><span class="μ3"> asyncio.run_coroutine_threadsafe(coro, loop)</span></span>
<span class="line"><span class="μ0">    # `await future` to wait for it.</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    return</span><span class="μ3"> future</span></span></code></pre><p>虽然他是 thread-safe 的，不过手操 thread 还是让我有点不爽。而且这抽象泄露也太严重了，直接给你一个 <samp>loop</samp> <span class="half-shrink-left">（</span>约等于 generator 函数给你的那个对象<span class="half-shrink-right">）</span>。</p>
<h3 id="subprocesspopen-和僵尸进程"><samp>subprocess.Popen</samp> 和僵尸进程</h3>
<p>你可以在任何 python 环境下（包括 REPL）试试这段代码：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">import</span><span class="μ3"> subprocess</span></span>
<span class="line"><span class="μ0"># 启动一个子进程，只要能一直跑随便用啥都行</span></span>
<span class="line"><span class="μ3">p </span><span class="μ1">=</span><span class="μ3"> subprocess.Popen([</span><span class="μ5">'ruby'</span><span class="μ3">, </span><span class="μ5">'-e'</span><span class="μ3">, </span><span class="μ5">'sleep 9999'</span><span class="μ3">])</span></span>
<span class="line"><span class="μ6">exit</span><span class="μ3">()</span></span></code></pre><p>你的 python 退出了，但是子进程还在跑！<span class="half-shrink-left">（</span>也就是所谓的僵尸进程<span class="half-shrink-right">）</span>。我以为是缺什么参数，结果他压根没有实现自动退出子进程的功能（隔壁 ruby、nodejs 可是默认行为，导致我都不知道还能这样<span class="half-shrink-right">）</span>。没有力量，所以只能找到 sublime 有个 <samp>on_exit</samp> 监听器，要在那里退出子进程。</p>
<h3 id="异步触发修改">异步触发修改</h3>
<p>出于操作的同步性考虑，插件必须在一次 <samp>TextCommand</samp> 回调里同步地完成对 view 的修改。一旦这个回调执行的同步代码太多，编辑器就会卡住，体验很不好。那么如何实现异步的修改呢？这里有一个小技巧，就是在异步任务结束的时候再触发一遍 <samp>TextCommand</samp> 并且把必要的参数传进去。一旦有新的用户操作会打断这次异步任务的，就加个标记不去触发即可。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[如何编写更快的 JS]]></title>
        <id>https://hyrious.me/p/fast-js</id>
        <link href="https://hyrious.me/p/fast-js"/>
        <updated>2022-01-28T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<p>这篇博客主要是对 4 年前的这篇 <q><a target="_blank" rel="noopener" href="https://mrale.ph/blog/2018/02/03/maybe-you-dont-need-rust-to-speed-up-your-js.html">Maybe you don&#39;t need Rust and WASM to speed up your JS</a></q> 的笔记。</p>
<p><strong>注意</strong>：过早优化是万恶之源，了解这篇博客<strong>可能</strong>有助于你写出更快的 JS/TS，但是不要一味追求写出让人看不懂的代码。</p>
<ol>
<li>调用函数时传递和声明一样多的参数，不使用可选参数。</li>
<li><a target="_blank" rel="noopener" href="https://mrale.ph/blog/2015/01/11/whats-up-with-monomorphism.html">单态化</a>函数，简单来说让每个参数的形状（对象的结构、或者函数本身）都永远不变。这个招式平时比较难搓，建议看前面的文章详细理解。</li>
<li>克制地使用缓存 —— 除非查找它比计算它容易。</li>
<li>想办法减少 GC 的压力，例如申请一个大的 TypedArray 存储定长数据。</li>
<li>如果只是在 <code>ASCII</code> 范围内工作，用 <code>Uint8Array</code> 代替 <code>String</code>。</li>
</ol>
<p>还有一些常识：</p>
<ol>
<li>用 <code>class</code> 维护对象的形状，不去改变 <code>prototype</code>。</li>
<li>从<q>维护形状</q>考虑，不要用 <code>Record&lt;string, X&gt;</code> 当 <code>Map/Set</code> 使 —— 直接用 <code>Map</code> 即可。</li>
</ol>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[简单理解 Tree Shaking]]></title>
        <id>https://hyrious.me/p/tree-shaking</id>
        <link href="https://hyrious.me/p/tree-shaking"/>
        <updated>2022-01-25T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#005CC5}.μ1{color:#032F62}.μ2{color:#24292E}.μ3{color:#6F42C1}.μ4{color:#D73A49}.μ5{color:#6A737D}.μ6{color:#E36209}@media(prefers-color-scheme:dark){.μ0{color:#79B8FF}.μ1{color:#9ECBFF}.μ2{color:#E1E4E8}.μ3{color:#B392F0}.μ4{color:#F97583}.μ5{color:#6A737D}.μ6{color:#FFAB70}}</style><p>问：如何分析并删除无用的 JS 代码？Tree-Shaking 给了打包器们一个简单的方法：只需要删除每个闭包里的没有<strong>使用</strong>且没有<strong>副作用</strong>的变量声明/表达式即可。剩下的就是需要给代码块（语法节点）标上有没有被使用、有没有副作用的信息。</p>
<p>怎么知道一段代码的副作用呢？<span class="half-shrink-left">（</span>换句话说，是不是<q>纯</q>的）</p>
<p>首先，纯字面量（数字，字符串等表达式）肯定没有副作用：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">42</span></span>
<span class="line"><span class="μ1">'hello'</span></span>
<span class="line"><span class="μ2">{ </span><span class="μ3">a</span><span class="μ2">: [] }</span></span>
<span class="line"><span class="μ4">function</span><span class="μ2">(){} </span><span class="μ5">// 函数本身也是没有副作用的 -- 除非你调他</span></span></code></pre><p><del>其次，</del> 没有其次了，仅此而已。光有上面这些信息就足够 shake 掉这个例子：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">function</span><span class="μ3"> add</span><span class="μ2">(</span><span class="μ6">a</span><span class="μ2">, </span><span class="μ6">b</span><span class="μ2">) { </span><span class="μ4">return</span><span class="μ2"> a </span><span class="μ4">+</span><span class="μ2"> b }</span></span>
<span class="line"><span class="μ4">function</span><span class="μ3"> mul</span><span class="μ2">(</span><span class="μ6">a</span><span class="μ2">, </span><span class="μ6">b</span><span class="μ2">) { </span><span class="μ4">return</span><span class="μ2"> a </span><span class="μ4">*</span><span class="μ2"> b }</span></span>
<span class="line"><span class="μ4">export</span><span class="μ4"> let</span><span class="μ2"> sum </span><span class="μ4">=</span><span class="μ3"> add</span><span class="μ2">(</span><span class="μ0">3</span><span class="μ2">, </span><span class="μ0">5</span><span class="μ2">)</span></span></code></pre><p align=center>&darr; &darr; &darr;</p>

<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">function</span><span class="μ3"> add</span><span class="μ2">(</span><span class="μ6">a</span><span class="μ2">, </span><span class="μ6">b</span><span class="μ2">) { </span><span class="μ4">return</span><span class="μ2"> a </span><span class="μ4">+</span><span class="μ2"> b }</span></span>
<span class="line"><span class="μ4">export</span><span class="μ4"> let</span><span class="μ2"> sum </span><span class="μ4">=</span><span class="μ3"> add</span><span class="μ2">(</span><span class="μ0">3</span><span class="μ2">, </span><span class="μ0">5</span><span class="μ2">)</span></span></code></pre><p>但是——你一拍大腿——能不能把函数调用也删掉呢？例如，假如我最终没有用上面的 <code>sum</code>，能不能把它连同 <code>add</code> 的定义一起删掉呢？——是可以的，用 Pure Annotation：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">export</span><span class="μ4"> let</span><span class="μ2"> sum </span><span class="μ4">=</span><span class="μ5"> /* @__PURE__ */</span><span class="μ3"> add</span><span class="μ2">(</span><span class="μ0">3</span><span class="μ2">, </span><span class="μ0">5</span><span class="μ2">)</span></span></code></pre><p>这个注释在告诉打包器：本次函数调用是<q>纯</q>的，其返回值和 <code>123</code> 差不多，如果没人用的话可以把这个调用删了。</p>
<p><strong>陷阱</strong>：但是你不能删掉函数括号里的东西。这是因为参数本身可能是由别的副作用产生的，兴许有人依赖这个副作用呢。例如：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ5">/* @__PURE__ */</span><span class="μ3"> debugPrint</span><span class="μ2">(</span><span class="μ3">createApp</span><span class="μ2">())</span></span></code></pre><p align=center>&darr; &darr; &darr;</p>

<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ3">createApp</span><span class="μ2">()</span></span></code></pre><p>这个标记对下面这种调用也有效：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ5">/* @__PURE__ */</span><span class="μ2"> React.</span><span class="μ3">createElement</span><span class="μ2">(</span><span class="μ1">'div'</span><span class="μ2">, {}, </span><span class="μ1">'Hello'</span><span class="μ2">)  </span><span class="μ5">// => nothing</span></span>
<span class="line"><span class="μ5">/* @__PURE__ */</span><span class="μ4"> new</span><span class="μ0"> A</span><span class="μ2">.b.c.</span><span class="μ3">d</span><span class="μ2">()                            </span><span class="μ5">// => nothing</span></span></code></pre><p>细心的你已经发现了：你无法对访问下标（<code>a.b</code>）标记是否含有副作用。实际上 esbuild 会认为所有的 getter setter 都是有副作用的。所以下面这段代码不能被 shake 掉：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">let</span><span class="μ2"> a </span><span class="μ4">=</span><span class="μ2"> {}</span></span>
<span class="line"><span class="μ2">a.b </span><span class="μ4">=</span><span class="μ0"> 1</span></span>
<span class="line"><span class="μ5">// 即使没有用到 a，这段代码也不能被删掉</span></span></code></pre><p>如果有一些复杂的初始化函数，你可以使用下面这个写法来规避这个问题：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">let</span><span class="μ2"> a </span><span class="μ4">=</span><span class="μ5"> /* @__PURE__ */</span><span class="μ2"> (() </span><span class="μ4">=></span><span class="μ2"> {</span></span>
<span class="line"><span class="μ4">  let</span><span class="μ2"> a </span><span class="μ4">=</span><span class="μ2"> {}</span></span>
<span class="line"><span class="μ2">  a.b </span><span class="μ4">=</span><span class="μ0"> 1</span></span>
<span class="line"><span class="μ4">  return</span><span class="μ2"> a</span></span>
<span class="line"><span class="μ2">})()</span></span></code></pre><p>注意：esbuild 的 <code>--minify-whitespace</code> 会将 <code>/* @__PURE__ */</code> 视为空格删掉，因此在输出 esm 时一定要记得关闭这个功能。</p>
<hr>
<p><strong>附赠：如何在打出的包里区分 dev/prod 环境？</strong></p>
<p>虽然 Node.js 推出了 conditional exports 并建议大家用这样的形式导出不同的包：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ1">"exports"</span><span class="μ2">: {</span></span>
<span class="line"><span class="μ0">  "development"</span><span class="μ2">: </span><span class="μ1">"./dist/index.dev.js"</span><span class="μ2">,</span></span>
<span class="line"><span class="μ0">  "production"</span><span class="μ2">: </span><span class="μ1">"./dist/index.prod.js"</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><p>但是前端生态可等不到他推广这个 feature，反而是使用了一个非常 cjs 的方法：</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ4">if</span><span class="μ2"> (process.env.</span><span class="μ0">NODE_ENV</span><span class="μ4"> ===</span><span class="μ1"> 'production'</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ0">  module</span><span class="μ2">.</span><span class="μ0">exports</span><span class="μ4"> =</span><span class="μ3"> require</span><span class="μ2">(</span><span class="μ1">'./dist/index.prod.js'</span><span class="μ2">)</span></span>
<span class="line"><span class="μ2">} </span><span class="μ4">else</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ0">  module</span><span class="μ2">.</span><span class="μ0">exports</span><span class="μ4"> =</span><span class="μ3"> require</span><span class="μ2">(</span><span class="μ1">'./dist/index.dev.js'</span><span class="μ2">)</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><p>你可以在 React 和 Vue3 的包里看到这种写法，而且现代打包器都对这种写法做了预处理。</p>
<hr>
<p>总之，理解了 Tree-Shaking 是如何工作的，才能让打包结果符合你的预期。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
    <entry>
        <title type="html"><![CDATA[Earley 算法]]></title>
        <id>https://hyrious.me/p/earley-parser</id>
        <link href="https://hyrious.me/p/earley-parser"/>
        <updated>2017-09-27T00:00:00.000Z</updated>
        <content type="html"><![CDATA[<style>.μ0{color:#D73A49}.μ1{color:#6F42C1}.μ2{color:#24292E}.μ3{color:#6A737D}.μ4{color:#005CC5}.μ5{color:#032F62}.μ6{color:#032F62}@media(prefers-color-scheme:dark){.μ0{color:#F97583}.μ1{color:#B392F0}.μ2{color:#E1E4E8}.μ3{color:#6A737D}.μ4{color:#79B8FF}.μ5{color:#9ECBFF}.μ6{color:#DBEDFF}}</style><ul>
<li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Earley_parser">Earley parser - Wikipedia</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/bitpeach/p/3602522.html">模式识别之 Earley 算法入门详讲 - bitpeach</a></li>
</ul>
<p>Earley parser 是一个可以在最坏 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><msup><mi>n</mi><mn>3</mn></msup><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n^3)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.0641em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">n</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span> 的复杂度下解析任何 CFG 文法的产生式的算法，它是支持左递归的。</p>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">new</span><span class="μ1"> EarleyParser</span><span class="μ2">({ CFG }).</span><span class="μ1">parse</span><span class="μ2">(str) </span><span class="μ3">//=> AST</span></span></code></pre><p>设某条 CFG 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>α</mi><mi>β</mi></mrow><annotation encoding="application/x-tex">X \to \alpha \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>，我们引入一个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 代表解析位置，例如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi><mo>→</mo><mi>α</mi><mo>⋅</mo><mi>β</mi></mrow><annotation encoding="application/x-tex">X \to \alpha \cdot \beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span> 代表当前正在匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 规则，已经匹配成功了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>，下一步是匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>。</p>
<p>设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是输入序列的第 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 个 token 所在的位置，对于每个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span>，Earley 算法都要产生一个 State 集合。每个 State 形如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><mi>α</mi><mo>⋅</mo><mi>β</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \to \alpha \cdot \beta, i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，代表我从 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 位置开始匹配的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 规则，已经匹配成功了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>α</mi></mrow><annotation encoding="application/x-tex">\alpha</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span></span></span></span>，下一步是匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>β</mi></mrow><annotation encoding="application/x-tex">\beta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8889em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span></span></span></span>。设 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 位置对应的 State 集合为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>。</p>
<p>首先，生成 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord">0</span><span class="mclose">)</span></span></span></span>；接下来重复执行以下操作：</p>
<ul>
<li>预测：如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 后面是一个非终结符如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><mi>α</mi><mo>⋅</mo><mi>Y</mi><mi>β</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \to \alpha \cdot Y \beta, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，我们把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>Y</mi></mrow><annotation encoding="application/x-tex">Y</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span></span></span></span> 开头的规则添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span>（<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 是当前位置，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.854em;vertical-align:-0.1944em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> 是刚才匹配 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的起始位置）</li>
<li>扫描：如果 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 后面是一个终结符如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><mi>α</mi><mo>⋅</mo><mi>a</mi><mi>β</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \to \alpha \cdot a \beta, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，我们把 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><mi>α</mi><mi>a</mi><mo>⋅</mo><mi>β</mi><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \to \alpha a \cdot \beta, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal">a</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>k</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(k + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span></li>
<li>规约：对于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 中的每个 State，如果它的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 到达该规则的末尾，如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>X</mi><mo>→</mo><mi>y</mi><mo>⋅</mo><mo separator="true">,</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(X \to y \cdot, j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord">⋅</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span>，说明我们已经匹配完成了这个（子）规则，在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">)</span></span></span></span> 中找到所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋅</mo></mrow><annotation encoding="application/x-tex">\cdot</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord">⋅</span></span></span></span> 后面是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>X</mi></mrow><annotation encoding="application/x-tex">X</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span></span></span></span> 的如 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo>→</mo><mi>α</mi><mo>⋅</mo><mi>X</mi><mi>β</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Y \to \alpha \cdot X \beta, i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.4445em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">Xβ</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span>，将小圆点后移一位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>Y</mi><mo>→</mo><mi>α</mi><mi>X</mi><mo>⋅</mo><mi>β</mi><mo separator="true">,</mo><mi>i</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(Y \to \alpha X \cdot \beta, i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.22222em;">Y</span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6833em;"></span><span class="mord mathnormal" style="margin-right:0.0037em;">α</span><span class="mord mathnormal" style="margin-right:0.07847em;">X</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05278em;">β</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.1667em;"></span><span class="mord mathnormal">i</span><span class="mclose">)</span></span></span></span> 添加到 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span></li>
</ul>
<p>注意：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>k</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(k)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">)</span></span></span></span> 是一个 <strong>集合</strong>，里面没有重复的 State。</p>
<p>设输入有 n 个 token，我们在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>S</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">S(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 中找到所有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6595em;"></span><span class="mord mathnormal">i</span></span></span></span> 是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span> 的，说明我们已经匹配完成了全部的规则，找到的都是合法的生成树。</p>
<h4 id="简单实现">简单实现</h4>
<pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span class="μ0">class</span><span class="μ1"> Earley</span></span>
<span class="line"><span class="μ0">  def</span><span class="μ1"> initialize</span><span class="μ2"> rules </span><span class="μ0">=</span><span class="μ2"> []</span></span>
<span class="line"><span class="μ2">    @rules </span><span class="μ0">=</span><span class="μ2"> rules</span></span>
<span class="line"><span class="μ0">  end</span></span>
<span class="line"><span class="μ0">  def</span><span class="μ1"> lazy_each_with_index</span><span class="μ2"> arr, i </span><span class="μ0">=</span><span class="μ4"> 0</span></span>
<span class="line"><span class="μ0">    yield</span><span class="μ2"> arr[i], (i </span><span class="μ0">+=</span><span class="μ4"> 1</span><span class="μ2">) </span><span class="μ0">-</span><span class="μ4"> 1</span><span class="μ0"> while</span><span class="μ2"> arr[i]</span></span>
<span class="line"><span class="μ0">  end</span></span>
<span class="line"><span class="μ0">  def</span><span class="μ1"> uniq_bfs</span><span class="μ2"> start </span><span class="μ0">=</span><span class="μ2"> [], i </span><span class="μ0">=</span><span class="μ4"> 0</span></span>
<span class="line"><span class="μ0">    yield</span><span class="μ2"> start[(i </span><span class="μ0">+=</span><span class="μ4"> 1</span><span class="μ2">) </span><span class="μ0">-</span><span class="μ4"> 1</span><span class="μ2">], </span><span class="μ4">-></span><span class="μ2"> x { start.push(x).uniq!; x } </span><span class="μ0">while</span><span class="μ2"> start[i]</span></span>
<span class="line"><span class="μ0">  end</span></span>
<span class="line"><span class="μ0">  def</span><span class="μ1"> parse</span><span class="μ2"> str, </span><span class="μ0">&#x26;</span><span class="μ2">lex</span></span>
<span class="line"><span class="μ2">    s </span><span class="μ0">=</span><span class="μ2"> [[[@rules[</span><span class="μ4">0</span><span class="μ2">], </span><span class="μ4">0</span><span class="μ2">, </span><span class="μ4">0</span><span class="μ2">]]]</span></span>
<span class="line"><span class="μ2">    lazy_each_with_index(s) { |set, k|</span></span>
<span class="line"><span class="μ2">      s.push [] </span><span class="μ0">if</span><span class="μ2"> token </span><span class="μ0">=</span><span class="μ2"> lex.(str)</span></span>
<span class="line"><span class="μ2">      uniq_bfs(set) { |((n, rule), i, j), u|</span></span>
<span class="line"><span class="μ0">        if</span><span class="μ2"> rule.size </span><span class="μ0">==</span><span class="μ2"> i</span></span>
<span class="line"><span class="μ2">          s[j].</span><span class="μ4">select</span><span class="μ2"> { |(_, rule), i, _| rule[i] </span><span class="μ0">==</span><span class="μ2"> n }.each { |e, i, j| u.([e, i </span><span class="μ0">+</span><span class="μ4"> 1</span><span class="μ2">, j]) }</span></span>
<span class="line"><span class="μ0">        elsif</span><span class="μ2"> rule[i].is_a? </span><span class="μ4">Symbol</span></span>
<span class="line"><span class="μ2">          @rules.</span><span class="μ4">select</span><span class="μ2"> { |e, _| rule[i] </span><span class="μ0">==</span><span class="μ2"> e }.each { |e| u.([e, </span><span class="μ4">0</span><span class="μ2">, k]) }</span></span>
<span class="line"><span class="μ0">        elsif</span><span class="μ2"> match rule[i], token</span></span>
<span class="line"><span class="μ2">          s[k </span><span class="μ0">+</span><span class="μ4"> 1</span><span class="μ2">].push [[n, rule], i </span><span class="μ0">+</span><span class="μ4"> 1</span><span class="μ2">, j]</span></span>
<span class="line"><span class="μ0">        end</span></span>
<span class="line"><span class="μ2">      }</span></span>
<span class="line"><span class="μ2">    }</span></span>
<span class="line"><span class="μ2">    s[</span><span class="μ0">-</span><span class="μ4">1</span><span class="μ2">].any? { |(n, rule), i, j| n </span><span class="μ0">==</span><span class="μ2"> @rules[</span><span class="μ4">0</span><span class="μ2">][</span><span class="μ4">0</span><span class="μ2">] </span><span class="μ0">&#x26;&#x26;</span><span class="μ2"> rule.size </span><span class="μ0">==</span><span class="μ2"> i </span><span class="μ0">&#x26;&#x26;</span><span class="μ2"> j.zero? }</span></span>
<span class="line"><span class="μ0">  end</span></span>
<span class="line"><span class="μ0">  def</span><span class="μ1"> match</span><span class="μ2"> pattern, token</span></span>
<span class="line"><span class="μ0">    case</span><span class="μ2"> pattern</span></span>
<span class="line"><span class="μ0">    when</span><span class="μ4"> String</span><span class="μ0"> then</span><span class="μ2"> token </span><span class="μ0">==</span><span class="μ2"> pattern</span></span>
<span class="line"><span class="μ0">    when</span><span class="μ4"> Regexp</span><span class="μ0"> then</span><span class="μ2"> token </span><span class="μ0">=~</span><span class="μ2"> pattern</span></span>
<span class="line"><span class="μ0">    else</span><span class="μ4"> false</span></span>
<span class="line"><span class="μ0">    end</span></span>
<span class="line"><span class="μ0">  end</span></span>
<span class="line"><span class="μ0">end</span></span>
<span class="line"></span>
<span class="line"><span class="μ4">p</span><span class="μ4"> Earley</span><span class="μ2">.</span><span class="μ0">new</span><span class="μ2">([</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:P</span><span class="μ2">, [</span><span class="μ4">:S</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:S</span><span class="μ2">, [</span><span class="μ4">:S</span><span class="μ2">, </span><span class="μ5">'+'</span><span class="μ2">, </span><span class="μ4">:M</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:S</span><span class="μ2">, [</span><span class="μ4">:S</span><span class="μ2">, </span><span class="μ5">'-'</span><span class="μ2">, </span><span class="μ4">:M</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:S</span><span class="μ2">, [</span><span class="μ4">:M</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:M</span><span class="μ2">, [</span><span class="μ4">:M</span><span class="μ2">, </span><span class="μ5">'*'</span><span class="μ2">, </span><span class="μ4">:T</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:M</span><span class="μ2">, [</span><span class="μ4">:M</span><span class="μ2">, </span><span class="μ5">'/'</span><span class="μ2">, </span><span class="μ4">:T</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:M</span><span class="μ2">, [</span><span class="μ4">:T</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">  [</span><span class="μ4">:T</span><span class="μ2">, [</span><span class="μ5">/</span><span class="μ6">^</span><span style="color:#22863A;--s-dark:#85E89D;font-weight:bold;--s-dark-font-weight:bold">\d</span><span class="μ6">+$</span><span class="μ5">/</span><span class="μ2">]],</span></span>
<span class="line"><span class="μ2">]).parse(</span><span class="μ5">'2 + 3 - 4'</span><span class="μ2">) { |s|</span></span>
<span class="line"><span class="μ2">  s.slice!(</span><span class="μ5">/</span><span class="μ6">^</span><span style="color:#22863A;--s-dark:#85E89D;font-weight:bold;--s-dark-font-weight:bold">\s</span><span class="μ6">+</span><span class="μ5">/</span><span class="μ2">)</span></span>
<span class="line"><span class="μ2">  s.slice!(</span><span class="μ5">/</span><span class="μ6">^</span><span style="color:#22863A;--s-dark:#85E89D;font-weight:bold;--s-dark-font-weight:bold">\d</span><span class="μ6">+|</span><span style="color:#22863A;--s-dark:#85E89D;font-weight:bold;--s-dark-font-weight:bold">\+</span><span class="μ6">|</span><span style="color:#22863A;--s-dark:#85E89D;font-weight:bold;--s-dark-font-weight:bold">\-</span><span class="μ6">|</span><span style="color:#22863A;--s-dark:#85E89D;font-weight:bold;--s-dark-font-weight:bold">\*</span><span class="μ6">|</span><span style="color:#22863A;--s-dark:#85E89D;font-weight:bold;--s-dark-font-weight:bold">\/</span><span class="μ5">/</span><span class="μ2">)</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><h4 id="最后">最后</h4>
<p>Earley parser 是一个自顶向下的算法，有一个与之类似的操作叫 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CYK_algorithm">CYK 算法</a> 是自下而上的。</p>]]></content>
        <author>
            <name>hyrious</name>
            <email>hyrious@outlook.com</email>
            <uri>https://hyrious.me</uri>
        </author>
    </entry>
</feed>