<!DOCTYPE html><html lang="zh-Hans-CN"><head><meta charset="UTF-8"><title>画一个 Sublime Merge 同款 Commit Graph</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><link rel="stylesheet" crossorigin href="/i/index-Bv3Y4ziu.css"></head><body class="post"><h2>画一个 Sublime Merge 同款 Commit Graph</h2><address>最后更新于 <time>2025-01-24</time></address><style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#d73a49}.μ2{color:#6f42c1}.μ3{color:#24292e}.μ4{color:#6a737d}.μ5{color:#e36209}.μ6{color:#005cc5}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#f97583}.μ2{color:#b392f0}.μ3{color:#e1e4e8}.μ4{color:#6a737d}.μ5{color:#ffab70}.μ6{color:#79b8ff}}</style><iframe src="/i/smerge-snapshot.html" width="100%" height="300px"></iframe><p>上面的 Git 记录来自这个真实的仓库：<a target="_blank" rel="noopener" href="https://github.com/opensumi/core">https://github.com/opensumi/core</a></p><p>我从起码 <a target="_blank" rel="noopener" href="https://github.com/desktop/desktop/issues/9452">5 年前</a> 就想画这玩意儿了，但一直缺少某些前置条件：a. 解析 Git Log 的东西和 b. 想明白这个图是怎么画的。前者我在 VS Code 的 <a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode/blob/c4c7c61/extensions/git/src/git.ts#L885">内置 Git 插件</a> 里抄到了，于是问题变成：</p><p>已知每个 Commit（看成列表里的元素）包含以下信息：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">interface</span><span class="μ2"> Commit</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">  // 当前 commit ID</span></span>
<span class="line"><span class="μ5">  hash</span><span class="μ1">:</span><span class="μ6"> string</span></span>
<span class="line"><span class="μ4">  // 上一个 commit 是谁，如果是 merge commit 会有两个 parent</span></span>
<span class="line"><span class="μ5">  parents</span><span class="μ1">:</span><span class="μ6"> string</span><span class="μ3">[]</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre><p>想办法用它（和它前后的 commit，如果需要的话）计算出绘制 Graph（也就是上面例子中左侧的图形）的必要信息。</p><p>考虑到现实场景中存在 <a target="_blank" rel="noopener" href="https://github.com/microsoft/vscode">几十万</a> 条 commits 的情况，显然 Sublime 不可能是离线（就是需要先获取到所有 commits 再计算结果）算的。因为 Sublime Merge 直接有最终效果供参考，可以通过<abbr title="找规律">瞪眼法</abbr>先盲猜一下每一行需要的信息是什么：</p><ul><li>有 N 列路径</li><li>对每条路径，往上看可能有 I（I &ge; 0）条输入路径</li><li>往下看类似，有 O（O &ge; 0）条输出路径</li><li>如果一条路消失了，它不会导致右侧的线向左移动，而是留下空位</li><li>如果出现新的端点，他会优先寻找空位，没有再往右添加</li></ul><p>再仔细看看，会发现：</p><ul><li>每一行只能出现一个「点」，代表当前 commit</li><li>只有这个点上会出现 merge（也就是多根线合并到一起的情况）</li><li>每列路径有一个东西是不变的：它总是在等待对的 parent commit 出现</li></ul><p>那么可以先这么定义一下中间状态：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ4">// 一开始会有一根预置的线表示正在等待 HEAD commit 出现</span></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> currentTracks </span><span class="μ1">=</span><span class="μ3"> [</span><span class="μ6">HEAD</span><span class="μ3">.hash]</span></span>
<span class="line"><span class="μ1">let</span><span class="μ2"> update</span><span class="μ1"> =</span><span class="μ3"> (</span><span class="μ5">commit</span><span class="μ3">) </span><span class="μ1">=></span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">  // 更新 currentTracks 并计算图</span></span>
<span class="line"><span class="μ3">}</span></span></code></pre><p>每次要处理某个 commit 时，对「上一次出来的线」计算「这一次他们变道到了哪一路」。什么情况下会变道呢？只有「出现了正在等待的 commit」时，这些线才会合并到第一根上，否则保持直线向下。</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">type</span><span class="μ2"> Track</span><span class="μ1"> =</span><span class="μ3"> { </span><span class="μ5">depth</span><span class="μ1">:</span><span class="μ6"> number</span><span class="μ3">; </span><span class="μ5">in</span><span class="μ1">:</span><span class="μ6"> number</span><span class="μ3">[]; </span><span class="μ5">out</span><span class="μ1">:</span><span class="μ6"> number</span><span class="μ3">[] }</span></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> nextTracks </span><span class="μ1">=</span><span class="μ3"> []</span></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> merged</span><span class="μ1">:</span><span class="μ2"> Track</span><span class="μ1"> |</span><span class="μ6"> undefined</span></span>
<span class="line"><span class="μ1">let</span><span class="μ3"> k </span><span class="μ1">=</span><span class="μ6"> 0</span><span class="μ4"> // 取 commit.parents 用</span></span>
<span class="line"><span class="μ1">for</span><span class="μ3"> (</span><span class="μ1">let</span><span class="μ3"> j </span><span class="μ1">=</span><span class="μ6"> 0</span><span class="μ3">; j </span><span class="μ1">&#x3C;</span><span class="μ3"> currentTracks.</span><span class="μ6">length</span><span class="μ3">; j</span><span class="μ1">++</span><span class="μ3">) {</span></span>
<span class="line"><span class="μ1">  let</span><span class="μ3"> parent </span><span class="μ1">=</span><span class="μ3"> currentTracks[j]</span></span>
<span class="line"><span class="μ1">  if</span><span class="μ3"> (parent) {</span></span>
<span class="line"><span class="μ1">    if</span><span class="μ3"> (parent </span><span class="μ1">===</span><span class="μ3"> commit.hash) {</span></span>
<span class="line"><span class="μ1">      if</span><span class="μ3"> (</span><span class="μ1">!</span><span class="μ3">merged) {</span></span>
<span class="line"><span class="μ4">        // 出现了，直接合并</span></span>
<span class="line"><span class="μ3">        nextTracks[j] </span><span class="μ1">=</span><span class="μ3"> commit.parents[k</span><span class="μ1">++</span><span class="μ3">] </span><span class="μ4">// 这根线接下来要找另一个 parent 了</span></span>
<span class="line"><span class="μ3">        merged </span><span class="μ1">=</span><span class="μ3"> { depth: j, in: [j], out: nextTracks[j] </span><span class="μ1">?</span><span class="μ3"> [j] </span><span class="μ1">:</span><span class="μ3"> [] }</span></span>
<span class="line"><span class="μ3">      } </span><span class="μ1">else</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">        // 合并到第一根上，所以下一次没有这根线了</span></span>
<span class="line"><span class="μ3">        nextTracks[j] </span><span class="μ1">=</span><span class="μ6"> null</span></span>
<span class="line"><span class="μ3">        merged.in.</span><span class="μ2">push</span><span class="μ3">(j)</span></span>
<span class="line"><span class="μ3">      }</span></span>
<span class="line"><span class="μ3">    } </span><span class="μ1">else</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">      // 无关的线继续向下</span></span>
<span class="line"><span class="μ3">      nextTracks[j] </span><span class="μ1">=</span><span class="μ3"> parent</span></span>
<span class="line"><span class="μ3">    }</span></span>
<span class="line"><span class="μ3">  } </span><span class="μ1">else</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">    // 空的还是空的</span></span>
<span class="line"><span class="μ3">    nextTracks[j] </span><span class="μ1">=</span><span class="μ6"> null</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"><span class="μ4">// 此时没被 merge 的 parents 要么往左合并，要么往右分叉</span></span>
<span class="line"><span class="μ1">while</span><span class="μ3"> (commit.parents[k]) {</span></span>
<span class="line"><span class="μ1">  let</span><span class="μ3"> exist </span><span class="μ1">=</span><span class="μ3"> currentTracks.</span><span class="μ2">indexOf</span><span class="μ3">(commit.parents[k])</span></span>
<span class="line"><span class="μ1">  if</span><span class="μ3"> (exist) {</span></span>
<span class="line"><span class="μ4">    // 已经往左合并了</span></span>
<span class="line"><span class="μ3">    merged?.out.</span><span class="μ2">push</span><span class="μ3">(exist)</span></span>
<span class="line"><span class="μ3">    nextTracks[exist] </span><span class="μ1">=</span><span class="μ3"> commit.parents[k</span><span class="μ1">++</span><span class="μ3">]</span></span>
<span class="line"><span class="μ3">  } </span><span class="μ1">else</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">    // 分叉，往右找到第一个空位</span></span>
<span class="line"><span class="μ1">    let</span><span class="μ3"> index </span><span class="μ1">=</span><span class="μ3"> nextTracks.</span><span class="μ2">indexOf</span><span class="μ3">(</span><span class="μ6">null</span><span class="μ3">)</span></span>
<span class="line"><span class="μ1">    if</span><span class="μ3"> (index </span><span class="μ1">&#x3C;</span><span class="μ6"> 0</span><span class="μ3">) index </span><span class="μ1">=</span><span class="μ3"> nextTracks.</span><span class="μ6">length</span></span>
<span class="line"><span class="μ3">    nextTracks[index] </span><span class="μ1">=</span><span class="μ3"> commit.parents[k</span><span class="μ1">++</span><span class="μ3">]</span></span>
<span class="line"><span class="μ1">    if</span><span class="μ3"> (merged) {</span></span>
<span class="line"><span class="μ4">      // 添加到当前 merge commit 的输出里</span></span>
<span class="line"><span class="μ3">      merged.out.</span><span class="μ2">push</span><span class="μ3">(index)</span></span>
<span class="line"><span class="μ3">    } </span><span class="μ1">else</span><span class="μ3"> {</span></span>
<span class="line"><span class="μ4">      // 如果没有 merge commit，那么新的 parent 自动形成一路</span></span>
<span class="line"><span class="μ3">      merged </span><span class="μ1">=</span><span class="μ3"> { depth: index, in: [], out: [index] }</span></span>
<span class="line"><span class="μ3">    }</span></span>
<span class="line"><span class="μ3">  }</span></span>
<span class="line"><span class="μ3">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ3">currentTracks </span><span class="μ1">=</span><span class="μ3"> nextTracks</span></span></code></pre><p>上述实现已经在 <a target="_blank" rel="noopener" href="https://github.com/hyrious/git-tm">https://github.com/hyrious/git-tm</a> 里使用了，感兴趣可以用用。</p><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2025 @ hyrious</p></footer></body></html>