<!DOCTYPE html><html lang="zh-Hans-CN"><head><meta charset="UTF-8"><title>Sublime Text 插件踩坑</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><link rel="stylesheet" crossorigin href="/i/index-wzb4-GSb.css"></head><body class="post"><h2>Sublime Text 插件踩坑</h2><address>最后更新于 <time>2022-02-06</time></address><style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6a737d}.μ2{color:#d73a49}.μ3{color:#6f42c1}.μ4{color:#24292e}.μ5{color:#e36209}.μ6{color:#032f62}.μ7{color:#005cc5}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#6a737d}.μ2{color:#f97583}.μ3{color:#b392f0}.μ4{color:#e1e4e8}.μ5{color:#ffab70}.μ6{color:#9ecbff}.μ7{color:#79b8ff}}</style><p>春节花了几天写了一个 <a target="_blank" rel="noopener" href="https://github.com/hyrious/prettierd">Sublime Text 插件</a>，这里大概记录一下关于它（主要是 python 部分）的小知识。</p><h3 id="sublimeset_timeout-和-sublimeset_timeout_async"><samp>sublime.set_timeout()</samp> 和 <samp>sublime.set_timeout_async()</samp></h3><p>文档上说 <q><samp>_async</samp></q> 会放在另一个线程里执行，听着似乎等于 <samp>threading<wbr>.Thread()<wbr>.start()</samp>？其实不然！这里文档没有明说的是，sublime 一共只有两个线程 —— 主渲染线程和 worker 线程。<q><samp>_async</samp></q> 的意思是把一个函数放到 worker 线程里跑 —— worker 线程里的任务还是会互相阻塞。所以一旦我们需要实现一些长时间阻塞的任务（如 <samp>process<wbr>.stdout<wbr>.readline()</samp>，假设你要做一个使用 tsserver 的插件<span class="half-shrink-right">）</span>，最好还是自己拿 Thread 搞事。</p><p>只有那些短时间且符合用户操作目的的单任务（例如格式化一下文本，当用户按下快捷键时，他期望编辑器做一些工作，但是又不希望整个程序像卡死了一样）适合在 worker 线程工作。</p><h3 id="async-await-py37"><samp>async await</samp> <span class="half-shrink-left">（</span>py3.7+）</h3><p>Sublime Text 4 提供了 python3.8 给新的插件，这意味着你可以写 <code>if a := 1</code> 和 <code>async def</code> 了。说到 <code>async</code> 我就不困了，我立马搬出《<a target="_blank" rel="noopener" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">函数染色问题</a>》。另外，在 sublime 里你总不能让一个 async 函数占着主线程，所以有了下面这段代码：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1"># Run a callback (-> coroutine) in a new `threading.Thread()`. Refer to</span></span>
<span class="line"><span class="μ1"># https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058</span></span>
<span class="line"><span class="μ2">def</span><span class="μ3"> run_in_new_thread</span><span class="μ4">(function, </span><span class="μ2">*</span><span class="μ4">args, </span><span class="μ2">**</span><span class="μ4">kwargs):</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # The "loop" holder.</span></span>
<span class="line"><span class="μ4">    loop </span><span class="μ2">=</span><span class="μ4"> asyncio.new_event_loop()</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # Kick start the event loop.</span></span>
<span class="line"><span class="μ2">    def</span><span class="μ3"> wrapper</span><span class="μ4">(loop):</span></span>
<span class="line"><span class="μ4">        asyncio.set_event_loop(loop)</span></span>
<span class="line"><span class="μ4">        loop.run_forever() </span><span class="μ1"># &#x3C;- block current thread, until "loop.stop()"</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # Send wrapper to a new thread with the loop.</span></span>
<span class="line"><span class="μ4">    t </span><span class="μ2">=</span><span class="μ4"> threading.Thread(</span><span class="μ5">target</span><span class="μ2">=</span><span class="μ4">wrapper, </span><span class="μ5">args</span><span class="μ2">=</span><span class="μ4">(loop,))</span></span>
<span class="line"><span class="μ4">    t.start()</span></span>
<span class="line"></span>
<span class="line"><span class="μ1">    # Run the callback with the loop.</span></span>
<span class="line"><span class="μ4">    coro </span><span class="μ2">=</span><span class="μ4"> function(</span><span class="μ2">*</span><span class="μ4">args, </span><span class="μ2">**</span><span class="μ4">kwargs)</span></span>
<span class="line"><span class="μ4">    future </span><span class="μ2">=</span><span class="μ4"> asyncio.run_coroutine_threadsafe(coro, loop)</span></span>
<span class="line"><span class="μ1">    # `await future` to wait for it.</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">    return</span><span class="μ4"> future</span></span></code></pre><p>虽然他是 thread-safe 的，不过手操 thread 还是让我有点不爽。而且这抽象泄露也太严重了，直接给你一个 <samp>loop</samp> <span class="half-shrink-left">（</span>约等于 generator 函数给你的那个对象<span class="half-shrink-right">）</span>。</p><h3 id="subprocesspopen-和僵尸进程"><samp>subprocess.Popen</samp> 和僵尸进程</h3><p>你可以在任何 python 环境下（包括 REPL）试试这段代码：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">import</span><span class="μ4"> subprocess</span></span>
<span class="line"><span class="μ1"># 启动一个子进程，只要能一直跑随便用啥都行</span></span>
<span class="line"><span class="μ4">p </span><span class="μ2">=</span><span class="μ4"> subprocess.Popen([</span><span class="μ6">'ruby'</span><span class="μ4">, </span><span class="μ6">'-e'</span><span class="μ4">, </span><span class="μ6">'sleep 9999'</span><span class="μ4">])</span></span>
<span class="line"><span class="μ7">exit</span><span class="μ4">()</span></span></code></pre><p>你的 python 退出了，但是子进程还在跑！<span class="half-shrink-left">（</span>也就是所谓的僵尸进程<span class="half-shrink-right">）</span>。我以为是缺什么参数，结果他压根没有实现自动退出子进程的功能（隔壁 ruby、nodejs 可是默认行为，导致我都不知道还能这样<span class="half-shrink-right">）</span>。没有力量，所以只能找到 sublime 有个 <samp>on_exit</samp> 监听器，要在那里退出子进程。</p><h3 id="异步触发修改">异步触发修改</h3><p>出于操作的同步性考虑，插件必须在一次 <samp>TextCommand</samp> 回调里同步地完成对 view 的修改。一旦这个回调执行的同步代码太多，编辑器就会卡住，体验很不好。那么如何实现异步的修改呢？这里有一个小技巧，就是在异步任务结束的时候再触发一遍 <samp>TextCommand</samp> 并且把必要的参数传进去。一旦有新的用户操作会打断这次异步任务的，就加个标记不去触发即可。</p><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2023 @ hyrious</p></footer></body></html>