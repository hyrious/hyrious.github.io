<!DOCTYPE html><html lang="zh-Hans-CN" data-critters-container><head><meta charset="UTF-8"><title>Sublime Text 插件踩坑</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><style>*,:after,:before{box-sizing:border-box;background-repeat:no-repeat}:after,:before{text-decoration:inherit;vertical-align:inherit}:where(body){margin:0}:where(pre){font-family:monospace,monospace;font-size:1em;overflow:auto}:where(code,kbd,samp){font-family:monospace,monospace;font-size:1em}:root{--title-color:#0d1117;--link-color:#0057ab;--link-bg-color:#deefff;--text-color:rgba(0, 0, 0, .8);--bg-color:#fff;--gray-color:#79828b;--pre-color:rgba(0, 0, 0, .05)}@media (prefers-color-scheme:dark){:root{--title-color:#dddddc;--link-color:#79c0ff;--link-bg-color:#263441;--text-color:rgba(255, 255, 255, .8);--bg-color:#0d1117;--gray-color:#747d86;--pre-color:rgba(255, 255, 255, .05)}}html{font-family:Chinese Quotes,Inter var,Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Ubuntu,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}code,pre,samp{font-family:ui-monospace,Cascadia Mono,Consolas,Roboto Mono,"Ubuntu Monospace",Noto Mono,monospace,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-size:90%}body{margin:auto;padding:2ch;max-width:70ch;color:var(--text-color,#000);background-color:var(--bg-color,#fff);line-height:1.58;font-synthesis:style}@property --offset{syntax:"<length>";inherits:false;initial-value:0}a{color:var(--link-color,#000);text-decoration:underline solid;text-decoration-color:transparent;text-decoration-thickness:2px;text-underline-offset:var(--offset,.1em);transition:text-decoration-color .2s,--offset .2s;box-shadow:0 -.7em var(--link-bg-color,#deefff) inset}a:hover{cursor:pointer}a:focus,a:hover{text-decoration-color:var(--link-color,#000);--offset:.2em}@supports not (background:paint(something)){a{transition:text-decoration-color .2s,text-underline-offset .2s}a:focus,a:hover{text-underline-offset:.2em}}h2{font-weight:700;font-size:28px;line-height:34px;margin:21px 0 12px;color:var(--title-color,#000)}h3{font-weight:700;font-size:22px;line-height:24px;margin:2rem 0 1rem;color:var(--title-color,#000)}h2,h3{text-wrap:balance}footer{padding:2ch 0;color:var(--gray-color);position:sticky;top:100vh;font-variant-numeric:tabular-nums}address{font-style:normal;font-size:15px;line-height:18px;color:var(--gray-color,#79828b);margin-bottom:14px;font-variant-numeric:tabular-nums}p{margin:0 0 9px;line-height:1.75}.shiki{font-family:DM Mono,Input Mono,Fira Code,monospace;font-size:.92em;line-height:1.4;margin:.5em 0;padding:1ch 16px;border-radius:6px;background-color:var(--pre-color)!important}.shiki>code{display:block;padding:0}@media (prefers-color-scheme:dark){.shiki,.shiki span{color:var(--s-dark)!important}}p>code{padding:2px 4px;background-color:var(--pre-color)}.half-shrink-left{margin-left:-.5em}footer a{color:inherit}footer a{box-shadow:unset}footer a:focus,footer a:hover{text-decoration-color:inherit}</style><link rel="preload" crossorigin href="/assets/index-vWxNvpCb.css" as="style"></head><body class="post"><h2>Sublime Text 插件踩坑</h2><address>最后更新于 <time>2022-02-06</time></address><p>春节花了几天写了一个 <a target="_blank" rel="noopener" href="https://github.com/hyrious/prettierd">Sublime Text 插件</a>，这里大概记录一下关于它（主要是 python 部分）的小知识。</p><h3 id="sublimeset_timeout-和-sublimeset_timeout_async"><samp>sublime.set_timeout()</samp> 和 <samp>sublime.set_timeout_async()</samp></h3><p>文档上说 <q><samp>_async</samp></q> 会放在另一个线程里执行，听着似乎等于 <samp>threading<wbr>.Thread()<wbr>.start()</samp>？其实不然！这里文档没有明说的是，sublime 一共只有两个线程 —— 主渲染线程和 worker 线程。<q><samp>_async</samp></q> 的意思是把一个函数放到 worker 线程里跑 —— worker 线程里的任务还是会互相阻塞。所以一旦我们需要实现一些长时间阻塞的任务（如 <samp>process<wbr>.stdout<wbr>.readline()</samp>，假设你要做一个使用 tsserver 的插件<span class="half-shrink-right">）</span>，最好还是自己拿 Thread 搞事。</p><p>只有那些短时间且符合用户操作目的的单任务（例如格式化一下文本，当用户按下快捷键时，他期望编辑器做一些工作，但是又不希望整个程序像卡死了一样）适合在 worker 线程工作。</p><h3 id="async-await-py37"><samp>async await</samp> <span class="half-shrink-left">（</span>py3.7+）</h3><p>Sublime Text 4 提供了 python3.8 给新的插件，这意味着你可以写 <code>if a := 1</code> 和 <code>async def</code> 了。说到 <code>async</code> 我就不困了，我立马搬出《<a target="_blank" rel="noopener" href="https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/">函数染色问题</a>》。另外，在 sublime 里你总不能让一个 async 函数占着主线程，所以有了下面这段代码：</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#6a737d;--s-dark:#6A737D"># Run a callback (-> coroutine) in a new `threading.Thread()`. Refer to</span></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D"># https://gist.github.com/dmfigol/3e7d5b84a16d076df02baa9f53271058</span></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">def</span><span style="color:#6f42c1;--s-dark:#B392F0"> run_in_new_thread</span><span style="color:#24292e;--s-dark:#E1E4E8">(function, </span><span style="color:#d73a49;--s-dark:#F97583">*</span><span style="color:#24292e;--s-dark:#E1E4E8">args, </span><span style="color:#d73a49;--s-dark:#F97583">**</span><span style="color:#24292e;--s-dark:#E1E4E8">kwargs):</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">    # The "loop" holder.</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">    loop </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8"> asyncio.new_event_loop()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">    # Kick start the event loop.</span></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">    def</span><span style="color:#6f42c1;--s-dark:#B392F0"> wrapper</span><span style="color:#24292e;--s-dark:#E1E4E8">(loop):</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">        asyncio.set_event_loop(loop)</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">        loop.run_forever() </span><span style="color:#6a737d;--s-dark:#6A737D"># &#x3C;- block current thread, until "loop.stop()"</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">    # Send wrapper to a new thread with the loop.</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">    t </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8"> threading.Thread(</span><span style="color:#e36209;--s-dark:#FFAB70">target</span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8">wrapper, </span><span style="color:#e36209;--s-dark:#FFAB70">args</span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8">(loop,))</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">    t.start()</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">    # Run the callback with the loop.</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">    coro </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8"> function(</span><span style="color:#d73a49;--s-dark:#F97583">*</span><span style="color:#24292e;--s-dark:#E1E4E8">args, </span><span style="color:#d73a49;--s-dark:#F97583">**</span><span style="color:#24292e;--s-dark:#E1E4E8">kwargs)</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">    future </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8"> asyncio.run_coroutine_threadsafe(coro, loop)</span></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">    # `await future` to wait for it.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">    return</span><span style="color:#24292e;--s-dark:#E1E4E8"> future</span></span></code></pre><p>虽然他是 thread-safe 的，不过手操 thread 还是让我有点不爽。而且这抽象泄露也太严重了，直接给你一个 <samp>loop</samp> <span class="half-shrink-left">（</span>约等于 generator 函数给你的那个对象<span class="half-shrink-right">）</span>。</p><h3 id="subprocesspopen-和僵尸进程"><samp>subprocess.Popen</samp> 和僵尸进程</h3><p>你可以在任何 python 环境下（包括 REPL）试试这段代码：</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#d73a49;--s-dark:#F97583">import</span><span style="color:#24292e;--s-dark:#E1E4E8"> subprocess</span></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D"># 启动一个子进程，只要能一直跑随便用啥都行</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">p </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8"> subprocess.Popen([</span><span style="color:#032f62;--s-dark:#9ECBFF">'ruby'</span><span style="color:#24292e;--s-dark:#E1E4E8">, </span><span style="color:#032f62;--s-dark:#9ECBFF">'-e'</span><span style="color:#24292e;--s-dark:#E1E4E8">, </span><span style="color:#032f62;--s-dark:#9ECBFF">'sleep 9999'</span><span style="color:#24292e;--s-dark:#E1E4E8">])</span></span>
<span class="line"><span style="color:#005cc5;--s-dark:#79B8FF">exit</span><span style="color:#24292e;--s-dark:#E1E4E8">()</span></span></code></pre><p>你的 python 退出了，但是子进程还在跑！<span class="half-shrink-left">（</span>也就是所谓的僵尸进程<span class="half-shrink-right">）</span>。我以为是缺什么参数，结果他压根没有实现自动退出子进程的功能（隔壁 ruby、nodejs 可是默认行为，导致我都不知道还能这样<span class="half-shrink-right">）</span>。没有力量，所以只能找到 sublime 有个 <samp>on_exit</samp> 监听器，要在那里退出子进程。</p><h3 id="异步触发修改">异步触发修改</h3><p>出于操作的同步性考虑，插件必须在一次 <samp>TextCommand</samp> 回调里同步地完成对 view 的修改。一旦这个回调执行的同步代码太多，编辑器就会卡住，体验很不好。那么如何实现异步的修改呢？这里有一个小技巧，就是在异步任务结束的时候再触发一遍 <samp>TextCommand</samp> 并且把必要的参数传进去。一旦有新的用户操作会打断这次异步任务的，就加个标记不去触发即可。</p><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2023 @ hyrious</p></footer><link rel="stylesheet" href="/assets/index-vWxNvpCb.css"></body></html>