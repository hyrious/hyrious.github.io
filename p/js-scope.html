<!DOCTYPE html><html lang="zh-Hans-CN"><head><meta charset="UTF-8"><title>JS 作用域碎碎念</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><link rel="stylesheet" crossorigin href="/i/index-Bu9etoZy.css"></head><body class="post"><h2>JS 作用域碎碎念</h2><address>最后更新于 <time>2023-01-17</time></address><style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#d73a49}.μ2{color:#24292e}.μ3{color:#005cc5}.μ4{color:#6f42c1}.μ5{color:#6a737d}.μ6{color:#e36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#f97583}.μ2{color:#e1e4e8}.μ3{color:#79b8ff}.μ4{color:#b392f0}.μ5{color:#6a737d}.μ6{color:#ffab70}}</style><p>JS 里存在两类<q>块</q>，一种是 block <code>{}</code>，另一种是 function body <code>(){}</code>（包括 method），这两种块对不同的变量声明会有不同的作用域效果，下面就来看看。</p><h4 id="var"><code>var</code></h4><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">false</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  var</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(a) </span><span class="μ5">// undefined</span></span></code></pre><p><code>var</code> 是一种历史悠久的变量，他不认识 block <code>{}</code>，会直接提升到第一个 function body 区，即使是 Dead-code 也不例外。</p><h4 id="let-const"><code>let</code>, <code>const</code></h4><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">true</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  const</span><span class="μ3"> a</span><span class="μ1"> =</span><span class="μ3"> 2</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(a) </span><span class="μ5">// 1</span></span></code></pre><p><code>let</code> 和 <code>const</code> 严格存在于当前 block 内，不会发生任何变量提升。</p><h4 id="function"><code>function</code></h4><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">false</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  function</span><span class="μ4"> foo</span><span class="μ2">() {}</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(foo) </span><span class="μ5">// undefined</span></span></code></pre><p><code>function</code> 也是一种定义变量的方式，他和 <code>var</code> 一样悠久，提升规则和 <code>var</code> 几乎一样，但有两点不同：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">const</span><span class="μ3"> a</span><span class="μ1"> =</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">false</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  var</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 2</span><span class="μ5"> // SyntaxError: Identifier 'a' has already been declared</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">const</span><span class="μ3"> foo</span><span class="μ1"> =</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">true</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  function</span><span class="μ4"> foo</span><span class="μ2">() {}</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(foo) </span><span class="μ5">// 1</span></span></code></pre><ol><li><code>var</code> 会不择手段地提升，碰到 <code>const</code>, <code>let</code> 之类硬茬就会爆炸；而 <code>function</code> 则温和很多。</li></ol><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(a, </span><span class="μ4">foo</span><span class="μ2">()) </span><span class="μ5">// undefined, 2</span></span>
<span class="line"><span class="μ1">var</span><span class="μ2"> a </span><span class="μ1">=</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">function</span><span class="μ4"> foo</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ3"> 2</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><ol start="2"><li>和 <code>var</code> 只送一个 <code>undefined</code> 不同，<code>function</code> 会连着定义一起送出去，我们可以 <em>看起来</em> 在定义之前就使用他。实际上，可以认为 <code>function</code> 连着内容一起被提升到了当前函数块的顶部执行。</li></ol><p>另外，当整个 <code>function</code> 作为表达式而不是语句存在时，其名称只会被限定在函数体内可以访问：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">$button.</span><span class="μ4">onclick</span><span class="μ1"> =</span><span class="μ1"> function</span><span class="μ4"> hello</span><span class="μ2">() {</span></span>
<span class="line"><span class="μ2">  console.</span><span class="μ4">log</span><span class="μ2">(hello.name) </span><span class="μ5">// 'hello'</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(hello) </span><span class="μ5">// ReferenceError: hello is not defined</span></span></code></pre><h4 id="class"><code>class</code></h4><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">const</span><span class="μ3"> A</span><span class="μ1"> =</span><span class="μ3"> 1</span></span>
<span class="line"><span class="μ1">if</span><span class="μ2"> (</span><span class="μ3">true</span><span class="μ2">) {</span></span>
<span class="line"><span class="μ1">  class</span><span class="μ4"> A</span><span class="μ2"> {}</span></span>
<span class="line"><span class="μ3">  A</span><span class="μ1"> =</span><span class="μ3"> 2</span></span>
<span class="line"><span class="μ2">}</span></span>
<span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(</span><span class="μ3">A</span><span class="μ2">) </span><span class="μ5">// 1</span></span></code></pre><p><code>class</code> 创造的变量约等于 <code>let</code>，不过需要注意的是，在 <code>class</code> 的静态表达式中是可以直接访问到其类名的，而 <code>let</code> 需要先执行完 <code>class</code>，反而不能这么使用：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ4"> A</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> a</span><span class="μ1"> =</span><span class="μ3"> A</span><span class="μ2">.name </span><span class="μ5">// 'A'</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> b</span><span class="μ1"> =</span><span class="μ3"> this</span><span class="μ2">.name </span><span class="μ5">// can also use `this`</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">let</span><span class="μ3"> A</span><span class="μ1"> =</span><span class="μ1"> class</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> a</span><span class="μ1"> =</span><span class="μ3"> A</span><span class="μ2">.name </span><span class="μ5">// ReferenceError: A is not defined</span></span>
<span class="line"><span class="μ1">  static</span><span class="μ6"> b</span><span class="μ1"> =</span><span class="μ3"> this</span><span class="μ2">.name </span><span class="μ5">// 'A'</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><p>注意到最后一个例子，<code>A.b</code> 可以拿到 <code>&#39;A&#39;</code>，这是因为匿名类会被自动赋予左边的变量名。当左边不是一个变量的时候该类的名字就是空了：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">console.</span><span class="μ4">log</span><span class="μ2">(</span></span>
<span class="line"><span class="μ1">  class</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ1">    static</span><span class="μ6"> b</span><span class="μ1"> =</span><span class="μ3"> this</span><span class="μ2">.name</span></span>
<span class="line"><span class="μ2">  }.b,</span></span>
<span class="line"><span class="μ2">) </span><span class="μ5">// ''</span></span></code></pre><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2025 @ hyrious</p></footer></body></html>