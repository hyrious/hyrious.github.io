<!DOCTYPE html><html lang="zh-Hans-CN"><head><meta charset="UTF-8"><title>魔改之道 · 以 RPG Maker MZ 为例</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><link rel="stylesheet" crossorigin href="/i/index-Bu9etoZy.css"></head><body class="post"><h2>魔改之道 · 以 RPG Maker MZ 为例</h2><address>最后更新于 <time>2025-04-16</time></address><style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#6f42c1}.μ2{color:#032f62}.μ3{color:#005cc5}.μ4{color:#6a737d}.μ5{color:#d73a49}.μ6{color:#24292e}.μ7{color:#e36209}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#b392f0}.μ2{color:#9ecbff}.μ3{color:#79b8ff}.μ4{color:#6a737d}.μ5{color:#f97583}.μ6{color:#e1e4e8}.μ7{color:#ffab70}}</style><p>经常 fork 的朋友都知道，魔改一时爽 rebase 火葬场。本文将介绍一种可持续性魔改办法，让你在面对<abbr title="原版">上游</abbr>不停的改动下仍然泰然自若，及时更新。</p><p>为什么用 RPG Maker 呢，因为这个软件会更新项目的引擎部分，你可以看一下它上一代 <a target="_blank" rel="noopener" href="https://github.com/rpgtkoolmv/corescript">RMMV 的这部分文件</a><small>（因为某些原因开源了，但 RMMZ 的这部分其实是不开源的）</small>。所谓更新其实就是直接把相关文件都覆盖掉，所以如果你对这部分代码有任何改动都会丢失。</p><p>RPG Maker 鼓励用户使用 patch 方式扩展游戏功能，这样就可以不动到引擎代码，从而规避上述问题。但现实情况是有时你需要往某个函数的<q>中间</q>插入一段代码，如果继续使用 patch 方式就会需要严格控制插件加载顺序，其实反而是增加了维护难度。</p><h3 id="git-is-all-you-need">Git is All You Need</h3><p>为了避免改动丢失，可以使用 Git 管理游戏仓库的代码部分。不过考虑到 RMMZ 的引擎并不通过 Git 下发更新，可以先把它这部分做成一个公共分支，里面只放引擎代码：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">$</span><span class="μ2"> cd</span><span class="μ2"> Project1</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> init</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> add</span><span class="μ2"> .</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> commit</span><span class="μ3"> -m</span><span class="μ3"> 1.9.0</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> tag</span><span class="μ3"> 1.9.0</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> branch</span><span class="μ2"> corescript</span><span class="μ4">  # 基于当前位置创建一个分支只用于管理核心代码</span></span></code></pre><p>然后在 <code>main</code> 分支正常开发游戏，可以直接对核心代码进行改动。当出现新的上游更新比如 <code>1.9.1</code> 时，可以从 <code>corescript</code> 分支计算出 diff 并应用到 <code>main</code> 上：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> switch</span><span class="μ2"> corescript</span></span>
<span class="line"><span class="μ4"># 打开 RMMZ，点击更新核心代码</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> add</span><span class="μ2"> .</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> commit</span><span class="μ3"> -m</span><span class="μ3"> 1.9.1</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> tag</span><span class="μ3"> 1.9.1</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> switch</span><span class="μ2"> main</span></span>
<span class="line"><span class="μ1">$</span><span class="μ2"> git</span><span class="μ2"> diff</span><span class="μ3"> 1.9.0</span><span class="μ3"> 1.9.1</span><span class="μ5"> |</span><span class="μ1"> git</span><span class="μ2"> apply</span><span class="μ4">  # 应用 1.9.0..1.9.1 的修改到本地代码</span></span></code></pre><p>应用 diff 过程中可能会产生少量冲突，手动解决即可。</p><h3 id="可持续性魔改">可持续性魔改</h3><p>有的时候，上游发生了大的重构或者删掉了包含你的修改的部分文件，apply 过程中因为不是冲突可能你不会注意到这点。这里就需要一点工程学技巧来维护了，例如，可以在自己的代码周围增加特殊标记：</p><pre class="shiki shiki-themes github-light github-dark has-diff μ0" tabindex="0"><code><span class="line"><span class="μ3">Game_Actor</span><span class="μ6">.</span><span class="μ3">prototype</span><span class="μ6">.</span><span class="μ1">someCoreFunction</span><span class="μ5"> =</span><span class="μ5"> function</span><span class="μ6">() {</span></span>
<span class="line"><span class="μ4">  // ... existing code ...</span></span>
<span class="line diff add"><span class="μ4">  // --- Start Patch ---</span></span>
<span class="line diff add"><span class="μ1">  customLogicHere</span><span class="μ6">();     </span></span>
<span class="line diff add"><span class="μ4">  // --- End Patch ---</span></span>
<span class="line"><span class="μ4">  // ... existing code ...</span></span>
<span class="line"><span class="μ6">}</span></span></code></pre><p>然后可以写一个小脚本检测 apply 前后每个文件的 patch 数量变化，来确定是否有 patch 丢失，这里就不贴多余代码了。</p><h3 id="解耦模式">解耦模式</h3><p>通常情况下我们希望避免对原代码做过多的魔改，那样不仅会导致 rebase 困难，而且也不利于其他人类阅读和维护。<a target="_blank" rel="noopener" href="https://gpp.tkchu.me/decoupling-patterns.html">《游戏设计模式》</a>中说：</p><blockquote><p>当我们说两块代码<q>解耦</q>时，是指修改一块代码一般不会需要修改另一块代码。 当我们修改游戏中的特性时，需要修改的代码越少，就越容易。</p></blockquote><p>下面我们就来看看最常见的解耦模式<q>依赖注入</q>的一个特化形式：服务定位器。</p><p>简单来说，我们可以假设（或者大部分编程语言中真的存在）一个<strong>全局</strong>的东西，任何地方的代码都可以访问到并和这个全局做一些操作，比如保存一些变量或者发送一些事件。</p><p>例如，我们希望在游戏中获得物品时弹出一个提醒，可以想到在获得物品的函数里通知其他地方的代码：</p><pre class="shiki shiki-themes github-light github-dark has-diff μ0" tabindex="0"><code><span class="line"><span class="μ3">Game_Party</span><span class="μ6">.</span><span class="μ3">prototype</span><span class="μ6">.</span><span class="μ1">gainItem</span><span class="μ5"> =</span><span class="μ5"> function</span><span class="μ6">(</span><span class="μ7">item</span><span class="μ6">, </span><span class="μ7">amount</span><span class="μ6">, </span><span class="μ7">includeEquip</span><span class="μ6">) {</span></span>
<span class="line diff add"><span class="μ6">  $game._onGainItem.</span><span class="μ1">fire</span><span class="μ6">({ item, amount, includeEquip }) </span></span>
<span class="line"><span class="μ4">  // ... existing code ...</span></span>
<span class="line"><span class="μ6">}</span></span>
<span class="line"></span>
<span class="line diff add"><span class="μ4">// 某个十万八千里外的代码:</span></span>
<span class="line diff add"><span class="μ6">$game.</span><span class="μ1">onGainItem</span><span class="μ6">(</span><span class="μ7">e</span><span class="μ5"> =></span><span class="μ6"> {              </span></span>
<span class="line diff add"><span class="μ1">  showNotification</span><span class="μ6">(e.item, e.amount) </span></span>
<span class="line diff add"><span class="μ6">})                                   </span></span></code></pre><p>游戏中有一些经常 patch 的区域，比如 <code>Game_Character#update</code>，可以重写成：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ3">Game_Character</span><span class="μ6">.</span><span class="μ3">prototype</span><span class="μ6">.</span><span class="μ1">update</span><span class="μ5"> =</span><span class="μ5"> function</span><span class="μ6">() {</span></span>
<span class="line"><span class="μ6">  $game._onWillCharacterUpdate.</span><span class="μ1">fire</span><span class="μ6">();</span></span>
<span class="line"><span class="μ3">  Game_CharacterBase</span><span class="μ6">.</span><span class="μ3">prototype</span><span class="μ6">.update.</span><span class="μ1">call</span><span class="μ6">(</span><span class="μ3">this</span><span class="μ6">);</span></span>
<span class="line"><span class="μ6">  $game._onDidCharacterUpdate.</span><span class="μ1">fire</span><span class="μ6">();</span></span>
<span class="line"><span class="μ6">};</span></span>
<span class="line"><span class="μ4">// 下略</span></span></code></pre><p>游戏中可能会对战斗系统做深度定制，比如在计算伤害时，会有多种奇形怪状的技能和状态参与进来，如果把它们都硬编码在一个文件里不免看着头大，可以重写成：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ6">$game.battle.</span><span class="μ1">registerActionEffect</span><span class="μ6">(</span><span class="μ5">new</span><span class="μ5"> class</span><span class="μ5"> extends</span><span class="μ1"> Game_ActionEffect</span><span class="μ6"> {</span></span>
<span class="line"><span class="μ5">  async</span><span class="μ1"> run</span><span class="μ6">(</span><span class="μ7">target</span><span class="μ5">:</span><span class="μ1"> Game_Battler</span><span class="μ6">) {</span></span>
<span class="line"><span class="μ4">    // 假设效果为启动一个别的效果</span></span>
<span class="line"><span class="μ5">    const</span><span class="μ3"> action</span><span class="μ5"> =</span><span class="μ5"> new</span><span class="μ1"> Game_Action</span><span class="μ6">(battler).</span><span class="μ1">setSkill</span><span class="μ6">(skillId);</span></span>
<span class="line"><span class="μ6">    $game.battle.</span><span class="μ1">scheduleAction</span><span class="μ6">(target, action);</span></span>
<span class="line"><span class="μ6">  }</span></span>
<span class="line"><span class="μ6">});</span></span></code></pre><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2025 @ hyrious</p></footer></body></html>