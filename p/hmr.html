<!DOCTYPE html><html lang="zh-Hans-CN"><head><meta charset="UTF-8"><title>热更新是怎么工作的</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><link rel="stylesheet" crossorigin href="/i/index-qDCUwxeJ.css"></head><body class="post"><h2>热更新是怎么工作的</h2><address>最后更新于 <time>2022-02-19</time></address><style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#d73a49}.μ2{color:#24292e}.μ3{color:#6f42c1}.μ4{color:#005cc5}.μ5{color:#6a737d}.μ6{color:#032f62}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#f97583}.μ2{color:#e1e4e8}.μ3{color:#b392f0}.μ4{color:#79b8ff}.μ5{color:#6a737d}.μ6{color:#9ecbff}}</style><p>注：并非指线上软件不重启更新，而是指开发阶段能够获得更好的开发体验。</p><hr><p>几年前我玩 RPG Maker 的时候也想过这个问题，每次修改过脚本后都要重新启动游戏才能测试效果，有没有什么办法可以不重启呢？</p><p>简单地想，如果直接重新执行被修改的那一页脚本，那么只需要他能保证执行后是想要的效果就行了。由于大部分脚本插件都是<q>插件</q>式的，他们通常是使用 <code>alias</code> 修改一些个默认系统里的方法以及定义一些新模块，由于 Ruby 有<q>打开类</q>的元编程特性，所以重新执行一段类/模块定义并不会出错，那么只需要能让一段基于 <code>alias</code> 写的插件执行两遍等于只执行第二遍就行了！</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">alias</span><span class="μ2"> old_meth meth</span></span>
<span class="line"><span class="μ1">def</span><span class="μ3"> meth</span></span>
<span class="line"><span class="μ1">  return</span><span class="μ2"> old_meth </span><span class="μ1">+</span><span class="μ4"> 1</span></span>
<span class="line"><span class="μ1">end</span></span></code></pre><p>假设有这样的插件代码。仔细观察，我们需要让 <code>old_meth</code> 第二次执行的时候仍然是<q>原方法</q>。怎么做呢？可以换成一个自定义的 <code>alias</code>：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ2">magic_alias </span><span class="μ4">:old_meth</span><span class="μ2">, </span><span class="μ4">:meth</span></span>
<span class="line"><span class="μ2">...</span></span></code></pre><p>如果上下文里已经有 <code>old_meth</code>，说明已经执行过一次，什么都不做就行：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">class</span><span class="μ1"> &#x3C;&#x3C;</span><span class="μ2"> self</span></span>
<span class="line"><span class="μ1">  def</span><span class="μ3"> magic_alias</span><span class="μ2">(name, value)</span></span>
<span class="line"><span class="μ1">    return</span><span class="μ1"> if</span><span class="μ2"> method_defined? name</span></span>
<span class="line"><span class="μ1">    alias_method</span><span class="μ2"> name, value </span><span class="μ5"># 否则正常使用原 alias 效果</span></span>
<span class="line"><span class="μ1">  end</span></span>
<span class="line"><span class="μ1">end</span></span></code></pre><p>所以，我当时的方案就是：在每页文件开头加这么一个神秘函数，用它代替 alias，然后重新执行这页代码，就可以适配大部分插件脚本的热更新了。</p><hr><p>Sublime Text 里也有一个针对插件的热更新机制，也是直接重新执行一下插件 python 文件。不过，它可以在顶层定义 <code>plugin_loaded</code> 和 <code>plugin_unloaded</code> 方法，在插件重载的时候可以利用这两个方法确保执行效果正确。</p><p>比起我的<q>神秘代码</q> + 重新执行，ST 的工作方式如下：</p><ol><li>原插件非阻塞调用 <code>plugin_unloaded</code></li><li>执行新插件</li><li>执行新插件的 <code>plugin_loaded</code></li></ol><p>这样一来，等于将热更新逻辑交给写插件的人实现。</p><hr><p>前端开发也有一套热更新方法，你可以在 <a target="_blank" rel="noopener" href="https://webpack.js.org/concepts/hot-module-replacement/">webpack</a>、<a target="_blank" rel="noopener" href="https://github.com/rixo/rollup-plugin-hot">rollup</a>、<a target="_blank" rel="noopener" href="https://github.com/PepsRyuu/nollup/blob/master/docs/nollup-hooks.md">nollup</a>、<a target="_blank" rel="noopener" href="https://vitejs.dev/guide/features.html#hot-module-replacement">vite</a> 里看到一套 HMR 接口，其基本思路和上面提到的其实也是一回事，每个模块（文件）可以注册退出 <code>hot.dispose()</code> 和进入 <code>hot.accept()</code> 时干的事情，从而达到热更新效果。</p><p>以 Vite 为例，他的热更新流程如下：</p><ol><li>后端扫描代码文件，理清依赖关系，把代码里包含 <code>hot.accept()</code> 的文件视为<q>热更新模块边界</q></li><li>有文件发生变化时，通过 1 的依赖关系查找到变化文件的公共热更新边界，通知前端刷新这个文件</li><li>前端依次执行：<ol><li>调用所有相关文件的 <code>hot.dispose()</code> 回调</li><li>下载执行 2 找到的边界文件</li><li>调用该文件的 <code>hot.accept()</code> 回调</li></ol></li></ol><p>不过，这里存在一个陷阱：你能保证除了更新的文件以外的模块不变吗？</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ5">// global.js</span></span>
<span class="line"><span class="μ1">export</span><span class="μ1"> let</span><span class="μ2"> state </span><span class="μ1">=</span><span class="μ2"> []</span></span>
<span class="line"></span>
<span class="line"><span class="μ5">// a.js</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> { state } </span><span class="μ1">from</span><span class="μ6"> './global.js'</span></span>
<span class="line"><span class="μ2">state.</span><span class="μ3">push</span><span class="μ2">(</span><span class="μ6">'a'</span><span class="μ2">)</span></span>
<span class="line"></span>
<span class="line"><span class="μ5">// b.js</span></span>
<span class="line"><span class="μ1">import</span><span class="μ2"> { state } </span><span class="μ1">from</span><span class="μ6"> './global.js'</span></span>
<span class="line"><span class="μ2">state.</span><span class="μ3">push</span><span class="μ2">(</span><span class="μ6">'b'</span><span class="μ2">)</span></span></code></pre><p>如果 a.js 发生了热更新，他能否在更新期间拿到和 b.js 一样的 <code>state</code>？</p><p>如果不能，那么此时运行时出现了两个 <code>state</code>，可能会出现一些 bug。</p><p>因此，那些基于黑 <code>require</code> 或类似技术（如 SystemJS）的 HMR 实现，可以保证新加载的模块依然可以引用到公共模块，只需要动态决定 <code>require</code> 返回啥就行了（比如可以用 <code>id+timestamp</code> 标识模块的唯一性）。</p><p>而 Vite 这种基于原生 ESM 的，显然没有地方给他黑 <code>import</code>，他唯一能做的就是利用浏览器缓存来让浏览器觉得使用了同一个模块。继续思考，然后你会发现他这种方案只能<q>不打包</q>，否则总是无法实现模块的唯一性。</p><p>Vite 的方案有没有可能在 Node.js 里实现呢？不好说，因为我们不清楚 <code>import</code> 到底有没有 cache，以及这个 cache 认不认 query（<code>import &quot;mod?t=114514&quot;</code>）。</p><hr><p>什么东西适合热更新？虽然我上面只提了 RM/ST 插件、前端工具，但是不难看出，基本上就这些东西<q>在</q>实现热更新：</p><ul><li>即插即用的插件</li><li>前端组件库，包括 CSS 样式</li></ul><p>前者不难理解，本身已经对<q>即插即用</q>下了一些功夫。后者可以理解为，组件的副作用恰好是热更新的目标——因为组件本身存在生命周期，只需要调用前组件的卸载和新组件的挂载就行。这些组件就类似我一开篇提到的用 alias 编写的 RM 插件，因为符合某种规范所以恰好运行良好。</p><p>除此以外，适当缩小业务范围也不难定义出适合热更新的目标。</p><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2023 @ hyrious</p></footer></body></html>