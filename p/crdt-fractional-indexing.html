<!DOCTYPE html>
<html lang="zh-Hans-CN">
<head>
  <meta charset="UTF-8">
  <title>CRDT: 分数排序</title>
  <meta name="color-scheme" content="light dark">
  <meta name="viewport" content="width=device-width">
  <link rel="icon" href="../favicon.ico">
  <link rel="stylesheet" href="../style.css">
</head>
<body class="post">
  <h2>CRDT: 分数排序</h2>
  <address>最后更新于 <time>2023-01-19</time></address>

<blockquote>
<p>原文：<a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-fractional-indexing">&laquo;CRDT: Fractional Indexing&raquo;</a>
原网站里还有精美的可视化效果。</p>
</blockquote>
<p>CRDT 是一系列解决协作问题的算法，其中一个不可避免的问题就是：如何记录顺序，如何在发生顺序修改时表现正确。假设我们使用一个数组来记录一组数据的话：</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> todos = [<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>];
</code></pre>
<p>在同步这个数据时，不可避免地要将这个数组发来发去，当数据量很大时显然不是一个优解。此时先别急着实现 CRDT 链表，我们可以让每个元素多记录一个特殊的数据用来排序，并且用这种方式的网络传输压力很小，下面就来看看。</p>
<p>首先，利用传统的 LWW (last-write-win) 算法，我们可以实现 CRDT Map，但这里面的元素不是有序的。接着，我们给每个元素添加一个字段表示它在数组中的位置。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> todos = {
  <span class="hljs-string">&quot;1@1&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;?&quot;</span> },
  <span class="hljs-string">&quot;1@2&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;?&quot;</span> },
};
</code></pre>
<p>其中左边的 <code>1@1</code> 只是用来标记元素唯一的，它可以通过 <code>client(本地随机id) + clock(自增整数)</code> 的方式生成。右边的 <code>position</code> 是本文即将说明的技巧，有了它就可以轻松实现排序、有序元素间交换等行为。</p>
<h3 id="position-的定义"><code>position</code> 的定义</h3>
<p>我们定义 <code>position</code> 是一个从 0 到 1 的数，当出现新的元素要插到某个有序列中时，取其前后元素的 <code>position</code>，折半即可得到新元素的 <code>position</code>。当没有前元素时，认为它是 0，当没有后元素时，认为它是 1。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> todos = {
  <span class="hljs-string">&quot;1@1&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-number">0.5</span> }, <span class="hljs-comment">// 第一个元素，插入 0 ~ 1 的中间，取 0.5</span>
  <span class="hljs-string">&quot;1@2&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-number">0.75</span> }, <span class="hljs-comment">// 第二个元素，插入 0.5 ~ 1 的中间，取 0.75</span>
};
</code></pre>
<p>直接二分取数的话，很快我们就会碰到浮点数的瓶颈：折半失效了！此时可以把它转成字符串，利用大整数的实现思路，实现一个无限精度的小数（或者称之为以 10 的指数为分母的分数）。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> todos = {
  <span class="hljs-string">&quot;1@1&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;0.5&quot;</span> }, <span class="hljs-comment">// 5/10</span>
  <span class="hljs-string">&quot;1@2&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;0.75&quot;</span> }, <span class="hljs-comment">// 75/100</span>
};
</code></pre>
<h3 id="冲突处理">冲突处理</h3>
<p>上面这个技巧在多人协作时会有一个问题：如果两个人同时在一个位置插入了新节点，岂不是会产生两个一模一样的 <code>position</code>？</p>
<p>首先我们肯定不能让排序的结果不对，我们可以用客户端本地生成的随机 id (也就是上面 <code>todos</code> 的 keys) 对这些节点的排序算法做兜底。</p>
<p>其次有一个简单的方法可以避免这种确定性冲突——引入不确定的随机数即可，每次不光是折半产生下标，并且我们故意往后多添加几位随机数。在十进制下，仅仅是多添加三个字节就可以达到 1000 种不同的后缀，而这么多人同时操作同一个有序列表的概率不大。</p>
<pre><code class="language-js"><span class="hljs-keyword">var</span> todos = {
  <span class="hljs-string">&quot;1@1&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;0.5123&quot;</span> }, <span class="hljs-comment">// ~5/10</span>
  <span class="hljs-string">&quot;1@2&quot;</span>: { <span class="hljs-attr">text</span>: <span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-attr">position</span>: <span class="hljs-string">&quot;0.75478&quot;</span> }, <span class="hljs-comment">// ~75/100</span>
};
</code></pre>
<p>当然，如果放宽 CRDT 的限制，引入中心服务器裁决的话，也可以让服务器帮冲突的节点挑选一个新位置。</p>

  <footer>
    <p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2022 @ hyrious</p>
  </footer>
</body>
</html>
