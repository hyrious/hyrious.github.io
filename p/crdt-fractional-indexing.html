<!DOCTYPE html><html lang="zh-Hans-CN"><head><meta charset="UTF-8"><title>CRDT: 分数排序</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><link rel="stylesheet" crossorigin href="/i/index-qDCUwxeJ.css"></head><body class="post"><h2>CRDT: 分数排序</h2><address>最后更新于 <time>2023-01-19</time></address><style>.μ0{color:#24292e;background-color:#fff}.μ1{color:#d73a49}.μ2{color:#24292e}.μ3{color:#032f62}.μ4{color:#005cc5}.μ5{color:#6a737d}@media(prefers-color-scheme:dark){.μ0{color:#e1e4e8;background-color:#24292e}.μ1{color:#f97583}.μ2{color:#e1e4e8}.μ3{color:#9ecbff}.μ4{color:#79b8ff}.μ5{color:#6a737d}}</style><blockquote><p>原文：<a target="_blank" rel="noopener" href="https://madebyevan.com/algos/crdt-fractional-indexing">&laquo;CRDT: Fractional Indexing&raquo;</a> 原网站里还有精美的可视化效果。</p></blockquote><p>CRDT 是一系列解决协作问题的算法，其中一个不可避免的问题就是：如何记录顺序，如何在发生顺序修改时表现正确。假设我们使用一个数组来记录一组数据的话：</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> [</span><span class="μ3">'hello'</span><span class="μ2">, </span><span class="μ3">'world'</span><span class="μ2">]</span></span></code></pre><p>在同步这个数据时，不可避免地要将这个数组发来发去，当数据量很大时显然不是一个优解。此时先别急着实现 CRDT 链表，我们可以让每个元素多记录一个特殊的数据用来排序，并且用这种方式的网络传输压力很小，下面就来看看。</p><p>首先，利用传统的 LWW (last-write-win) 算法，我们可以实现 CRDT Map，但这里面的元素不是有序的。接着，我们给每个元素添加一个字段表示它在数组中的位置。</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ3">'?'</span><span class="μ2"> },</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ3">'?'</span><span class="μ2"> },</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><p>其中左边的 <code>1@1</code> 只是用来标记元素唯一的，它可以通过 <code>client(本地随机id) + clock(自增整数)</code> 的方式生成。右边的 <code>position</code> 是本文即将说明的技巧，有了它就可以轻松实现排序、有序元素间交换等行为。</p><h3 id="position-的定义"><code>position</code> 的定义</h3><p>我们定义 <code>position</code> 是一个从 0 到 1 的数，当出现新的元素要插到某个有序列中时，取其前后元素的 <code>position</code>，折半即可得到新元素的 <code>position</code>。当没有前元素时，认为它是 0，当没有后元素时，认为它是 1。</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ4">0.5</span><span class="μ2"> }, </span><span class="μ5">// 第一个元素，插入 0 ~ 1 的中间，取 0.5</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ4">0.75</span><span class="μ2"> }, </span><span class="μ5">// 第二个元素，插入 0.5 ~ 1 的中间，取 0.75</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><p>直接二分取数的话，很快我们就会碰到浮点数的瓶颈：折半失效了！此时可以把它转成字符串，利用大整数的实现思路，实现一个无限精度的小数（或者称之为以 10 的指数为分母的分数）。</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ3">'0.5'</span><span class="μ2"> }, </span><span class="μ5">// 5/10</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ3">'0.75'</span><span class="μ2"> }, </span><span class="μ5">// 75/100</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><h3 id="冲突处理">冲突处理</h3><p>上面这个技巧在多人协作时会有一个问题：如果两个人同时在一个位置插入了新节点，岂不是会产生两个一模一样的 <code>position</code>？</p><p>首先我们肯定不能让排序的结果不对，我们可以用客户端本地生成的随机 id (也就是上面 <code>todos</code> 的 keys) 对这些节点的排序算法做兜底。</p><p>其次有一个简单的方法可以避免这种确定性冲突——引入不确定的随机数即可，每次不光是折半产生下标，并且我们故意往后多添加几位随机数。在十进制下，仅仅是多添加三个字节就可以达到 1000 种不同的后缀，而这么多人同时操作同一个有序列表的概率不大。</p><pre class="shiki shiki-themes github-light github-dark μ0" tabindex="0"><code><span class="line"><span class="μ1">var</span><span class="μ2"> todos </span><span class="μ1">=</span><span class="μ2"> {</span></span>
<span class="line"><span class="μ3">  '1@1'</span><span class="μ2">: { text: </span><span class="μ3">'hello'</span><span class="μ2">, position: </span><span class="μ3">'0.5123'</span><span class="μ2"> }, </span><span class="μ5">// ~5/10</span></span>
<span class="line"><span class="μ3">  '1@2'</span><span class="μ2">: { text: </span><span class="μ3">'world'</span><span class="μ2">, position: </span><span class="μ3">'0.75478'</span><span class="μ2"> }, </span><span class="μ5">// ~75/100</span></span>
<span class="line"><span class="μ2">}</span></span></code></pre><p>当然，如果放宽 CRDT 的限制，引入中心服务器裁决的话，也可以让服务器帮冲突的节点挑选一个新位置。</p><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2023 @ hyrious</p></footer></body></html>