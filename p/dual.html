<!DOCTYPE html>
<html lang="zh-Hans-CN">
<head>
    <meta charset="UTF-8">
    <title>“双包”陷阱</title>
    <meta name="color-scheme" content="light dark">
    <meta name="viewport" content="width=device-width">
    <link rel="icon" href="../favicon.ico">
    <link rel="stylesheet" href="../style.css">
    <style>
        .dim { opacity: 0.5; }
    </style>
</head>
<body>
    <h2><q>双包</q>陷阱</h2>
    <address>最后更新于 <time>2021-08-14</time></address>
    <blockquote>
        Ref:<br>
        <a href="https://nodejs.org/api/packages.html#packages_dual_commonjs_es_module_packages" target="_blank">Dual CommonJS/ES module packages</a>
        <em>Node.js docs</em>.
    </blockquote>
    <p>在进入正文之前，首先明确这里有几个正交的话题：</p>
    <ul>
        <li>CommonJS (以下缩写 cjs) / ES module (以下缩写 esm)</li>
        <li>Node.js / Browser</li>
        <li>Bundler / No bundler</li>
    </ul>
    <p>本文的目标是：尽量不出于版本不同而引入重复的代码。换而言之就是除非有使用不同版本的需求，任何代码都应当只存在一份。</p>
    <p>那么什么时候会引入两份相同的代码呢？当一个包同时导出了 cjs 和 esm 代码的时候。让我们看一个例子 (此处对应文档中的<a href="https://nodejs.org/api/packages.html#packages_approach_1_use_an_es_module_wrapper">方式一、二</a>)：</p>
    <pre><code>"exports": {
    "import": "./index.mjs",
    "require": "./index.js"
}</code></pre>
    <p>这么导出有什么问题？问题在于当外部有两个文件用不同方式引入该包时，对应的两个文件都会被考虑进去：</p>
    <pre><code>// a.js
import "pkg" // -> pkg/index.mjs
// b.js
require("pkg") // -> pkg/index.js
</code></pre>
    <p>一种解决方式，如文档所说，就是 index.mjs 实际上里面什么都没写，只是引入 index.js 再重新导出的一个 wrapper。这么做的代价是放弃了 tree shaking。</p>
    <p>另一种解决方式，就是使用不同的命名来防止外部使用出错：</p>
    <pre><code>"exports": {
    ".": "./index.js",
    "./module": "./index.mjs"
}</code></pre>
    <p>这样一来外部就不会<q>不小心</q>引入两个相同的文件了，除非是故意。代价就是用 esm 的那个文件得写个奇怪的路径。通常来说上述两个解决方式对原本是 cjs 的包进行迁移比较有用，而如果原本是 esm (typescript)，那最好继续往下看。</p>
    <p>注意：以上内容同时对 Node.js 和打包工具（通常是打包给浏览器）生效。</p>
    <hr>
    <p>对 Node.js 来说，esm 用户往往希望自己能使用 <code>import { name } from "pkg"</code> 的方式来引入，而 named exports 必须使用 esm 语法才能导出。Node.js 原生会依次看 <code>exports</code>、<code>main</code> 字段来决定到底用哪个文件。</p>
    <p>对浏览器来说，有两种使用方式：全局 IIFE (或者等价的 UMD) 和打包器。IIFE 就不说了，打包器会依次看 <code>browser</code>、<code>exports</code>、<code>module</code> 和 <code>main</code> 字段来决定到底用哪个文件。</p>
    <hr class="dim">
    <p>如果要同时考虑 Node.js 和浏览器的 esm 需求，那么推荐以下配置：</p>
    <pre><code>"exports": {
    "node": {
        "import": "./index-node.mjs",
        "require": "./index-node.js"
    },
    "default": "./index.mjs",
}</code></pre>
    <p><code>exports.node</code> 限定了这里的条件只有目标平台是 Node 时才会考虑，其他情况下走 default 分支。同时鉴于现代打包器都在推崇 esm 带来的 tree shaking 等好处，所以这里只导出一个 esm 文件即可 (不会吧不会还有人用不支持 esm 的打包器吧)。</p>
    <hr class="dim">
    <p>如果 Node.js 就用 cjs 也无所谓，那么推荐以下配置：</p>
    <pre><code>"main": "index.js",
"module": "index.mjs"</code></pre>
    <p>这回连 <code>exports</code> 都不要了，也是最不用思考的例子。</p>
    <hr class="dim">
    <p>如果 cjs 去他喵，给我全线换成 esm，这里有两种做法：</p>
    <pre><code>"main": "index.mjs"</code></pre>
    <p>用 <code>mjs</code> 后缀表明这个文件是 esm 格式，Node.js 会切到 esm 模式来运行文件。</p>
    <pre><code>"type": "module",
"main": "index.js"</code></pre>
    <p><code>type</code> 是一个比较危险的字段，他表示将当前文件夹下所有 .js 文件视为 esm 格式。在 type=module 时，还使用 cjs 唯一的办法是使用 .cjs 后缀。</p>
    <p>辣个男人 (Sindre Sorhus) 正在将他全部的包都换成下面这种形式，你们觉得这样好不好呢。</p>
    <hr>
    <p>补充：如果需要在不同的平台跑不同的代码，可以用 <code>browser</code> 字段，他的优先级在打包器中高于其他所有字段，顶多和 <code>exports</code> 持平 (但是 <code>browser</code> 可以覆盖 <code>exports</code>)。</p>
</body>
</html>
