<!DOCTYPE html>
<html lang="zh-Hans-CN">
<head>
  <meta charset="UTF-8">
  <title>TypeScript object vs record vs {}</title>
  <meta name="color-scheme" content="light dark">
  <meta name="viewport" content="width=device-width">
  <link rel="icon" href="../favicon.ico">
  <link rel="stylesheet" href="../style.css">
</head>
<body>
  <h2>TypeScript <code>object</code> vs <code>record</code> vs <code>{}</code></h2>
  <address>最后更新于 <time>2023-02-21</time></address>

<p>TypeScript 中存在三种可以用来描述<q>对象</q>的类型：<code>object</code>、<code>Record&lt;string, any&gt;</code>、<code>{}</code>，该用哪种？下面就来看看。</p>
<h3 id="-空的形状"><code>{}</code> 空的形状</h3>
<p>首先我们知道 <code>{}</code> 是一个 interface，它负责匹配<q>形状</q>，而一个空的形状约等于 <code>any</code> ——</p>
<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: {} = <span class="hljs-number">1</span>; <span class="hljs-comment">// ok</span>
</code></pre>
<p>实际上，它保证右侧的值是可以按<q>对象</q>形式（也就是下标形式）访问的。也就是说 <code>null</code> 和 <code>undefined</code> 不在此列（因为他们直接 <code>.foo</code> 会炸）。</p>
<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: {} = <span class="hljs-literal">null</span>; <span class="hljs-comment">// error</span>
</code></pre>
<p>此外，注意到对象都继承有 <code>Object.prototype</code>，所以我们可以调用这些方法而不爆炸：</p>
<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: {} = <span class="hljs-number">1</span>;
a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// ok</span>
</code></pre>
<p>上面的说法有个问题，<code>Object.create(null)</code> 可以不继承那些方法，但是 <code>Object.create()</code> 的类型返回 <code>any</code>，所以 TypeScript 实际检查不出下面代码的错误：</p>
<pre><code class="language-ts"><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: {} = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>);
a.<span class="hljs-title function_">toString</span>(); <span class="hljs-comment">// types ok, but runtime error</span>
</code></pre>
<h3 id="object-非基本类型以外的所有"><code>object</code> 非基本类型以外的所有</h3>
<p>可以阅读 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-2-2/#the-object-type">TypeScript 2.2 的更新说明</a>，就是 <code>{}</code> 去掉 <code>number</code> 之类的基本类型。</p>
<p>实际上，除了标准库里会有一些接口必须传入非基本类型对象（如 <code>map.set(object,value)</code>）外，日常操作几乎用不着这个玩意儿。</p>
<h4 id="object-所有对象都继承的形状"><code>Object</code> 所有对象都继承的形状</h4>
<p><code>Object</code>（大写 <code>O</code>）是定义在 <code>libes*.d.ts</code> 里的 interface，它是所有对象类型最终继承的形状，所以它上面的方法可以从任意对象上点出来使用。</p>
<p>除了用于扩展标准库以外，日常操作几乎用不着这个玩意儿。</p>
<pre><code class="language-ts"><span class="hljs-comment">// 可能的用途</span>
<span class="hljs-comment">// 模块上下文需要 declare global，脚本上下文不需要</span>
<span class="hljs-keyword">declare</span> <span class="hljs-variable language_">global</span> {
  <span class="hljs-keyword">interface</span> <span class="hljs-title class_">Object</span> {
    <span class="hljs-title function_">foo</span>(): <span class="hljs-built_in">number</span>;
  }
}
<span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">foo</span> = <span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-number">42</span>;
};
</code></pre>
<h3 id="recordstring-any-传统字典或者不如-"><code>Record&lt;string, any&gt;</code> 传统字典，或者不如 <code>{}</code></h3>
<p>在 <code>Map</code>（es6）发明出来之前，JS 里只能使用对象来模拟使用字典（实际上 v8 会检测这种用法并在底层切到一个真的字典实现）。因此 <code>Record&lt;K, V&gt;</code> 可以用于标记这种用法。</p>
<p>另一种用法是，当你在玩一些类型体操，操作用户传入或者 infer 出来的对象类型时，需要先用 <code>extends</code> 来限制传进来的确实是对象类型，你可能会在哪里看到这种写法：</p>
<pre><code class="language-ts"><span class="hljs-keyword">function</span> foo&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Record</span>&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;&gt;(<span class="hljs-attr">obj</span>: T, <span class="hljs-attr">key</span>: keyof T) {}
</code></pre>
<p>简单解释一下 <code>extends</code>，这个关键字限制传进来的类型必须被右侧的类型<em>包含</em>，然后可以对原类型做后续处理（如 <code>keyof</code> 和别的体操）。</p>
<p>显然，这个例子里我们限制第一个参数大概需要是个对象，然后第二个参数会推导出第一个参数的下标。那么用 <code>{}</code> 可以吗？可以！</p>
<pre><code class="language-ts"><span class="hljs-keyword">type</span> <span class="hljs-title class_">Foo</span>&lt;T <span class="hljs-keyword">extends</span> {}&gt; = keyof T;
<span class="hljs-comment">// type A = &#x27;a&#x27; | &#x27;b&#x27;</span>
<span class="hljs-keyword">type</span> A = <span class="hljs-title class_">Foo</span>&lt;{ <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>; <span class="hljs-attr">b</span>: <span class="hljs-number">2</span> }&gt;;
<span class="hljs-comment">// type B = &#x27;toString&#x27; | &#x27;toFixed&#x27; | &#x27;toExponential&#x27; | &#x27;toPrecision&#x27; | &#x27;valueOf&#x27; | &#x27;toLocaleString&#x27;</span>
<span class="hljs-keyword">type</span> B = <span class="hljs-title class_">Foo</span>&lt;<span class="hljs-number">1</span>&gt;;
</code></pre>
<p><q>这不对</q>，你可能想这么说。这一眼看上去不符合你对用户的用法的期待，但是类型和运行时上都是允许的。</p>
<pre><code class="language-ts"><span class="hljs-title function_">foo</span>(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;toString&quot;</span>); <span class="hljs-comment">// ok</span>
(<span class="hljs-number">1</span>)[<span class="hljs-string">&quot;toString&quot;</span>]; <span class="hljs-comment">// ok</span>
</code></pre>
<p>我建议所有人都把 <code>extends Record&lt;string, any&gt;</code> 换成 <code>extends {}</code>，因为</p>
<ul>
<li>对类型的限制更宽松</li>
<li>更短，好写好读</li>
<li>（性能上）更快</li>
<li>（语义上）更正确</li>
</ul>
<h3 id="typescript-eslint-历史遗留问题"><code>typescript-eslint</code> 历史遗留问题</h3>
<p><a target="_blank" rel="noopener" href="https://typescript-eslint.io/rules/ban-types/">typescript-eslint 默认禁止你使用 <code>Object</code> 和 <code>{}</code></a>，前者没什么问题，但 <code>{}</code> 实际上是很有用的类型。这纯粹是因为 TypeScript 以前的 <code>{}</code> 没那么好用。</p>
<p>你可以添加以下规则来覆盖它对 <code>{}</code> 的限制：</p>
<pre><code class="language-json"><span class="hljs-punctuation">{</span>
  <span class="hljs-attr">&quot;@typescript-eslint/ban-types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">[</span>
    <span class="hljs-string">&quot;error&quot;</span><span class="hljs-punctuation">,</span>
    <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;types&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-punctuation">{</span> <span class="hljs-attr">&quot;{}&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">false</span></span> <span class="hljs-punctuation">}</span><span class="hljs-punctuation">,</span> <span class="hljs-attr">&quot;extendDefaults&quot;</span><span class="hljs-punctuation">:</span> <span class="hljs-literal"><span class="hljs-keyword">true</span></span> <span class="hljs-punctuation">}</span>
  <span class="hljs-punctuation">]</span>
<span class="hljs-punctuation">}</span>
</code></pre>

  <footer>
    <p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2022 @ hyrious</p>
  </footer>
</body>
</html>
