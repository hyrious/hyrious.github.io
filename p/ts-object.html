<!DOCTYPE html><html lang="zh-Hans-CN" data-critters-container><head><meta charset="UTF-8"><title>TypeScript object vs record vs {}</title><meta name="author" content="hyrious"><meta name="color-scheme" content="light dark"><meta name="viewport" content="width=device-width"><link rel="icon" href="/favicon.svg" type="image/svg+xml"><link rel="alternate" href="/feed.xml" type="application/rss+xml" title="hyrious.log"><style>*,:after,:before{box-sizing:border-box;background-repeat:no-repeat}:after,:before{text-decoration:inherit;vertical-align:inherit}:where(body){margin:0}:where(pre){font-family:monospace,monospace;font-size:1em;overflow:auto}:where(code,kbd,samp){font-family:monospace,monospace;font-size:1em}:root{--title-color:#0d1117;--link-color:#0057ab;--link-bg-color:#deefff;--text-color:rgba(0, 0, 0, .8);--bg-color:#fff;--gray-color:#79828b;--pre-color:rgba(0, 0, 0, .05)}@media (prefers-color-scheme:dark){:root{--title-color:#dddddc;--link-color:#79c0ff;--link-bg-color:#263441;--text-color:rgba(255, 255, 255, .8);--bg-color:#0d1117;--gray-color:#747d86;--pre-color:rgba(255, 255, 255, .05)}}html{font-family:Chinese Quotes,Inter var,Inter,ui-sans-serif,system-ui,Segoe UI,Roboto,Ubuntu,Noto Sans,sans-serif,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji"}code,pre{font-family:ui-monospace,Cascadia Mono,Consolas,Roboto Mono,"Ubuntu Monospace",Noto Mono,monospace,"Apple Color Emoji","Segoe UI Emoji",Segoe UI Symbol,"Noto Color Emoji";font-size:90%}body{margin:auto;padding:2ch;max-width:70ch;color:var(--text-color,#000);background-color:var(--bg-color,#fff);line-height:1.58;font-synthesis:style}@property --offset{syntax:"<length>";inherits:false;initial-value:0}a{color:var(--link-color,#000);text-decoration:underline solid;text-decoration-color:transparent;text-decoration-thickness:2px;text-underline-offset:var(--offset,.1em);transition:text-decoration-color .2s,--offset .2s;box-shadow:0 -.7em var(--link-bg-color,#deefff) inset}a:hover{cursor:pointer}a:focus,a:hover{text-decoration-color:var(--link-color,#000);--offset:.2em}@supports not (background:paint(something)){a{transition:text-decoration-color .2s,text-underline-offset .2s}a:focus,a:hover{text-underline-offset:.2em}}h2{font-weight:700;font-size:28px;line-height:34px;margin:21px 0 12px;color:var(--title-color,#000)}h3{font-weight:700;font-size:22px;line-height:24px;margin:2rem 0 1rem;color:var(--title-color,#000)}h4{font-size:20px;line-height:22px;margin:1.6rem 0 .6rem;color:var(--title-color,#000)}h2,h3,h4{text-wrap:balance}:is(h2,h3,h4,a[href^="/p/"])>code:after,:is(h2,h3,h4,a[href^="/p/"])>code:before{content:"`"}:is(h2,h3,h4,a[href^="/p/"])>code{background:var(--pre-color,rgba(0,0,0,.05))}footer{padding:2ch 0;color:var(--gray-color);position:sticky;top:100vh;font-variant-numeric:tabular-nums}address{font-style:normal;font-size:15px;line-height:18px;color:var(--gray-color,#79828b);margin-bottom:14px;font-variant-numeric:tabular-nums}p{margin:0 0 9px;line-height:1.75}.shiki{font-family:DM Mono,Input Mono,Fira Code,monospace;font-size:.92em;line-height:1.4;margin:.5em 0;padding:1ch 16px;border-radius:6px;background-color:var(--pre-color)!important}.shiki>code{display:block;padding:0}@media (prefers-color-scheme:dark){.shiki,.shiki span{color:var(--s-dark)!important}}p>code{padding:2px 4px;background-color:var(--pre-color)}footer a{color:inherit}footer a{box-shadow:unset}footer a:focus,footer a:hover{text-decoration-color:inherit}</style><link rel="preload" crossorigin href="/assets/index-vWxNvpCb.css" as="style"></head><body class="post"><h2>TypeScript <code>object</code> vs <code>record</code> vs <code>{}</code></h2><address>最后更新于 <time>2023-02-21</time></address><p>TypeScript 中存在三种可以用来描述<q>对象</q>的类型：<code>object</code>、<code>Record&lt;string, any&gt;</code>、<code>{}</code>，该用哪种？下面就来看看。</p><h3 id="-空的形状"><code>{}</code> 空的形状</h3><p>首先我们知道 <code>{}</code> 是一个 interface，它负责匹配<q>形状</q>，而一个空的形状约等于 <code>any</code> ——</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#d73a49;--s-dark:#F97583">let</span><span style="color:#24292e;--s-dark:#E1E4E8"> a</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#24292e;--s-dark:#E1E4E8"> {} </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#005cc5;--s-dark:#79B8FF"> 1</span><span style="color:#6a737d;--s-dark:#6A737D"> // ok</span></span></code></pre><p>实际上，它保证右侧的值是可以按<q>对象</q>形式（也就是下标形式）访问的。也就是说 <code>null</code> 和 <code>undefined</code> 不在此列（因为他们直接 <code>.foo</code> 会炸）。</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#d73a49;--s-dark:#F97583">let</span><span style="color:#24292e;--s-dark:#E1E4E8"> a</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#24292e;--s-dark:#E1E4E8"> {} </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#005cc5;--s-dark:#79B8FF"> null</span><span style="color:#6a737d;--s-dark:#6A737D"> // error</span></span></code></pre><p>此外，注意到对象都继承有 <code>Object.prototype</code>，所以我们可以调用这些方法而不爆炸：</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#d73a49;--s-dark:#F97583">let</span><span style="color:#24292e;--s-dark:#E1E4E8"> a</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#24292e;--s-dark:#E1E4E8"> {} </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#005cc5;--s-dark:#79B8FF"> 1</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">a.</span><span style="color:#6f42c1;--s-dark:#B392F0">toString</span><span style="color:#24292e;--s-dark:#E1E4E8">() </span><span style="color:#6a737d;--s-dark:#6A737D">// ok</span></span></code></pre><p>上面的说法有个问题，<code>Object.create(null)</code> 可以不继承那些方法，但是 <code>Object.create()</code> 的类型返回 <code>any</code>，所以 TypeScript 实际检查不出下面代码的错误：</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#d73a49;--s-dark:#F97583">let</span><span style="color:#24292e;--s-dark:#E1E4E8"> a</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#24292e;--s-dark:#E1E4E8"> {} </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#24292e;--s-dark:#E1E4E8"> Object.</span><span style="color:#6f42c1;--s-dark:#B392F0">create</span><span style="color:#24292e;--s-dark:#E1E4E8">(</span><span style="color:#005cc5;--s-dark:#79B8FF">null</span><span style="color:#24292e;--s-dark:#E1E4E8">)</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">a.</span><span style="color:#6f42c1;--s-dark:#B392F0">toString</span><span style="color:#24292e;--s-dark:#E1E4E8">() </span><span style="color:#6a737d;--s-dark:#6A737D">// types ok, but runtime error</span></span></code></pre><h3 id="object-非基本类型以外的所有"><code>object</code> 非基本类型以外的所有</h3><p>可以阅读 <a target="_blank" rel="noopener" href="https://devblogs.microsoft.com/typescript/announcing-typescript-2-2/#the-object-type">TypeScript 2.2 的更新说明</a>，就是 <code>{}</code> 去掉 <code>number</code> 之类的基本类型。</p><p>实际上，除了标准库里会有一些接口必须传入非基本类型对象（如 <code>map.set(object,value)</code>）外，日常操作几乎用不着这个玩意儿。</p><h4 id="object-所有对象都继承的形状"><code>Object</code> 所有对象都继承的形状</h4><p><code>Object</code>（大写 <code>O</code>）是定义在 <code>libes*.d.ts</code> 里的 interface，它是所有对象类型最终继承的形状，所以它上面的方法可以从任意对象上点出来使用。</p><p>除了用于扩展标准库以外，日常操作几乎用不着这个玩意儿。</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#6a737d;--s-dark:#6A737D">// 可能的用途</span></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">// 模块上下文需要 declare global，脚本上下文不需要</span></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">declare</span><span style="color:#24292e;--s-dark:#E1E4E8"> global {</span></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">  interface</span><span style="color:#6f42c1;--s-dark:#B392F0"> Object</span><span style="color:#24292e;--s-dark:#E1E4E8"> {</span></span>
<span class="line"><span style="color:#6f42c1;--s-dark:#B392F0">    foo</span><span style="color:#24292e;--s-dark:#E1E4E8">()</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#005cc5;--s-dark:#79B8FF"> number</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">  }</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">}</span></span>
<span class="line"><span style="color:#005cc5;--s-dark:#79B8FF">Object</span><span style="color:#24292e;--s-dark:#E1E4E8">.</span><span style="color:#005cc5;--s-dark:#79B8FF">prototype</span><span style="color:#24292e;--s-dark:#E1E4E8">.</span><span style="color:#6f42c1;--s-dark:#B392F0">foo</span><span style="color:#d73a49;--s-dark:#F97583"> =</span><span style="color:#d73a49;--s-dark:#F97583"> function</span><span style="color:#6f42c1;--s-dark:#B392F0"> foo</span><span style="color:#24292e;--s-dark:#E1E4E8">() {</span></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">  return</span><span style="color:#005cc5;--s-dark:#79B8FF"> 42</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">}</span></span></code></pre><h3 id="recordstring-any-传统字典或者不如-"><code>Record&lt;string, any&gt;</code> 传统字典，或者不如 <code>{}</code></h3><p>在 <code>Map</code>（es6）发明出来之前，JS 里只能使用对象来模拟使用字典（实际上 v8 会检测这种用法并在底层切到一个真的字典实现）。因此 <code>Record&lt;K, V&gt;</code> 可以用于标记这种用法。</p><p>另一种用法是，当你在玩一些类型体操，操作用户传入或者 infer 出来的对象类型时，需要先用 <code>extends</code> 来限制传进来的确实是对象类型，你可能会在哪里看到这种写法：</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#d73a49;--s-dark:#F97583">function</span><span style="color:#6f42c1;--s-dark:#B392F0"> foo</span><span style="color:#24292e;--s-dark:#E1E4E8">&#x3C;</span><span style="color:#6f42c1;--s-dark:#B392F0">T</span><span style="color:#d73a49;--s-dark:#F97583"> extends</span><span style="color:#6f42c1;--s-dark:#B392F0"> Record</span><span style="color:#24292e;--s-dark:#E1E4E8">&#x3C;</span><span style="color:#005cc5;--s-dark:#79B8FF">string</span><span style="color:#24292e;--s-dark:#E1E4E8">, </span><span style="color:#005cc5;--s-dark:#79B8FF">any</span><span style="color:#24292e;--s-dark:#E1E4E8">>>(</span><span style="color:#e36209;--s-dark:#FFAB70">obj</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#6f42c1;--s-dark:#B392F0"> T</span><span style="color:#24292e;--s-dark:#E1E4E8">, </span><span style="color:#e36209;--s-dark:#FFAB70">key</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#d73a49;--s-dark:#F97583"> keyof</span><span style="color:#6f42c1;--s-dark:#B392F0"> T</span><span style="color:#24292e;--s-dark:#E1E4E8">) {}</span></span></code></pre><p>简单解释一下 <code>extends</code>，这个关键字限制传进来的类型必须被右侧的类型<em>包含</em>，然后可以对原类型做后续处理（如 <code>keyof</code> 和别的体操）。</p><p>显然，这个例子里我们限制第一个参数大概需要是个对象，然后第二个参数会推导出第一个参数的下标。那么用 <code>{}</code> 可以吗？可以！</p><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#d73a49;--s-dark:#F97583">type</span><span style="color:#6f42c1;--s-dark:#B392F0"> Foo</span><span style="color:#24292e;--s-dark:#E1E4E8">&#x3C;</span><span style="color:#6f42c1;--s-dark:#B392F0">T</span><span style="color:#d73a49;--s-dark:#F97583"> extends</span><span style="color:#24292e;--s-dark:#E1E4E8"> {}> </span><span style="color:#d73a49;--s-dark:#F97583">=</span><span style="color:#d73a49;--s-dark:#F97583"> keyof</span><span style="color:#6f42c1;--s-dark:#B392F0"> T</span></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">// type A = 'a' | 'b'</span></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">type</span><span style="color:#6f42c1;--s-dark:#B392F0"> A</span><span style="color:#d73a49;--s-dark:#F97583"> =</span><span style="color:#6f42c1;--s-dark:#B392F0"> Foo</span><span style="color:#24292e;--s-dark:#E1E4E8">&#x3C;{ </span><span style="color:#e36209;--s-dark:#FFAB70">a</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#005cc5;--s-dark:#79B8FF"> 1</span><span style="color:#24292e;--s-dark:#E1E4E8">; </span><span style="color:#e36209;--s-dark:#FFAB70">b</span><span style="color:#d73a49;--s-dark:#F97583">:</span><span style="color:#005cc5;--s-dark:#79B8FF"> 2</span><span style="color:#24292e;--s-dark:#E1E4E8"> }></span></span>
<span class="line"><span style="color:#6a737d;--s-dark:#6A737D">// type B = 'toString' | 'toFixed' | 'toExponential' | 'toPrecision' | 'valueOf' | 'toLocaleString'</span></span>
<span class="line"><span style="color:#d73a49;--s-dark:#F97583">type</span><span style="color:#6f42c1;--s-dark:#B392F0"> B</span><span style="color:#d73a49;--s-dark:#F97583"> =</span><span style="color:#6f42c1;--s-dark:#B392F0"> Foo</span><span style="color:#24292e;--s-dark:#E1E4E8">&#x3C;</span><span style="color:#005cc5;--s-dark:#79B8FF">1</span><span style="color:#24292e;--s-dark:#E1E4E8">></span></span></code></pre><p><q>这不对</q>，你可能想这么说。这一眼看上去不符合你对用户的用法的期待，但是类型和运行时上都是允许的。</p><!-- prettier-ignore --><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#6f42c1;--s-dark:#B392F0">foo</span><span style="color:#24292e;--s-dark:#E1E4E8">(</span><span style="color:#005cc5;--s-dark:#79B8FF">1</span><span style="color:#24292e;--s-dark:#E1E4E8">, </span><span style="color:#032f62;--s-dark:#9ECBFF">'toString'</span><span style="color:#24292e;--s-dark:#E1E4E8">); </span><span style="color:#6a737d;--s-dark:#6A737D">// ok</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">(</span><span style="color:#005cc5;--s-dark:#79B8FF">1</span><span style="color:#24292e;--s-dark:#E1E4E8">)[</span><span style="color:#032f62;--s-dark:#9ECBFF">'toString'</span><span style="color:#24292e;--s-dark:#E1E4E8">] </span><span style="color:#6a737d;--s-dark:#6A737D">// ok</span></span></code></pre><p>我建议所有人都把 <code>extends Record&lt;string, any&gt;</code> 换成 <code>extends {}</code>，因为</p><ul><li>对类型的限制更宽松</li><li>更短，好写好读</li><li>（性能上）更快</li><li>（语义上）更正确</li></ul><h3 id="typescript-eslint-历史遗留问题"><code>typescript-eslint</code> 历史遗留问题</h3><p><a target="_blank" rel="noopener" href="https://typescript-eslint.io/rules/ban-types/">typescript-eslint 默认禁止你使用 <code>Object</code> 和 <code>{}</code></a>，前者没什么问题，但 <code>{}</code> 实际上是很有用的类型。这纯粹是因为 TypeScript 以前的 <code>{}</code> 没那么好用。</p><p>你可以添加以下规则来覆盖它对 <code>{}</code> 的限制：</p><!-- prettier-ignore --><pre class="shiki shiki-themes github-light github-dark" style="background-color:#fff;--s-dark-bg:#24292e;color:#24292e;--s-dark:#e1e4e8" tabindex="0"><code><span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">{</span></span>
<span class="line"><span style="color:#005cc5;--s-dark:#79B8FF">  "@typescript-eslint/ban-types"</span><span style="color:#24292e;--s-dark:#E1E4E8">: [</span><span style="color:#032f62;--s-dark:#9ECBFF">"error"</span><span style="color:#24292e;--s-dark:#E1E4E8">, {</span></span>
<span class="line"><span style="color:#005cc5;--s-dark:#79B8FF">    "types"</span><span style="color:#24292e;--s-dark:#E1E4E8">: { </span><span style="color:#005cc5;--s-dark:#79B8FF">"{}"</span><span style="color:#24292e;--s-dark:#E1E4E8">: </span><span style="color:#005cc5;--s-dark:#79B8FF">false</span><span style="color:#24292e;--s-dark:#E1E4E8"> },</span></span>
<span class="line"><span style="color:#005cc5;--s-dark:#79B8FF">    "extendDefaults"</span><span style="color:#24292e;--s-dark:#E1E4E8">: </span><span style="color:#005cc5;--s-dark:#79B8FF">true</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">  }]</span></span>
<span class="line"><span style="color:#24292e;--s-dark:#E1E4E8">}</span></span></code></pre><footer><p><a href="http://creativecommons.org/publicdomain/zero/1.0/">CC0</a> 2023 @ hyrious</p></footer><link rel="stylesheet" href="/assets/index-vWxNvpCb.css"></body></html>